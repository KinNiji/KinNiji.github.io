<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>数据结构 | NijiBlog</title>

    <meta name="description" content="笔记">
    <meta name="keywords" content="blog">

    

    <meta property="og:locale" content="cn,ja,default" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "数据结构 | NijiBlog"  />
    <meta property="og:description" content= "笔记" />
    <meta property="og:url" content="https://kinniji.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="Niji" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="笔记" />
    <meta name="twitter:title" content="数据结构 | NijiBlog"/>
    <meta name="twitter:description" content="笔记"/>
    <script type="application/ld+json">
        {
            "description": "笔记",
            "author": { "@type": "Person", "name": "Niji" },
            "@type": "BlogPosting",
            "url": "https://kinniji.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "https://KinNiji.github.io/images/avatar.jpg"
            },
            "name": "Niji"
            },
            "headline": "数据结构 | NijiBlog",
            "datePublished": "2022-08-31T16:00:00.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https://kinniji.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1654266144177.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1654266144177.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="Niji">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>NijiBlog</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">首页</a>
                
                <a href="/archives">归档</a>
                
                <a href="/friends">收藏</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/KinNiji">
        <ion-icon name="github"></ion-icon>
    </a>

    <a class="social" target="_blank" href="">
        <ion-icon name=""></ion-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">首页</a>
                    
                    <a href="/archives">归档</a>
                    
                    <a href="/friends">收藏</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-cl88bb4qq0000jok14bmdetqr" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      数据结构
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2022-08-31T16:00:00.000Z" itemprop="datePublished">2022/09/01</time>
</div>

            
            <div class="article-category">
                <a class="article-category-link" href="/categories/%E8%80%83%E7%A0%94/">考研</a>,<a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a>
            </div>
            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>
            </div>
            

            
            <div class="article-busuanzi">
                <span id="busuanzi_value_page_pv">N</span> 人看过
            </div>
            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <h1 id="绪论">0. 绪论</h1>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">符号</th>
<th style="text-align: left;">含义</th>
<th style="text-align: left;">通俗理解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Θ</td>
<td style="text-align: left;">精确的渐近行为</td>
<td style="text-align: left;">相当于“=”</td>
</tr>
<tr class="even">
<td style="text-align: left;">O</td>
<td style="text-align: left;">上界</td>
<td style="text-align: left;">相当于“&lt;=”</td>
</tr>
<tr class="odd">
<td style="text-align: left;">o</td>
<td style="text-align: left;">松上界</td>
<td style="text-align: left;">相当于“&lt;”</td>
</tr>
<tr class="even">
<td style="text-align: left;">Ω</td>
<td style="text-align: left;">下界</td>
<td style="text-align: left;">相当于“&gt;=”</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ω</td>
<td style="text-align: left;">松下界</td>
<td style="text-align: left;">相当于“&gt;”</td>
</tr>
</tbody>
</table>
<p>O(1) &lt; O(<span class="math inline">\(log_2n\)</span>) &lt; O(n) &lt; O(<span class="math inline">\(nlog_2n\)</span>) &lt; O(<span class="math inline">\(n^2\)</span>) &lt; O(<span class="math inline">\(n^3\)</span>) &lt; O(<span class="math inline">\(2^n\)</span>) &lt; O(n!) &lt; O(<span class="math inline">\(n^n\)</span>)</p>
<p>常数 &lt; 对数函数 &lt; 幂函数 &lt; 指数函数 &lt; 阶乘</p>
<p>比较时求极限洛必达</p>
<h1 id="线性表">1. 线性表</h1>
<p>线性表：由n个数据元素组成的有限序列，所有元素具有相同的数据类型。</p>
<h2 id="顺序表">顺序表***</h2>
<h3 id="存储结构">存储结构</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序表</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> SqList&#123;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    ElemType elem[MAX_SIZE];</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>&#125;SqList;</span></code></pre></div>
<h3 id="初始化">初始化</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Status Init_SqList(SqList *L)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序表的初始化</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    L-&gt;elem = (ElemType *) malloc(MAX_SIZE * <span class="kw">sizeof</span>(ElemType));</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (!L-&gt;elem)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        L-&gt;length = <span class="dv">0</span>;</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OK;</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="插入">插入</h3>
<p>复杂度O(n)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>Status Insert_SqList(SqList *L, <span class="dt">int</span> i, ElemType e)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 在顺序表索引为i处插入元素</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 索引错误</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i &lt; <span class="dv">0</span> || i &gt; L-&gt;length-<span class="dv">1</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 溢出错误</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L-&gt;length &gt;= MAX_SIZE)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OVERFLOW;</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i-1后的所有元素后移</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> j = L-&gt;length-<span class="dv">1</span>; j &gt;= i-<span class="dv">1</span>; --j)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        L-&gt;elem[j+<span class="dv">1</span>] = L-&gt;elem[j];</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 在i-1插入新元素</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    L-&gt;elem[i-<span class="dv">1</span>] = e;</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 长度加1</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    L-&gt;length++;</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="删除">删除</h3>
<p>复杂度O(n)</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>ElemType Delete_SqList(SqList *L, <span class="dt">int</span> i)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 删除顺序表中索引为i的元素</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: ElemType 被删除元素的值</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 空表错误</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L-&gt;length == <span class="dv">0</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 索引错误</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i &lt; <span class="dv">0</span> || i &gt; L-&gt;length-<span class="dv">1</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 保存被删除元素的值</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    ElemType x = L-&gt;elem[i-<span class="dv">1</span>];</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i后的所有元素前移</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> j = i; j &lt;= L-&gt;length; j++)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        L-&gt;elem[j-<span class="dv">1</span>] = L-&gt;elem[j];</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 长度减1</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    L-&gt;length--;</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 返回被删除元素的值</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x;</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="查找">查找</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Locate_Elem(SqList *L, ElemType e)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 定位顺序表中第一个指定值的元素</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: int 元素索引（未找到返回-1）</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; L-&gt;length; i++)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (L-&gt;elem[i] == e)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> i;</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="单链表">单链表***</h2>
<h3 id="存储结构-1">存储结构</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 单链表</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> LNode&#123;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 数据域</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指针域</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> LNode *next;</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>&#125;LNode, *LinkList;</span></code></pre></div>
<h3 id="初始化-1">初始化</h3>
<p>头插法</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>LinkList HeadInsert_LinkList(<span class="dt">void</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 头插法创建单链表</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> null:</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: LNode 链表的头结点head</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data;</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    LNode *head, *p;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 创建头结点head</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    head = (LinkList) malloc(<span class="kw">sizeof</span>(LNode));</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    head-&gt;next = NULL;</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 从data读入数据，以32767作为结束标志</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    scanf(<span class="st">&quot;%d&quot;</span>, &amp;data);</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(data != <span class="dv">32767</span>)&#123;</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 创建新结点p并赋值</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        p = (LNode *) malloc(<span class="kw">sizeof</span>(LNode));</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        p-&gt;data = data;</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 钩链</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = head-&gt;next;</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        head-&gt;next = p;</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 返回头结点head</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> head;</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>尾插法</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>LinkList TailInsert_LinkList(<span class="dt">void</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 尾插法创建单链表（区别在于使用了一个额外的指针q代替head不断向后）</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> null:</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: LNode 链表的头结点head</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data;</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    LNode *head, *p, *q;</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 创建头结点head，结点q</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    head = q = (LinkList) malloc(<span class="kw">sizeof</span>(LNode));</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    q-&gt;next = NULL;</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 从data读入数据，以32767作为结束标志</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    scanf(<span class="st">&quot;%d&quot;</span>, &amp;data);</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(data != <span class="dv">32767</span>)&#123;</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 创建新结点q并赋值</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        p = (LinkList) malloc(<span class="kw">sizeof</span>(LNode));</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        p-&gt;data = data;</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 钩链</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = q-&gt;next;</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        q-&gt;next = p;</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        q = p;</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 返回头结点head</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> head;</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="插入-1">插入</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Status Insert_LinkList(LinkList L, <span class="dt">int</span> i, ElemType e)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 创建值为e的结点并插入到单链表的第i个</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 值</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    LNode *p = L-&gt;next, *q;</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j;</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 跳过i-1个结点，单链表下一节点为空时跳出</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = <span class="dv">0</span>; p != NULL &amp;&amp; j &lt; i - <span class="dv">1</span>; j++)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        p = p-&gt;next;</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j != i - <span class="dv">1</span>)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        q = (LNode *) malloc(<span class="kw">sizeof</span>(LNode));</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        q-&gt;data = e;</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        q-&gt;next = p-&gt;next;</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = q;</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OK;</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="删除-1">删除</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Status Delete_LinkList(LinkList L, <span class="dt">int</span> i)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 删除单链表中第i个结点</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    LNode *p = L, *q = L-&gt;next;</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 跳过i-1个结点，单链表下一节点为空时跳出</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j;</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = <span class="dv">0</span>; q != NULL &amp;&amp; j &lt; i-<span class="dv">1</span>; j++)&#123;</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        p = q;</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        q = q-&gt;next;</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 索引错误或单链表长度为0</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j != i-<span class="dv">1</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = q-&gt;next;</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        free(q);</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OK;</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="查找-1">查找</h3>
<p>按序号查找</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>LNode *Get_Node(LinkList L, <span class="dt">int</span> i)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 取单链表中第i个结点</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: LNode 结点指针（未找到为NULL）</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    LNode *p = L-&gt;next;</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 跳过i个结点，单链表下一节点为空时跳出</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j;</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = <span class="dv">0</span>; p != NULL &amp;&amp; j &lt; i; j++)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        p = p-&gt;next;</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 索引错误或单链表长度为0</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j != i)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> NULL;</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p;</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>按值查找</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>LNode *Locate_Node(LNode *L, ElemType key)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 查找链表中值为key的第一个节点</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 关键值</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: LNode 结点指针（未找到为NULL）</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    LNode *p = L-&gt;next;</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL &amp;&amp; p-&gt;data != key)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        p = p-&gt;next;</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 没有符合条件的结点</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (p-&gt;data != key)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> NULL;</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p;</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="循环链表">循环链表***</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 判断是否为空</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>head-&gt;next == head</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 判断是否为链尾</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>p-&gt;next == head</span></code></pre></div>
<h2 id="双向链表">双向链表***</h2>
<h3 id="存储结构-2">存储结构</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 双向链表</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> DNode&#123;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 数据域</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指针域</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> DNode *prior, *next;</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>&#125;DNode, *DLinkList;</span></code></pre></div>
<h3 id="插入-2">插入</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>Status Insert_DLinkList(DLinkList L, <span class="dt">int</span> i, ElemType e)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 创建值为e的结点并插入到双向链表的第i个</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 值</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    DNode *p = L-&gt;next, *q;</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j;</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 跳过i-1个结点，单链表下一节点为空时跳出</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = <span class="dv">0</span>; p != NULL &amp;&amp; j &lt; i - <span class="dv">1</span>; j++)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        p = p-&gt;next;</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j != i - <span class="dv">1</span>)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        q = (DNode *) malloc(<span class="kw">sizeof</span>(DNode));</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        q-&gt;data = e;</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        q-&gt;next = p-&gt;next;</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 相对于单链表的额外步骤1</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        p-&gt;next-&gt;prior = q;</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = q;</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 相对于单链表的额外步骤2</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>        q-&gt;prior = p;</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OK;</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="删除-2">删除</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>Status Delete_DLinkList(DLinkList L, <span class="dt">int</span> i)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 删除双向链表中第i个结点</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    DNode *p = L, *q = L-&gt;next;</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 跳过i-1个结点，单链表下一节点为空时跳出</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j;</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = <span class="dv">0</span>; q != NULL &amp;&amp; j &lt; i-<span class="dv">1</span>; j++)&#123;</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        p = q;</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        q = q-&gt;next;</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 索引错误或单链表长度为0</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j != i-<span class="dv">1</span>)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = q-&gt;next;</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 相对于单链表的额外步骤</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>        q-&gt;next-&gt;prior = p;</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>        free(q);</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OK;</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="稀疏多项式">稀疏多项式*</h2>
<h3 id="存储结构-3">存储结构</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序表一元多项式</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> Ploy&#123;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> coef;</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> expn;</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>&#125;Ploy;</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> PloySqList&#123;</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    Ploy ploy[MAX_SIZE];</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length;</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>&#125;PloySqList;</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链表一元多项式</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> PloyLNode&#123;</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> coef;</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> expn;</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> PloyLNode *next;</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>&#125;PloyLNode, *PloyLinkList;</span></code></pre></div>
<h3 id="运算">运算</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>PloyLinkList Add_PloyLinkList(PloyLinkList La, PloyLinkList Lb)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 两个有序多项式链表相加，生成一个新的结果有序多项式链表，且原来两个链表不变</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> La: 有序多项式链表a</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Lb: 有序多项式链表b</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: PloyLinkList</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    PloyLinkList Lc = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    PloyLNode *pa = La-&gt;next, *pb = Lb-&gt;next, *pc = Lc, *p;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> x;</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (pa != NULL &amp;&amp; pb != NULL)&#123;</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (pa-&gt;expn &lt; pb-&gt;expn)&#123;</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>            p = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>            p-&gt;coef = pa-&gt;coef;</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>            p-&gt;expn = pa-&gt;expn;</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>            p-&gt;next = NULL;</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>            pc-&gt;next = p;</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>            pc = p;</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>            pa = pa-&gt;next;</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> <span class="cf">if</span> (pa-&gt;expn &gt; pb-&gt;expn)&#123;</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>            p = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>            p-&gt;coef = pb-&gt;coef;</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>            p-&gt;expn = pb-&gt;expn;</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>            p-&gt;next = NULL;</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>            pc-&gt;next = p;</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>            pc = p;</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>            pb = pb-&gt;next;</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> &#123;</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>            x = pa-&gt;coef + pb-&gt;coef;</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (x &gt;= <span class="fl">1.0e-6</span> &amp;&amp; x &lt;= -<span class="fl">1.0e-6</span>)&#123;</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>                p = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>                p-&gt;coef = x;</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>                p-&gt;expn = pb-&gt;expn;</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>                p-&gt;next = NULL;</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>                pc-&gt;next = p;</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>                pc = p;</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>            pa = pa-&gt;next;</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>            pb = pb-&gt;next;</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (pa != NULL) &#123;</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (pa != NULL) &#123;</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>            p = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>            p-&gt;coef = pa-&gt;coef;</span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>            p-&gt;expn = pa-&gt;expn;</span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>            p-&gt;next = NULL;</span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>            pc-&gt;next = p;</span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>            pc = p;</span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>            pa = pa-&gt;next;</span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>    &#125; <span class="cf">else</span> &#123;</span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (pb != NULL) &#123;</span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a>            p = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a>            p-&gt;coef = pb-&gt;coef;</span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a>            p-&gt;expn = pb-&gt;expn;</span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a>            p-&gt;next = NULL;</span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a>            pc-&gt;next = p;</span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a>            pc = p;</span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a>            pb = pb-&gt;next;</span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb18-64"><a href="#cb18-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Lc;</span>
<span id="cb18-65"><a href="#cb18-65" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="广义表">广义表</h2>
<p>广义表中的元素可以是原子项或广义表</p>
<p>表长：广义表中所包含的元素的个数</p>
<p>表深：广义表中括号的最大层数</p>
<h3 id="存储结构-4">存储结构</h3>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 广义表</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> GLNode&#123;</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 标志域，1为表结点，0为原子结点</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tag;</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 表结点和原子结点的共用体</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> &#123;</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 原子节点的值域</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        ElemType value;</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 表头表尾指针</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> &#123;</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> GLNode *hp, *tp;</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        &#125;ptr;</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    &#125;Gdata;</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>&#125;GLNode;</span></code></pre></div>
<h3 id="扩展线性链表存储结构">扩展线性链表存储结构</h3>
<p>上面的存储方法表结点太多，造成空间浪费</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 扩展线性链表存储结构</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> gLNode&#123;</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 标志域，1为表结点，0为原子结点</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tag;</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 表结点和原子结点的共用体</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> &#123;</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 原子节点的值域</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        ElemType data;</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 表节点的值域</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> gLNode *sList;</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    &#125;;</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 原子结点或表结点的下一个同层结点</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> gLNode *link;</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>&#125;gLNode;</span></code></pre></div>
<h1 id="栈">2. 栈</h1>
<h2 id="基本概念">基本概念**</h2>
<p>栈：先进后出(FILO)线性表</p>
<p>栈顶/表尾(Top)：允许进行插入、删除操作的一端</p>
<p>栈底/表头(Bottom)：固定端</p>
<h2 id="存储结构和基本操作">存储结构和基本操作**</h2>
<h3 id="动态顺序存储">动态顺序存储</h3>
<p>栈空：top=bottom</p>
<p>栈满：top-bottom&gt;=size</p>
<p>进栈(Push)：元素插入栈顶，top++</p>
<p>出栈(Pop)：--top，此时top指向栈顶元素，然后取出该元素</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 动态顺序栈</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> Stack</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    ElemType *bottom;</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    ElemType *top;</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size;</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>&#125;Stack;</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>Stack Init_Stack()</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 动态顺序栈的初始化</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Stack</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    Stack S;</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    S.bottom = (ElemType *)malloc (MAX_SIZE * <span class="kw">sizeof</span>(ElemType));</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    S.top = S.bottom;</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    S.size = MAX_SIZE;</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S;</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>Status Push_Stack(Stack S, ElemType e)</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 动态顺序栈的压栈</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 动态顺序栈</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (S.top - S.bottom &gt;= S.size)&#123;</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>        S.bottom = (ElemType *)realloc (S.bottom, (INCREASEMENT + S.size) * <span class="kw">sizeof</span>(ElemType));</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (!S.bottom)</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> ERROR;</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>        S.top = S.bottom + S.size;</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>        S.size += INCREASEMENT;</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>    *S.top++ = e;</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>Status Pop_Stack(Stack S, ElemType *e)</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 动态顺序栈的出栈</span></span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 动态顺序栈</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (S.top == S.bottom)</span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a>    e = --S.top;</span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="静态顺序存储">静态顺序存储</h3>
<p>栈空：top=0</p>
<p>栈满：top=maxsize-1</p>
<p>进栈(Push)：++top，元素插入栈顶</p>
<p>出栈(Pop)：top指向栈顶元素，取出该元素，然后top--</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 静态顺序栈</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> SqStack&#123;</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    ElemType stackArray[MAX_SIZE];</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top;</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>&#125;SqStack;</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>SqStack Init_SqStack()</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 静态顺序栈的初始化</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: SqStack</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    SqStack S;</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    S.top = <span class="dv">0</span>;</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S;</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>Status Push_SqStack(SqStack S, ElemType e)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 静态顺序栈的压栈</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 静态顺序栈</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span>&#123;</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (S.top == MAX_SIZE - <span class="dv">1</span>)</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OVERFLOW;</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>    S.stackArray[++S.top] = e;</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>Status Pop_SqStack(SqStack S, ElemType *e)</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 静态顺序栈的出栈</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 静态顺序栈</span></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (S.top == <span class="dv">0</span>)</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>    *e = S.stackArray[S.top--];</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="链式存储">链式存储</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式栈</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> StackLNode&#123;</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> StackLNode *next;</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>&#125;StackLNode, *LinkStack;</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>LinkStack Init_LinkStack()</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式栈的初始化</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 链式栈</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    StackLNode *top;</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    top = (StackLNode *)malloc (<span class="kw">sizeof</span>(StackLNode));</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    top-&gt;next = NULL;</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> top;</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>Status Push_LinkStack(StackLNode *top, ElemType e)</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式栈的压栈</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 链式栈</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>    StackLNode *p;</span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>    p = (StackLNode *)malloc (<span class="kw">sizeof</span>(StackLNode));</span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>    p-&gt;data = e;</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 头插法，返回头结点指针</span></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    p-&gt;next = top-&gt;next;</span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>    top-&gt;next = p;</span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>Status Pop_LinkStack(StackLNode *top, ElemType *e)</span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式栈的出栈</span></span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 链式栈</span></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a>    StackLNode *p;</span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (top-&gt;next == NULL)</span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>    p = top-&gt;next;</span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a>    *e = p-&gt;data;</span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a>    top-&gt;next = p-&gt;next;</span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a>    free(p);</span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb23-56"><a href="#cb23-56" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h1 id="队列">3. 队列</h1>
<h2 id="基本概念-1">基本概念</h2>
<p>队列：先进先出(FIFO)线性表</p>
<p>队首(Front)：允许进行删除的一端</p>
<p>队尾(Rear)：允许进行插入的一端</p>
<p>队列空：front=rear</p>
<p>入队：元素插入队尾，rear++</p>
<p>出队：取出front所指向的元素，front++</p>
<h2 id="存储结构和基本操作-1">存储结构和基本操作**</h2>
<h3 id="顺序存储循环队列">顺序存储（循环队列）</h3>
<p>传统队列front和rear不断向前会造成假溢出现象，故需要通过对front和rear进行模运算（+1取模后若为0则取0）实现循环队列</p>
<p>对空和队满时，front均等于rear，因此入队前判断队满改为(rear + 1) % MAX_SIZE == fornt，如此一来rear所指单元始终为空（牺牲了一个存储单元）</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序储存队列（循环队列）</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> SqQueue&#123;</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    ElemType queueArray[MAX_SIZE];</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> front, rear;</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>&#125;SqQueue;</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>SqQueue *Init_CircularQueue()</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 循环队列的初始化</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: SqQueue</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    SqQueue *Q = (SqQueue *) malloc(<span class="kw">sizeof</span>(SqQueue));</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    Q-&gt;front = Q-&gt;rear = <span class="dv">0</span>;</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Q;</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>Status Insert_CircularQueue(SqQueue *Q, ElemType e)</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 循环队列的插入</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Q: 循环队列</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 插入元素</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ((Q-&gt;rear + <span class="dv">1</span>) % MAX_SIZE == Q-&gt;front)</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OVERFLOW;</span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>    Q-&gt;queueArray[Q-&gt;rear] = e;</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>    Q-&gt;rear = (Q-&gt;rear + <span class="dv">1</span>) % MAX_SIZE;</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>Status Delete_CircularQueue(SqQueue *Q, ElemType *e)</span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 循环队列的删除</span></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Q: 循环队列</span></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 删除元素</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (Q-&gt;front == Q-&gt;rear)</span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a>    *e = Q-&gt;queueArray[Q-&gt;front];</span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a>    Q-&gt;front = (Q-&gt;front + <span class="dv">1</span>) % MAX_SIZE;</span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="链式存储-1">链式存储</h3>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式储存队列</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> QueueLNode&#123;</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> QueueLNode *next;</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>&#125;QueueLNode;</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> LinkQueue&#123;</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    QueueLNode *front, *rear;</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>&#125;LinkQueue;</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>LinkQueue *Init_LinkQueue()</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式队列的初始化</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: LinkQueue</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    LinkQueue *Q = (LinkQueue *)malloc (<span class="kw">sizeof</span>(LinkQueue));</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    QueueLNode *p = (QueueLNode *)malloc (<span class="kw">sizeof</span>(QueueLNode));</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    p-&gt;next = NULL;</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    Q-&gt;front = Q-&gt;rear = p;</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Q;</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>Status Insert_LinkQueue(LinkQueue *Q, ElemType e)</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式队列的插入</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Q: 链式队列</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 插入元素</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>    QueueLNode *p = (QueueLNode *)malloc (<span class="kw">sizeof</span>(QueueLNode));</span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>    p-&gt;data = e;</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>    p-&gt;next = NULL;</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>    Q-&gt;rear-&gt;next = p;</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>    Q-&gt;rear = p;</span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>Status Delete_LinkQueue(LinkQueue *Q, ElemType *e)</span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式队列的删除</span></span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Q: 链式队列</span></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 删除元素</span></span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a>    QueueLNode *p;</span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (Q-&gt;front == Q-&gt;rear)</span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>    p = Q-&gt;front-&gt;next;</span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a>    *e = p-&gt;data;</span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>    Q-&gt;front-&gt;next = p-&gt;next;</span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 当队列只有一个结点时使队尾指针指向该结点</span></span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (p == Q-&gt;rear)</span>
<span id="cb25-58"><a href="#cb25-58" aria-hidden="true" tabindex="-1"></a>        Q-&gt;rear = Q-&gt;front;</span>
<span id="cb25-59"><a href="#cb25-59" aria-hidden="true" tabindex="-1"></a>    free(p);</span>
<span id="cb25-60"><a href="#cb25-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb25-61"><a href="#cb25-61" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb25-62"><a href="#cb25-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-63"><a href="#cb25-63" aria-hidden="true" tabindex="-1"></a>Status Destory_LinkQueue(LinkQueue *Q)</span>
<span id="cb25-64"><a href="#cb25-64" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb25-65"><a href="#cb25-65" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式队列的释放</span></span>
<span id="cb25-66"><a href="#cb25-66" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Q: 链式队列</span></span>
<span id="cb25-67"><a href="#cb25-67" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb25-68"><a href="#cb25-68" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb25-69"><a href="#cb25-69" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb25-70"><a href="#cb25-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (Q-&gt;front != NULL)&#123;</span>
<span id="cb25-71"><a href="#cb25-71" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 从队首开始每次释放一个结点，直到所有结点都被释放</span></span>
<span id="cb25-72"><a href="#cb25-72" aria-hidden="true" tabindex="-1"></a>        Q-&gt;rear = Q-&gt;front-&gt;next;</span>
<span id="cb25-73"><a href="#cb25-73" aria-hidden="true" tabindex="-1"></a>        free(Q-&gt;front);</span>
<span id="cb25-74"><a href="#cb25-74" aria-hidden="true" tabindex="-1"></a>        Q-&gt;front = Q-&gt;rear;</span>
<span id="cb25-75"><a href="#cb25-75" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb25-76"><a href="#cb25-76" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h1 id="矩阵">4. 矩阵</h1>
<h2 id="稀疏矩阵">稀疏矩阵*</h2>
<p>稀疏矩阵：矩阵中有大量的零元素，对于m×n矩阵，稀疏因子δ=s/(m×n)≤0.05，其中s为非零元素个数</p>
<p>稀疏矩阵的三元组存储结构：所有非零元素只储存行下标、列下标、元素值</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 三元组</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> Triple&#123;</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> row, col;</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    ElemType elem;</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>&#125;Triple;</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 三元组稀疏矩阵</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> TMatrix&#123;</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> rowNum, colNum, nonzeroNum;</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    Triple data[MAX_SIZE];</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>&#125;TMatrix;</span></code></pre></div>
<p>稀疏矩阵的转置：</p>
<p>对于有t个非零元素的m×n矩阵，复杂度O(n×t)，当t与m×n一个数量级时，复杂度O(m×n^2)，而传统矩阵的转置复杂度O(m×n)，虽然节省了储存空间，但复杂度增加，故仅在t&lt;&lt;m×n时使用稀疏矩阵</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Transpose_TripleMatrix(TMatrix A, TMatrix B)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 稀疏矩阵的转置</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> A: 稀疏矩阵A</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> B: 空矩阵B，返回转置后的矩阵</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, col;</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    B.rowNum = A.colNum;</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    B.colNum = A.rowNum;</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    B.nonzeroNum = A.nonzeroNum;</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (B.nonzeroNum != <span class="dv">0</span>)&#123;</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>        j = <span class="dv">0</span>;</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 逐列遍历矩阵的非零元素</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (col = <span class="dv">1</span>; col &lt;= A.colNum; col++)</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; A.nonzeroNum; i++)</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (A.data[i].col == col)&#123;</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>                    B.data[j].row = A.data[i].col;</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>                    B.data[j].col = A.data[i].row;</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>                    B.data[j].elem = A.data[i].elem;</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>                    j++;</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>稀疏矩阵的乘法：</p>
<p>对于有t个非零元素的m×n矩阵A和n×p矩阵B，复杂度O(<span class="math inline">\(m×p+t_A×t_B/m\)</span>)，传统矩阵的转置复杂度O(m×n×p)</p>
<h1 id="树">5. 树</h1>
<h2 id="基本概念-2">基本概念*</h2>
<p>结点：一个数据元素及其若干指向其子树的分支</p>
<p>祖先结点、子孙结点、双亲结点（父节点）、孩子结点（子节点）、兄弟结点</p>
<p>度：结点的度等于结点子树的数量，树的度等于树中结点的度的最大值</p>
<p>m叉树：任意结点的度 ≤ m，可以为空树</p>
<p>叶子结点（终端结点）：度等于0的结点</p>
<p>分支结点（非终端结点）：度大于0的结点</p>
<p>结点的深度：自顶向下累加</p>
<p>结点的高度：自底向上累加</p>
<p>结点的层次：根节点为第一层，其子节点为第二层，以此类推</p>
<p>树的深度/高度：结点的最大层数</p>
<p>有序树：次序从左到右</p>
<p>无序树：兄弟结点之间没有次序</p>
<p>路径：两结点间所经过的结点序列构成路径，路径长度等于所经过的边的数量，路径的方向为自顶向下</p>
<p>树的路径长度：从根结点到每一个结点的路径长度之和</p>
<p>森林：若干互不相交的树的集合</p>
<p><strong>性质：</strong></p>
<p>结点数 = 所有结点度数和 + 1</p>
<p>度为m的树第i层至多有<span class="math inline">\(m^{i-1}\)</span>个结点</p>
<p>高度为h的m叉树至多有<span class="math inline">\(\frac{m^h-1}{m-1}\)</span>个结点（等比数列求和）</p>
<p>高度为h度为m的树至少有h + m - 1个结点</p>
<p>具有n个结点的m叉树最小高度为<span class="math inline">\(\lceil log_m(n(m-1)+1)\rceil\)</span>（<span class="math inline">\(\frac{m^{h-1}}{m-1}&lt;n≤\frac{m^h-1}{m-1}\)</span>）</p>
<h2 id="二叉树">二叉树***</h2>
<h3 id="基本概念-3">基本概念</h3>
<p>二叉树：每个结点至多有2棵子树</p>
<p>满二叉树：深度为k的二叉树有<span class="math inline">\(2^k-1\)</span>个结点，对其进行“自上而下，自左至右”的原则进行连续编号</p>
<p>完全二叉树：每一个结点与满二叉树的一一对应。</p>
<p>二叉排序/查找树(BST)：左子树上所有结点的关键字小于根节点，右子树上所有结点的关键字大于根节点</p>
<p>平衡二叉树(AVL)：任意结点的左子树与右子树的深度之差小于等于1，简写源自作者名</p>
<h3 id="性质">性质</h3>
<p>设度为0/1/2的结点个数分别为<span class="math inline">\(n_0/n_1/n_2\)</span>，有<span class="math inline">\(n_0+n_1+n_2=n1+2n_2+1\)</span>，即<span class="math inline">\(n_0=n_2+1\)</span></p>
<p>高度为k的二叉树至多有<span class="math inline">\(2^k-1\)</span>个结点，第i层至多有<span class="math inline">\(2^{i-1}\)</span>个结点</p>
<p>对于完全二叉树，i &gt; 1时：</p>
<ul>
<li><p>i所在层次为<span class="math inline">\(\lfloor log_2i\rfloor+1\)</span></p></li>
<li><p>i的父节点为<span class="math inline">\(\lfloor\frac{i}{2}\rfloor\)</span>：</p>
<ul>
<li><p>若i为偶，父节点为<span class="math inline">\(\frac{i}{2}\)</span>，i为父节点的左孩子</p></li>
<li><p>若i为奇，父节点为<span class="math inline">\(\frac{i-1}{2}\)</span>，i为父节点的右孩子</p></li>
</ul></li>
</ul>
<p>对于完全二叉树，结点数为n时：</p>
<p>高度为<span class="math inline">\(\lceil log_2(n+1)\rceil\)</span>或<span class="math inline">\(\lfloor log_2n\rfloor+1\)</span>（<span class="math inline">\(2^{h-1}&lt;n≤2^h-1\)</span>）</p>
<h3 id="存储结构-5">存储结构</h3>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉树顺序存储结构</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> ElemType BTSq[MAX_SIZE];</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉树链式存储结构</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> BTLNode&#123;</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> BTLNode *lChild, *rChild;</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>&#125;BTLNode;</span></code></pre></div>
<h3 id="遍历算法">遍历算法</h3>
<h4 id="先序遍历dlr">先序遍历DLR</h4>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Preorder_Traverse_Recursion(BTLNode *T)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 先序遍历递归实现</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>        Visit(T-&gt;data);</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>        Preorder_Traverse_Recursion(T-&gt;lChild);</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>        Preorder_Traverse_Recursion(T-&gt;rChild);</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Preorder_Traverse(BTLNode *T)</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 先序遍历非递归实现</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>    BTLNode *stack[MAX_SIZE];</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>    BTLNode *p = T, *q;</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top = <span class="dv">0</span>;</span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 访问根结点</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>        Visit(p-&gt;data);</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 若右子树非空则进栈</span></span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>        q = p-&gt;rChild;</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (q != NULL)</span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>            stack[++top] = q;</span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 继续访问左子树</span></span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>        p = p-&gt;lChild;</span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 若左子树为空，且栈非空，栈顶右子树出栈</span></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (p == NULL &amp;&amp; top != <span class="dv">0</span>)</span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>            p = stack[top--];</span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h4 id="中序遍历ldr">中序遍历LDR</h4>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Inorder_Traverse_Recursion(BTLNode *T)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 中序遍历递归实现</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        Inorder_Traverse_Recursion(T-&gt;lChild);</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>        Visit(T-&gt;data);</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        Inorder_Traverse_Recursion(T-&gt;rChild);</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Inorder_Traverse(BTLNode *T)</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 中序遍历非递归实现</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>    BTLNode *stack[MAX_SIZE];</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>    BTLNode *p = T, *q;</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top = <span class="dv">0</span>;</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL || top != <span class="dv">0</span>)&#123;</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 指向左子树，循环直至左子树为空</span></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (p != NULL)&#123;</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>            stack[++top] = p;</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;lChild;</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> &#123;</span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 出栈并访问</span></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>            q = stack[top--];</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>            Visit(q-&gt;data);</span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 指向右子树</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>            p = q-&gt;rChild;</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h4 id="后续遍历lrd">后续遍历LRD</h4>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Postorder_Traverse_Recursion(BTLNode *T)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 后序遍历递归实现</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>        Postorder_Traverse_Recursion(T-&gt;lChild);</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>        Postorder_Traverse_Recursion(T-&gt;rChild);</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>        Visit(T-&gt;data);</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Postorder_Traverse(BTLNode *T)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 后序遍历非递归实现</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    BTLNode *stack[MAX_SIZE], *p = T;</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tag[MAX_SIZE], top = <span class="dv">0</span>;</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL || top != <span class="dv">0</span>)&#123;</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 若根结点非空则进栈（未被经过，tag设置为0），然后指向左子树</span></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>            stack[++top] = p;</span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>            tag[top] = <span class="dv">0</span>;</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;lChild;</span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (tag[top] == <span class="dv">0</span>)&#123;</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 若栈顶结点tag=0（左子树为空），则指向右子树，并更新tag</span></span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>            p = stack[top]-&gt;rChild;</span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>            tag[top] = <span class="dv">1</span>;</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> &#123;</span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 若栈顶结点tag=1（左右子树都为空，访问根节点），则栈顶结点出栈</span></span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>            p = stack[top--];</span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a>            Visit(p-&gt;data);</span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a>            p = NULL;</span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h4 id="层次遍历">层次遍历</h4>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Level_Traverse(BTLNode *T)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 层次遍历</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null </span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    BTLNode *Queue[MAX_NODE], *p = T;</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> front = <span class="dv">0</span>, rear = <span class="dv">0</span>;</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 根结点入队</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>        Queue[++rear] = p;</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (front &lt; rear)&#123;</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 队尾结点出队并访问</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>            p = Queue[++front];</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>            Visit(p-&gt;data);</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 左右子节点依次入队</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;lChild != NULL)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>                Queue[++rear] = p-&gt;lChild;</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;rChild != NULL)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>                Queue[++rear] = p-&gt;rChild;</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="线索二叉树">线索二叉树**</h2>
<p>线索化：修改空指针使其指向前驱或后继，使得遍历时不需要堆栈</p>
<h3 id="存储结构-6">存储结构</h3>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉线索树</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> BTTLNode&#123;</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> BTTLNode *lChild, *rChild;</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* lTag:    0   有左孩子结点，指向其左孩子结点</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="co">     *          1   无左孩子结点，指向其前驱</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="co">     * rTag:    0   有右孩子结点，指向其右孩子结点</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="co">     *          1   无右孩子结点，指向其后继</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> lTag, rTag;</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>&#125;BTTLNode;</span></code></pre></div>
<h3 id="线索化算法">线索化算法</h3>
<p>先序</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Preorder_Threading(BTTLNode *T)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 先序线索化二叉树</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 线索二叉树</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    BTTLNode *stack[MAX_NODE], *last = NULL, *p;</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top = <span class="dv">0</span>;</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>        stack[++top] = T;</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (top &gt; <span class="dv">0</span>)&#123;</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>            p = stack[top--];</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// p结点若无左孩子，则指向其前驱</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;lChild != NULL)</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>                p-&gt;lTag = <span class="dv">0</span>;</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> &#123;</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>                p-&gt;lTag = <span class="dv">1</span>;</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>                p-&gt;lChild = last;</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 更新其前驱，若前驱无右孩子，则指向p结点</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (last != NULL)&#123;</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (last-&gt;rChild != NULL)</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rTag = <span class="dv">0</span>;</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> &#123;</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rTag = <span class="dv">1</span>;</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rChild = p;</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 将前驱更新为p结点</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>            last = p;</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 右孩子先入栈，左孩子后入栈</span></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;rChild != NULL &amp;&amp; p-&gt;rTag == <span class="dv">0</span>)</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>                stack[++top] = p-&gt;rChild;</span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;lChild != NULL &amp;&amp; p-&gt;lTag == <span class="dv">0</span>)</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>                stack[++top] = p-&gt;lChild;</span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 最后一个结点无右孩子且无后继（rTag=1且rChild=NULL）</span></span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>        last-&gt;rTag = <span class="dv">1</span>;</span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>中序</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Inorder_Threading(BTTLNode *T)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 中序线索化二叉树</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 线索二叉树</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    BTTLNode *stack[MAX_NODE], *last = NULL, *p = T;</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top = <span class="dv">0</span>;</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL || top &gt; <span class="dv">0</span>)&#123;</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (p != NULL)&#123;</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 左孩子入栈直至左孩子为空</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>            stack[++top] = p;</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;lChild;</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> &#123;</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// p结点出栈，若无左孩子，则指向其前驱</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>            p = stack[top--];</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;lChild != NULL)</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>                p-&gt;lTag = <span class="dv">0</span>;</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> &#123;</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>                p-&gt;lTag = <span class="dv">1</span>;</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>                p-&gt;lChild = last;</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 更新其前驱，若前驱无右孩子，则指向p结点</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (last != NULL)&#123;</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (last-&gt;rChild != NULL)</span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rTag = <span class="dv">0</span>;</span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> &#123;</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rTag = <span class="dv">1</span>;</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rChild = p;</span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 将前驱更新为p结点</span></span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>            last = p;</span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 左孩子和根节点已入栈，右孩子入栈</span></span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;rChild;</span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 最后一个结点无右孩子且无后继（rTag=1且rChild=NULL）</span></span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>    last-&gt;rTag = <span class="dv">1</span>;</span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="遍历算法-1">遍历算法</h3>
<p>先序</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Preorder_Traverse_BiThreadTree(BTTLNode *T)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 遍历先序线索化二叉树</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 线索二叉树</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    BTTLNode *p = T;</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>        Visit(p-&gt;data);</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (p-&gt;lTag == <span class="dv">0</span>)</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;lChild;</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;rChild;</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>中序</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Inorder_Traverse_BiThreadTree(BTTLNode *T)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 遍历中序线索化二叉树</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 线索二叉树</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    BTTLNode *p;</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>        p = T;</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (p-&gt;lTag == <span class="dv">0</span>)</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;lChild;</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>            Visit(p-&gt;data);</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;rTag == <span class="dv">1</span>)</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>                p = p-&gt;rChild;</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> &#123;</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>                p = p-&gt;rChild;</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> (p-&gt;lTag == <span class="dv">0</span>)</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>                    p = p-&gt;lChild;</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="树和森林">树和森林**</h2>
<h3 id="树的存储结构">树的存储结构</h3>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 双亲表示法（顺序存储结构）</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> PTNode&#123;</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> parent;</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>&#125;PTNode;</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> PTree&#123;</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    PTNode nodes[MAX_SIZE];</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> root;</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num;</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>&#125;PTree;</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 孩子链表示法</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> CTableLNode&#123;</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> childNo;</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> CTableLNode *next;</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>&#125;CTableLNode;</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> CHeadLNode&#123;</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>    CTableLNode *first;</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>&#125;CHeadNode;</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> CTree&#123;</span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>    CHeadNode nodes[MAX_SIZE];</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> root;</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num;</span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>&#125;CTree;</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 孩子兄弟表示法（二叉树表示法）</span></span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> CSLNode&#123;</span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> CSLNode *firstChild, *firstSibling;</span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>&#125;CSLNode;</span></code></pre></div>
<h3 id="树森林二叉树的相互转化">树、森林、二叉树的相互转化</h3>
<p>树 &lt;-&gt; 二叉树：用孩子兄弟表示法表示树，左孩子为第一个孩子，右孩子为第一个兄弟</p>
<p>森林 -&gt; 二叉树：森林的每棵树用孩子兄弟表示法表示，表示后的所有二叉树从第二棵开始每棵接在前一棵的根结点的右结点</p>
<p>二叉树 -&gt; 森林：二叉树从右结点断开，子树以此类推，所有二叉树再转化为树</p>
<h3 id="树和森林的遍历">树和森林的遍历</h3>
<p><strong>树：</strong></p>
<p>先根遍历：与对应二叉树的先序遍历相同</p>
<p>后根遍历：与对应二叉树的后序遍历相同</p>
<p>层序遍历：一层层地遍历</p>
<p><strong>森林</strong>：</p>
<p>先序遍历：按先根遍历的方式遍历森林中的每一棵树</p>
<p>中序遍历：按后根遍历的方式遍历森林中的每一棵树</p>
<h2 id="哈夫曼树">哈夫曼树**</h2>
<p>哈夫曼树又称最优二叉树。以字符集作为叶子结点，频度作为结点的权值构造哈夫曼树。</p>
<p>哈夫曼树左分支为0，右分支为1，从根结点到每个叶子结点的路径上的0和1所组成的字符串，为该结点所对应的哈夫曼编码。哈夫曼树中没有度为1的结点，n个叶子结点的哈夫曼树共有2n-1个结点。生成的哈夫曼树的根结点下标为2n-1。</p>
<h3 id="存储结构-7">存储结构</h3>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 哈夫曼树</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> HTNode&#123;</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> weight;</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> parent, lChild, rChild;</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>&#125;HTNode;</span></code></pre></div>
<h3 id="生成哈夫曼树">生成哈夫曼树</h3>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Create_HuffmanTree(<span class="dt">unsigned</span> n, HTNode HT[], <span class="dt">const</span> <span class="dt">char</span> c[], <span class="dt">const</span> <span class="dt">unsigned</span> weight[])</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 创建哈夫曼树</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 叶子结点数</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> HT: 用于生成哈夫曼树</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> c: 字符集</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> weight: 叶子结点权重</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> m: 总结点数</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j;</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 所有结点初始化权重</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">2</span> * n - <span class="dv">1</span>; i++) &#123;</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (i &lt; n)</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>            HT[i].weight = weight[i];</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>            HT[i].weight = -<span class="dv">1</span>;</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>        HT[i].parent = HT[i].lChild = HT[i].rChild = -<span class="dv">1</span>;</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = (<span class="dt">int</span>)n; i &lt; <span class="dv">2</span> * n - <span class="dv">1</span>; i++) &#123;</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 保存最小的两个权值</span></span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> w1 = <span class="dv">32767</span>, w2 = <span class="dv">32767</span>;</span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 保存最小的两个权值的下标</span></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> p1 = <span class="dv">0</span>, p2 = <span class="dv">0</span>;</span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 遍历所有未合并的结点找到权值最小的两个</span></span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; i; j++) &#123;</span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 结点j尚未合并</span></span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (HT[j].parent == -<span class="dv">1</span>) &#123;</span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (HT[j].weight &lt; w1) &#123;</span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>                    w2 = w1;</span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>                    p2 = p1;</span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a>                    w1 = HT[j].weight;</span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>                    p1 = j;</span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> <span class="cf">if</span> (HT[j].weight &lt; w2) &#123;</span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>                    w2 = HT[j].weight;</span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>                    p2 = j;</span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 权值最小的两个结点合并为结点i</span></span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a>        HT[i].lChild = p1;</span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a>        HT[i].rChild = p2;</span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a>        HT[i].weight = w1 + w2;</span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a>        HT[p1].parent = i;</span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a>        HT[p2].parent = i;</span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb40-50"><a href="#cb40-50" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="哈夫曼编码">哈夫曼编码</h3>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Huffman_Coding(<span class="dt">unsigned</span> n, HTNode HT[], <span class="dt">const</span> <span class="dt">char</span> c[])</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 输出哈夫曼树的哈夫曼编码</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 叶子结点数</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> HT: 哈夫曼树</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> string_i, p, p_parent;</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 单个字符的编码的最大长度为n-1</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span>* string = (<span class="dt">char</span>*)malloc(n * <span class="kw">sizeof</span>(<span class="dt">char</span>)), * HC[n];</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 编码的结束标志</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    string[n] = <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 遍历所有叶子结点</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; n; i++) &#123;</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>        string_i = n;</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>        p = i;</span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>        p_parent = HT[i].parent;</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (p_parent != -<span class="dv">1</span>) &#123;</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 左孩子为0，右孩子为1</span></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (HT[p_parent].lChild == p)</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>                string[--string_i] = <span class="ch">&#39;0&#39;</span>;</span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>                string[--string_i] = <span class="ch">&#39;1&#39;</span>;</span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 当父节点的父节点不为空，则指向父节点</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>            p = p_parent;</span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>            p_parent = HT[p].parent;</span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>        HC[i] = (<span class="dt">char</span>*) malloc(<span class="kw">sizeof</span>(<span class="dt">char</span>));</span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a>        strcpy(HC[i], &amp;string[string_i]);</span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h1 id="图">6. 图</h1>
<h2 id="基本概念-4">基本概念*</h2>
<p>顶点：点集V，点数|V|</p>
<p>度：依附于顶点V的边的条数，TD(V)</p>
<p>入度、出度：以顶点V为终点、起点的边的条数，ID(V)、OD(V)</p>
<p>弧、边（顶点之间的关系）：边集E，边数|E|，有向图为弧&lt;V1, V2&gt;，无向图为边(V1, V2)</p>
<p>权：边的权重</p>
<p>图：G=(V+E)</p>
<p>有向图：&lt;V1, V2&gt;，V1为弧尾/起点、V2为弧头/终点</p>
<p>无向图：&lt;V1, V2&gt;=&lt;V2, V1&gt;，(V1, V2)</p>
<p>简单图：不存在重复边、不存在顶点到自身的边。</p>
<p>多重图：不符合简单图</p>
<p>完全图：具有n(n-1)/2条边的无向图为完全无向图，具有n(n-1)条边的有向图为完全有向图</p>
<p>稠密图、稀疏图：视边数的多少的模糊定义，|E| &lt;&gt; |V|log|V|</p>
<p>带权图（网）：每条边都带权</p>
<p>连通、路径：V1经过若干条弧/边能够到达V2，则V1, V2连通，即有路径</p>
<p>简单路径：路径中的顶点没有重复</p>
<p>回路（环）：路径的第一个顶点和最后一个顶点相同</p>
<p>简单回路：回路中除了第一个顶点和最后一个顶点没有重复</p>
<p>连通图：无向图中，任意两个顶点V1, V2间都是连通的</p>
<p>连通分量：无向图中，极大的连通子图</p>
<p>强连通图：有向图中，任意两个顶点V1, V2间，有从V1到V2和从V2到V1的路径</p>
<p>强连通分量：有向图中，极大的连通子图</p>
<p>生成树：连通图中，包含图中全部顶点的一个极小连通子图（n个顶点的生成树有n-1条边）</p>
<p>最小生成树：带权连通图中，代价最小的生成树</p>
<p>生成森林：非连通图中，所有的连通分量构成生成森林</p>
<p>有向树：只有一个顶点入度为0，其余顶点入度为1</p>
<h2 id="存储结构-8">存储结构**</h2>
<h3 id="邻接矩阵">邻接矩阵</h3>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 邻接矩阵</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 邻接矩阵数据类型</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> AdjType;</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> AdjSqGraph&#123;</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 邻接矩阵</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    AdjType adj[MAX_VEX][MAX_VEX];</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点信息顺序表</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    VexType vexList[MAX_VEX];</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点数、边数</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> vexNum, arcNum;</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>&#125;ASGraph;</span></code></pre></div>
<h3 id="邻接链表">邻接链表</h3>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 邻接链表</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 表节点</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> ArcLNode&#123;</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 邻接点在顶点结点数组的下标</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> adjVex;</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 权重</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    WeightType weight;</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指向下一个表节点</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ArcLNode *next;</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>&#125;ArcLNode;</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a><span class="co">// 顶点结点</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> VexNode&#123;</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点信息</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>    VexType data;</span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点的度（入度或出度，正邻接出度直观，逆邻接入度直观）</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> degree;</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指向第一条依附于该顶点的弧的指针</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>    ArcLNode *first;</span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>&#125;VexNode, *AdjList;</span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> AdjListGraph&#123;</span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点结点数组</span></span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>    AdjList adjList[MAX_VEX];</span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点数</span></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> vexNum;</span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>&#125;ALGraph;</span></code></pre></div>
<h3 id="边表">边表</h3>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 边表</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> EdgeLNode&#123;</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 边所依附的两个顶点</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    VexType vex1, vex2;</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 边的权重</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    WeightType weight;</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>&#125;EdgeLNode, *EdgeList;</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> EdgeListGraph&#123;</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 边表</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    EdgeList edgeList[MAX_EDGE];</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点信息顺序表</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    VexType vexList[MAX_VEX];</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点数、边数</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> vexNum, arcNum;</span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>&#125;ELGraph;</span></code></pre></div>
<h3 id="十字链表邻接多重表">十字链表、邻接多重表</h3>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 有向图-&gt;十字链表</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * 弧结点：  </span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="co"> *      headvex     头域（弧头顶点在图中的位置）</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="co"> *      tailvex     尾域（弧尾顶点在图中的位置）</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co"> *      hlink       指向弧头相同的下一条弧</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="co"> *      tlink       指向弧尾相同的下一条弧</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * 顶点结点：</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="co"> *      data        数据信息</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="co"> *      firstin     指向以该顶点为弧头的第一个弧结点</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="co"> *      firstout    指向以该顶点为弧尾的第一个弧结点</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 无向图-&gt;邻接多重表</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * 边结点：</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a><span class="co"> *      mark        标志域（标记该边是否被搜索过）</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a><span class="co"> *      ivex        该边依附的顶点i</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a><span class="co"> *      jvex        该边依附的顶点j</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a><span class="co"> *      ilink       指向下一条依附于顶点i的边</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a><span class="co"> *      jlink       指向下一条依附于顶点j的边</span></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a><span class="co"> *      info        边的信息</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * 顶点结点：</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a><span class="co"> *      data        数据信息</span></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a><span class="co"> *      firstedge   指向第一条依附于该顶点的边</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span></code></pre></div>
<h2 id="遍历算法-2">遍历算法***</h2>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 访问标志</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">enum</span>&#123;FALSE, TRUE&#125; BOOLEAN;</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>BOOLEAN Visited[MAX_VEX];</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> Queue&#123;</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> elem[MAX_VEX];</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> front, rear;</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>&#125;Queue;</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Visit(<span class="dt">int</span> index, <span class="dt">int</span> data)&#123;</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    printf(<span class="st">&quot;index: %d, data: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, index, data);</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="深度优先dfs">深度优先DFS</h3>
<p>递归实现</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> DFS(ALGraph *G, <span class="dt">int</span> i)&#123;</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 更新访问标志</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    Visited[i] = TRUE;</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    Visit(i, G-&gt;adjList[i].data);</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指向表结点的第一个结点</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    ArcLNode *p = G-&gt;adjList[i].first;</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (!Visited[p-&gt;adjVex])</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>            DFS(G, p-&gt;adjVex);</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        p = p-&gt;next;</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> DFS_Traverse_Graph(ALGraph *G)</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 图的深度优先遍历递归实现</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v;</span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 访问标志初始化</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (v = <span class="dv">0</span>; v &lt; G-&gt;vexNum; v++)</span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>        Visited[v] = FALSE;</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 遍历顶点结点</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (v = <span class="dv">0</span>; v &lt; G-&gt;vexNum; v++)</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (!Visited[v])</span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>            DFS(G, v);</span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="广度优先bfs">广度优先BFS</h3>
<p>依靠队列实现</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> BFS_Traverse_Graph(ALGraph *G)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 图的广度优先遍历依靠队列实现</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j;</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    ArcLNode *p;</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 建立空队列</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    Queue *Q = (Queue *) malloc(<span class="kw">sizeof</span>(Queue));</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    Q-&gt;front = Q-&gt;rear = <span class="dv">0</span>;</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 访问标志初始化</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>        Visited[i] = FALSE;</span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 遍历顶点结点</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)&#123;</span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (!Visited[i])&#123;</span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 下标入队</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>            Q-&gt;elem[++Q-&gt;rear] = i;</span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 队列是否为空</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (Q-&gt;front != Q-&gt;rear)&#123;</span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 访问下标为队首元素的顶点结点</span></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>                j = Q-&gt;elem[++Q-&gt;front];</span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>                Visited[j] = TRUE;</span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>                Visit(j, G-&gt;adjList[j].data);</span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 顶点结点的所有表结点下标入队</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>                p = G-&gt;adjList[j].first;</span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// 未被访问过的下标才能入队</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> (!Visited[p-&gt;adjVex])</span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>                        Q-&gt;elem[++Q-&gt;rear] = p-&gt;adjVex;</span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a>                    p = p-&gt;next;</span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="最小生成树算法">最小生成树算法**</h2>
<h3 id="prim算法">Prim算法</h3>
<p>从某一个顶点开始构建生成树，每次将代价最小的新定点纳入生成树，直到所有顶点入树。</p>
<p>适用于稠密图，复杂度<span class="math inline">\(O(|V|^2)\)</span></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 比较数组，用于保存未入树顶点到已入树顶点的权值最小的边</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Example:</span><span class="co"> closeEdge[j].vex = k -&gt; cost(j, k) = closeEdge[j].cost</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Initialize:</span><span class="co"> 若从顶点s开始构建最小生成树</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="co"> *      closeEdge[s].cost = 0;</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span>&#123;</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 边依附的已入树顶点</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> vex;</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 最小的边的权值</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> cost;</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>&#125;closeEdge[MAX_EDGE];</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>EdgeList MST_Prim(ASGraph *G, <span class="dt">int</span> u)</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> Prime算法构建最小生成树</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图（邻接矩阵）</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> u: 从下标为u的顶点开始构建</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: EdgeList 边表</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>    EdgeList MT = (EdgeLNode *) malloc((G-&gt;vexNum - <span class="dv">1</span>) * <span class="kw">sizeof</span>(EdgeLNode));</span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k;</span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> min;</span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 初始化比较数组</span></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)&#123;</span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>        closeEdge[i].vex = u;</span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>        closeEdge[i].cost = G-&gt;adjVec[i][u];</span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>    closeEdge[u].cost = <span class="dv">0</span>;</span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 找到生成树的n-1条边</span></span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum - <span class="dv">1</span>; i++)&#123;</span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>        min = INFINITY;</span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)</span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (closeEdge[j].cost != <span class="dv">0</span> &amp;&amp; closeEdge[j].cost &lt; min)&#123;</span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>                min = closeEdge[j].cost;</span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>                k = j;</span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>        MT[i].vex1 = closeEdge[k].vex;</span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a>        MT[i].vex2 = k;</span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a>        MT[i].weight = closeEdge[k].cost;</span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>        closeEdge[k].cost = <span class="dv">0</span>;</span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 更新比较数组</span></span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)&#123;</span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (G-&gt;adjVec[j][k] &lt; closeEdge[j].cost)&#123;</span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a>                closeEdge[j].cost = G-&gt;adjVec[j][k];</span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a>                closeEdge[j].vex = k;</span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb49-50"><a href="#cb49-50" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb49-51"><a href="#cb49-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> MT;</span>
<span id="cb49-52"><a href="#cb49-52" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="kruskal算法">Kruskal算法</h3>
<p>每次选择一条权值最小的边，使边依附的两个顶点连通（若已经连通则跳过），直到所有顶点连通。</p>
<p>适用于稀疏图，复杂度<span class="math inline">\(O(|E|log_2|E|)\)</span></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>EdgeList MST_Kruskal(ELGraph *G)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> Kruskal算法最小生成树</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> G: 图</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: EdgeList 边表</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    EdgeList MT = (EdgeLNode *) malloc((G-&gt;vexNum - <span class="dv">1</span>) * <span class="kw">sizeof</span>(EdgeLNode));</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k, s1, s2, *Vest = (<span class="dt">int</span> *) malloc(G-&gt;vexNum * <span class="kw">sizeof</span>(<span class="dt">int</span>));</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 初始化连通数组</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* 若Vest[i] = Vest[j]，表明Vi和Vj在同一个连通分量中</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a><span class="co">     * 若Vest[i] ≠ Vest[j]，表明Vi和Vj之间没有回路</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>        Vest[i] = i;</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 边表按权重升序排序</span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    Sort_EdgeList(G-&gt;edgeList, G-&gt;arcNum);</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = j = <span class="dv">0</span>; i &lt; G-&gt;vexNum &amp;&amp; j &lt; G-&gt;vexNum - <span class="dv">1</span>;)&#123;</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 权值最小的边依附的两个顶点</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>        s1 = Vest[G-&gt;edgeList[i].vex1];</span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>        s2 = Vest[G-&gt;edgeList[i].vex2];</span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (s1 != s2)&#123;</span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a>            MT[j].vex1 = G-&gt;edgeList[i].vex1;</span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>            MT[j].vex2 = G-&gt;edgeList[i].vex2;</span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a>            MT[j].weight = G-&gt;edgeList[i].weight;</span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>            j++;</span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (k = <span class="dv">0</span>; k &lt; G-&gt;vexNum; k++)&#123;</span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 连通的顶点对应的于Vest中的值相等</span></span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (Vest[k] == s2)</span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>                    Vest[k] = s1;</span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a>        i++;</span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true" tabindex="-1"></a>    free(Vest);</span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> MT;</span>
<span id="cb50-38"><a href="#cb50-38" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="最短路径算法">最短路径算法*</h2>
<h3 id="dijkstra算法">Dijkstra算法</h3>
<p>求图的单源的最短路径</p>
<p>不能解决带负权值的图</p>
<p>复杂度<span class="math inline">\(O(|V|^2)\)</span></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 是否找到最短路径的标志</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>BOOLEAN final[MAX_VEX];</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 最短路径长度（为0表示到自身、为数值表示路径长度、为无穷表示无法到达）</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> dist[MAX_VEX];</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="co">// 路径上的前驱结点</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> pre[MAX_VEX];</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Path_Dijkstra(ASGraph *G, <span class="dt">int</span> u)</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> Dijkstra算法查找单源最短路径</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图（邻接链表）</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> u: 单源，即顶点u到其余所有顶点的最短路径</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null </span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k;</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> min;</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 初始化3个数组</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)&#123;</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>        pre[i] = u;</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>        final[i] = FALSE;</span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>        dist[i] = G-&gt;adjVec[u][i];</span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>    dist[u] = <span class="dv">0</span>;</span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>    final[u] = TRUE;</span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 遍历除了顶点u以外的顶点，找到没确定最短路径且dist最小的第k个顶点</span></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 说明顶点k到上一个的顶点的最短路径已经找到为dist</span></span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum - <span class="dv">1</span>; i++)&#123;</span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a>        k = <span class="dv">0</span>;</span>
<span id="cb51-30"><a href="#cb51-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (final[k])</span>
<span id="cb51-31"><a href="#cb51-31" aria-hidden="true" tabindex="-1"></a>            k++;</span>
<span id="cb51-32"><a href="#cb51-32" aria-hidden="true" tabindex="-1"></a>        min = INFINITY;</span>
<span id="cb51-33"><a href="#cb51-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)</span>
<span id="cb51-34"><a href="#cb51-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (!final[j] &amp;&amp; dist[k] &lt; min)&#123;</span>
<span id="cb51-35"><a href="#cb51-35" aria-hidden="true" tabindex="-1"></a>                min = dist[j];</span>
<span id="cb51-36"><a href="#cb51-36" aria-hidden="true" tabindex="-1"></a>                k = j;</span>
<span id="cb51-37"><a href="#cb51-37" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb51-38"><a href="#cb51-38" aria-hidden="true" tabindex="-1"></a>        final[k] = TRUE;</span>
<span id="cb51-39"><a href="#cb51-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 通过顶点k，上一个的顶点到与顶点k相邻的顶点是否存在更短路径</span></span>
<span id="cb51-40"><a href="#cb51-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> l = <span class="dv">0</span>; l &lt; G-&gt;vexNum; l++)</span>
<span id="cb51-41"><a href="#cb51-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (!final[l] &amp;&amp; dist[k] + G-&gt;adjVec[k][l] &lt; dist[l])&#123;</span>
<span id="cb51-42"><a href="#cb51-42" aria-hidden="true" tabindex="-1"></a>                dist[l] = dist[k] + G-&gt;adjVec[k][l];</span>
<span id="cb51-43"><a href="#cb51-43" aria-hidden="true" tabindex="-1"></a>                pre[l] = k;</span>
<span id="cb51-44"><a href="#cb51-44" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb51-45"><a href="#cb51-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 输出</span></span>
<span id="cb51-46"><a href="#cb51-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> l = <span class="dv">0</span>; l &lt; G-&gt;vexNum; l++)</span>
<span id="cb51-47"><a href="#cb51-47" aria-hidden="true" tabindex="-1"></a>            printf(<span class="st">&quot;%d</span><span class="sc">\t</span><span class="st">&quot;</span>, (<span class="dt">int</span>)final[l]);</span>
<span id="cb51-48"><a href="#cb51-48" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb51-49"><a href="#cb51-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> l = <span class="dv">0</span>; l &lt; G-&gt;vexNum; l++)</span>
<span id="cb51-50"><a href="#cb51-50" aria-hidden="true" tabindex="-1"></a>            printf(<span class="st">&quot;%d</span><span class="sc">\t</span><span class="st">&quot;</span>, (<span class="dt">int</span>)dist[l]);</span>
<span id="cb51-51"><a href="#cb51-51" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb51-52"><a href="#cb51-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> l = <span class="dv">0</span>; l &lt; G-&gt;vexNum; l++)</span>
<span id="cb51-53"><a href="#cb51-53" aria-hidden="true" tabindex="-1"></a>            printf(<span class="st">&quot;%d</span><span class="sc">\t</span><span class="st">&quot;</span>, pre[l]);</span>
<span id="cb51-54"><a href="#cb51-54" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot;</span><span class="sc">\n\n</span><span class="st">&quot;</span>);</span>
<span id="cb51-55"><a href="#cb51-55" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb51-56"><a href="#cb51-56" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="floyd算法">Floyd算法</h3>
<p>求图的各顶点间的最短路径</p>
<p>不能解决带负权值回路的图</p>
<p>复杂度<span class="math inline">\(O(|V|^3)\)</span>​</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 任意两顶点间的最短距离（为0表示到自身、为数值表示路径长度、为无穷表示无法到达）</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> A[MAX_VEX][MAX_VEX];</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 最短路径上的中继顶点</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Path[MAX_VEX][MAX_VEX];</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Print_Path(<span class="dt">int</span> i, <span class="dt">int</span> j)</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 递归输出Floyd算法两顶点间的最短路径</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 顶点i</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> j: 顶点j</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null </span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (Path[i][j] != -<span class="dv">1</span>)&#123;</span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>        Print_Path(i, Path[i][j]);</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot; -&gt; %d&quot;</span>, Path[i][j]);</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>        Print_Path(Path[i][j], j);</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Path_Floyd(ASGraph *G)</span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> Floyd算法查找顶点间的最短路径</span></span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图（邻接矩阵）</span></span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k;</span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 初始化2个数组</span></span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j =<span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)&#123;</span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a>            A[i][j] = G-&gt;adjVec[i][j];</span>
<span id="cb52-33"><a href="#cb52-33" aria-hidden="true" tabindex="-1"></a>            Path[i][j] = -<span class="dv">1</span>;</span>
<span id="cb52-34"><a href="#cb52-34" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb52-35"><a href="#cb52-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 第k个顶点作为中继顶点，遍历距离矩阵</span></span>
<span id="cb52-36"><a href="#cb52-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 若加入中继顶点最短距离更短则替换</span></span>
<span id="cb52-37"><a href="#cb52-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (k = <span class="dv">0</span>; k &lt; G-&gt;vexNum; k++)</span>
<span id="cb52-38"><a href="#cb52-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb52-39"><a href="#cb52-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (j =<span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)</span>
<span id="cb52-40"><a href="#cb52-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (A[i][k] + A[k][j] &lt; A[i][j])&#123;</span>
<span id="cb52-41"><a href="#cb52-41" aria-hidden="true" tabindex="-1"></a>                    A[i][j] = A[i][k] + A[k][j];</span>
<span id="cb52-42"><a href="#cb52-42" aria-hidden="true" tabindex="-1"></a>                    Path[i][j] = k;</span>
<span id="cb52-43"><a href="#cb52-43" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb52-44"><a href="#cb52-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 输出路径</span></span>
<span id="cb52-45"><a href="#cb52-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb52-46"><a href="#cb52-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)</span>
<span id="cb52-47"><a href="#cb52-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (i != j)&#123;</span>
<span id="cb52-48"><a href="#cb52-48" aria-hidden="true" tabindex="-1"></a>                printf(<span class="st">&quot;%d&quot;</span>, i);</span>
<span id="cb52-49"><a href="#cb52-49" aria-hidden="true" tabindex="-1"></a>                Print_Path(i, j);</span>
<span id="cb52-50"><a href="#cb52-50" aria-hidden="true" tabindex="-1"></a>                printf(<span class="st">&quot; -&gt; %d</span><span class="sc">\n</span><span class="st">&quot;</span>, j);</span>
<span id="cb52-51"><a href="#cb52-51" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb52-52"><a href="#cb52-52" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="拓扑排序算法">拓扑排序算法*</h2>
<p>由某个集合上的一个偏序得到该集合上的一个全序的操作。</p>
<p>AOV网：顶点表示活动的有向无环图（Activity On Vertex），图中顶点表示活动，有向边表示活动之间的优先关系。对于有向边&lt;i, j&gt;或i到j的有向路径，i是j的前驱，j是i的后继。AOV网中不能有环。</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>BOOLEAN Topological_Sort(ALGraph *G, <span class="dt">int</span> topology[])</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 拓扑排序</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图（邻接链表）</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> topology: 拓扑排序</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: BOOLEAN </span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="co"> *  TRUE：有拓扑排序</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a><span class="co"> *  FALSE：图中有环</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, k, adj_k, top = <span class="dv">0</span>, count = <span class="dv">0</span>;</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>    BOOLEAN <span class="dt">bool</span> = TRUE;</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> stack[MAX_VEX];</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>    ArcLNode *p;</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 入度为0的顶点入栈</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (G-&gt;adjList[i].inDegree == <span class="dv">0</span>)</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>            stack[++top] = G-&gt;adjList[i].data;</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (top != <span class="dv">0</span>) &#123;</span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 栈顶出栈</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>        k = stack[top--];</span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>        topology[count++] = k;</span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>        p = G-&gt;adjList[k].first;</span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 所有顶点k的后继顶点入度减1（删除顶点k为弧尾的所有弧）</span></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>            adj_k = p-&gt;adjVex;</span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>            G-&gt;adjList[adj_k].inDegree--;</span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 入度为0的顶点入栈</span></span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (G-&gt;adjList[adj_k].inDegree == <span class="dv">0</span>)</span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>                stack[++top] = adj_k;</span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;next;</span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 还原图顶点的入度</span></span>
<span id="cb53-36"><a href="#cb53-36" aria-hidden="true" tabindex="-1"></a>    Count_ALGraph_InDegree(G);</span>
<span id="cb53-37"><a href="#cb53-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 拓扑序列长度小于顶点数，说明图中有环</span></span>
<span id="cb53-38"><a href="#cb53-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (count &lt; G-&gt;vexNum)</span>
<span id="cb53-39"><a href="#cb53-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FALSE;</span>
<span id="cb53-40"><a href="#cb53-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb53-41"><a href="#cb53-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> TRUE;</span></code></pre></div>
<h2 id="关键路径">关键路径*</h2>
<p>AOE网：边表示活动的有向无环图（Activity On Edge），图中顶点表示事件，每个事件表示在其前的所有活动已经完成，其后的活动可以开始；弧表示活动，弧上的权值表示相应活动所需的开销。</p>
<p>事件的最早发生时间ve：拓扑序列中每个顶点的所有（前驱顶点的最早发生时间+活动开销）的最大值</p>
<p>事件的最迟发生时间vl：逆拓扑序列中每个顶点的所有（后继顶点的最迟发生时间-活动开销）的最小值</p>
<p>关键事件：ve=vl</p>
<p>活动的最早发生时间e：等于弧尾最早发生时间</p>
<p>活动的最迟发生时间I：等于弧头最晚发生时间-活动开销</p>
<p>活动的时间余量d：l-e</p>
<p>关键活动：活动的时间余量d=0</p>
<figure>
<img src="../images/关键路径.jpg" alt="关键路径" /><figcaption aria-hidden="true">关键路径</figcaption>
</figure>
<h1 id="查找-2">7. 查找</h1>
<h2 id="基本概念-5">基本概念*</h2>
<p>查找：在数据集合中寻找满足某种条件的数据元素的过程</p>
<p>查找表（查找结构）：用于查找的数据集合，由同一类型的数据元素组成</p>
<p>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找的结果是唯一的</p>
<p>静态查找：在查找时只对查找表的数据元素进行查找，仅关注查找速度</p>
<p>动态查找：在实施查找的同时也要进行插入和删除，除了查找速度，也要关注插入和删除是否方便实现</p>
<p>查找方法的评价指标</p>
<p>查找长度：在查找运算中，需要对比关键字的次数</p>
<p>平均查找长度(ASL, Average Search Length)：所有查找过程中进行关键字的比较次数的平均值，<span class="math inline">\(ASL=\sum_{i=1}^{n}p_i*c_i\)</span>，其中n为元素个数，<span class="math inline">\(p_i\)</span>为查找第i个元素的概率（通常认为查找任何一个元素的概率都相同为1/n），<span class="math inline">\(c_i\)</span>为第i个元素的查找长度</p>
<h2 id="静态查找">静态查找**</h2>
<h3 id="顺序查找">顺序查找</h3>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序查找表</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * 第0个元素为哨兵元素，数据从第1个元素开始储存</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> SqTable&#123;</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    ElemType elem[MAX_SIZE];</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length;</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>&#125;SqTable;</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>Status SeqSearch(SqTable ST, ElemType key)</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序查找</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ST: 查找表</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> p;</span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 设置哨兵为要查找的元素</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>    ST.elem[<span class="dv">0</span>]=key;</span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 从最后一个元素开始，若要查找的元素与当前元素相同时，跳出循环。若为哨兵元素，此时p为0</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 优点是判断跳出循环的条件不需要检查是否越界</span></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (p = ST.length; !EQ(ST.elem[p], key); p--);</span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p;</span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="折半查找">折半查找</h3>
<p>也称二分查找</p>
<p>查找表是有序的</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>Status BinSearch(SqList ST, ElemType key)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 折半查找</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ST: 查找表（有序）</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> low = <span class="dv">1</span>, high = ST.length, mid;</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (low &lt; high)&#123;</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>        mid = (low + high) / <span class="dv">2</span>;</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(ST.elem[mid], key))</span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mid;</span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> (LT(ST.elem[mid], key))</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>            low = mid + <span class="dv">1</span>;</span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>            high = mid - <span class="dv">1</span>;</span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>折半查找判定树：查找过程可用二叉树表示</p>
<figure>
<img src="../images/折半查找判定树.png" alt="折半查找判定树" /><figcaption aria-hidden="true">折半查找判定树</figcaption>
</figure>
<p>查找成功时，为每个结点的比较次数之和除以有序表长度</p>
<p>ASL=(1×1+2×2+3×4+4×3)/10=29/10</p>
<p>查找失败时，为每个外结点的比较次数之和除以外结点个数，外结点为每个结点的空指针指向的不存在的结点</p>
<p>ASL=(3×5+4×6)/11=39/11</p>
<h3 id="分块查找">分块查找</h3>
<p>也称索引顺序查找，分块有序，分块内无序（第i+1块关键字均大于第i块），分块对应索引表，分块内对应查找表</p>
<p>为顺序查找和折半查找的综合，对索引表折半查找，对查找表顺序查找</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 索引表</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> BlockIndex&#123;</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 块最大关键字</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    ElemType maxKey;</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 块起始位置和终止位置</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> low, high;</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>&#125;BlockIndex;</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>Status BlockSearch(ElemType ST[], BlockIndex index[], ElemType key, <span class="dt">int</span> n, <span class="dt">int</span> blocks)</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 分块查找（顺序查找索引表）</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ST: 查找表</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> index: 索引表</span></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 查找表长度</span></span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> blocks: 分块数</span></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i = <span class="dv">0</span>, j;</span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顺序查找索引表</span></span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> ((i &lt; blocks) &amp;&amp; LT(index[i].maxKey, key))</span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a>        i++;</span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i &gt; blocks)</span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顺序查找块内</span></span>
<span id="cb56-29"><a href="#cb56-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = index[i].low; j &lt; index[i].high; j++)</span>
<span id="cb56-30"><a href="#cb56-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(ST[j], key))</span>
<span id="cb56-31"><a href="#cb56-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span>;</span>
<span id="cb56-32"><a href="#cb56-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j &gt; n || !EQ(ST[j], key))</span>
<span id="cb56-33"><a href="#cb56-33" aria-hidden="true" tabindex="-1"></a>        j = <span class="dv">0</span>;</span>
<span id="cb56-34"><a href="#cb56-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> j;</span>
<span id="cb56-35"><a href="#cb56-35" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="动态查找">动态查找*</h2>
<h3 id="二叉排序树bst">二叉排序树BST</h3>
<p>概念见二叉树</p>
<h4 id="查找插入创建">查找、插入、创建</h4>
<p>非递归写法：套一个while循环，树的指针以一定的判断依据不断指向左右孩子，直到指向的结点为空跳出循环</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>BTLNode *Search_BST(BTLNode *T, ElemType key)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉排序树的查找</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ST: 二叉排序树</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: BTLNode</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(T-&gt;data, key))</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> T;</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> (LT(T-&gt;data, key))</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Search_BST(T-&gt;lChild, key);</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Search_BST(T-&gt;rChild, key);</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> NULL;</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a>Status Insert_BST(BTLNode *T, ElemType key)</span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉排序树的插入</span></span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ST: 二叉排序树</span></span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 插入关键字</span></span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a>    BTLNode *p = (BTLNode *)malloc (<span class="kw">sizeof</span>(BTLNode));</span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a>    p-&gt;data = key;</span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true" tabindex="-1"></a>    p-&gt;lChild = p-&gt;rChild = NULL;</span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 若为空树，则插入根节点</span></span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T == NULL)</span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true" tabindex="-1"></a>        T = p;</span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 不为空树</span></span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb57-36"><a href="#cb57-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 结点已存在</span></span>
<span id="cb57-37"><a href="#cb57-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(T-&gt;data, key))</span>
<span id="cb57-38"><a href="#cb57-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> OK;</span>
<span id="cb57-39"><a href="#cb57-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 插入左子树</span></span>
<span id="cb57-40"><a href="#cb57-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> (LT(p-&gt;data, key))</span>
<span id="cb57-41"><a href="#cb57-41" aria-hidden="true" tabindex="-1"></a>            Insert_BST(T-&gt;lChild, key);</span>
<span id="cb57-42"><a href="#cb57-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 插入右子树</span></span>
<span id="cb57-43"><a href="#cb57-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> </span>
<span id="cb57-44"><a href="#cb57-44" aria-hidden="true" tabindex="-1"></a>            Insert_BST(T-&gt;rChild, key);</span>
<span id="cb57-45"><a href="#cb57-45" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb57-46"><a href="#cb57-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb57-47"><a href="#cb57-47" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb57-48"><a href="#cb57-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-49"><a href="#cb57-49" aria-hidden="true" tabindex="-1"></a>BTLNode *Create_BST(ElemType el[], <span class="dt">int</span> n)</span>
<span id="cb57-50"><a href="#cb57-50" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb57-51"><a href="#cb57-51" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉排序树的创建</span></span>
<span id="cb57-52"><a href="#cb57-52" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> el: 数组</span></span>
<span id="cb57-53"><a href="#cb57-53" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 数组长度</span></span>
<span id="cb57-54"><a href="#cb57-54" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: BTLNode</span></span>
<span id="cb57-55"><a href="#cb57-55" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb57-56"><a href="#cb57-56" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb57-57"><a href="#cb57-57" aria-hidden="true" tabindex="-1"></a>    BTLNode *T = NULL;</span>
<span id="cb57-58"><a href="#cb57-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n ; i++)&#123;</span>
<span id="cb57-59"><a href="#cb57-59" aria-hidden="true" tabindex="-1"></a>        Insert_BST(T, el[i]);</span>
<span id="cb57-60"><a href="#cb57-60" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb57-61"><a href="#cb57-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> T;</span>
<span id="cb57-62"><a href="#cb57-62" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h4 id="删除-3">删除</h4>
<p>①若被删除结点p是叶结点，则直接删除，不会破坏二叉排序树的性质。</p>
<p>②若结点p只有一棵左子树或右子树，则让p的子树成为p父结点的子树，替代p的位置。</p>
<p>③若结点p有左、右两棵子树，则令p的直接后继或直接前驱替代p，然后从二叉排序树中删去这个直接后继或直接前驱，删去的过程同①②。</p>
<figure>
<img src="../images/BST的删除.png" alt="BST的删除" /><figcaption aria-hidden="true">BST的删除</figcaption>
</figure>
<h3 id="平衡二叉树avl">平衡二叉树AVL</h3>
<p>概念见二叉树</p>
<p>平衡因子：二叉树结点的左子树的深度减去右子树的深度，AVL的平衡因子只可能是-1/0/1</p>
<h4 id="插入-3">插入</h4>
<p>平衡化旋转：将不平衡二叉排序树转变为平衡二叉排序树</p>
<p>LL型：在A的左孩子的左子树中插入导致不平衡，调整: A的左孩子结点右旋</p>
<p>RR型：在A的右孩子的右子树中插入导致不平衡，调整: A的右孩子结点左旋</p>
<p>LR型：在A的左孩子的右子树中插入导致不平衡，调整: A的左孩子的右孩子先左旋再右旋</p>
<p>RL型：在A的右孩子的左子树中插入导致不平衡，调整: A的右孩子的左孩子先右旋后左旋</p>
<p>左孩子只能右旋，右孩子只能左旋</p>
<p>寻找不平衡结点：从插入结点向上回溯，找到第一个不平衡的结点，以该结点为根结点的子树即为最小不平衡子树</p>
<h4 id="删除-4">删除</h4>
<p>与插入类似，不同之处在于，若删除的结点使得最小不平衡子树在平衡后高度-1，则需要对祖先结点进行进一步调整，直至回溯到根结点。</p>
<h4 id="查找-3">查找</h4>
<p>在AVL上查找的复杂度O(<span class="math inline">\(log_2 n\)</span>)</p>
<h3 id="红黑树"><em>红黑树</em></h3>
<p>红黑树是满足红黑性质的二叉排序树：</p>
<ul>
<li>每个结点为红结点或黑结点</li>
<li>根结点为黑结点</li>
<li>叶节点、虚构外部结点、空节点为黑结点</li>
<li>不存在两个相邻的红结点（红结点的父子均为黑结点）</li>
<li>对于每个结点，从该结点到任一叶结点的简单路径上，所含黑结点数量相同</li>
</ul>
<h3 id="b树">B树</h3>
<p>又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶</p>
<figure>
<img src="../images/b树.png" alt="b树" /><figcaption aria-hidden="true">b树</figcaption>
</figure>
<p>一棵m阶B树满足如下条件:</p>
<ul>
<li><p>根结点的子树数∈[2, m]（若根结点为终端节点子树可为1），关键字数∈[1, m-1]</p>
<p>除根结点外的所有非叶子结点子树数∈[<span class="math inline">\(\lceil m/2\rceil\)</span>, m]，关键字数∈[<span class="math inline">\(\lceil m/2\rceil-1\)</span>, m-1]</p></li>
<li><p>关键字的值服从：子树0&lt;关键字1&lt;子树1&lt;关键字2&lt;子树2&lt;....</p></li>
<li><p>对任一结点，其所有子树高度相同；所有的叶子结点都出现在同一层次上，并且不带信息（为虚构外部结点，指向这些结点的指针为空，类似于折半查找判定树的查找失败结点)。</p></li>
</ul>
<p>含n个关键字的m阶B树，高度h的范围：</p>
<ul>
<li>最小高度——让各层的分叉尽可能多，每个结点都有m个分叉，则每个结点有m-1个关键字，通过关键字数构建不等式：<span class="math inline">\(n≤(m-1)(1+m+m^2+...+m^{h-1})=m^h-1\)</span>，即<span class="math inline">\(h≥log_m(n+1)\)</span></li>
<li>最大高度——让各层的分叉尽可能少，根结点只有两个分叉，其他结点只有<span class="math inline">\(\lceil m/2\rceil\)</span>个分叉；而n个关键字的B树必有n+1个叶子结点（每一个结点将-∞~+∞分隔，共分为n+1个区间），通过结点数构建不等式：<span class="math inline">\(n+1≥2\lceil m/2\rceil^{h-1}\)</span>，即<span class="math inline">\(h≤log_{\lceil m/2\rceil}\frac{n+1}{2}+1\)</span></li>
</ul>
<h4 id="插入-4">插入</h4>
<p>向最底层的某个终端结点插入，若插入后该结点关键字数≤m-1，则插入成功</p>
<p>若插入后该结点关键字数=m，则从<span class="math inline">\(\lceil m/2\rceil\)</span>处将其中的关键字分为两部分，左部分（$k_1到k_{m/2} <span class="math inline">\(）置于原结点，右部分（\)</span>k_{m/2+1}到k_m <span class="math inline">\(）置于新结点，中间位置(\)</span>k_{m/2}$) 的关键字插入原结点的父结点</p>
<p>若父节点溢出则向上进一步调整，直至根结点，而根节点溢出时，则在分裂后将中间位置的结点置为新的根结点，树的高度+1</p>
<h4 id="删除-5">删除</h4>
<p>删除后结点的关键字数≥<span class="math inline">\(\lceil m/2\rceil-1\)</span>时</p>
<ul>
<li>若被删除关键字在终端结点，则直接删除该关键字</li>
<li>若被删除关键字在非终端结点，则用直接前驱或直接后继来替代被删除的关键字，转化为对终端结点关键字的删除操作
<ul>
<li>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素</li>
<li>直接后继：当前关键字右侧指针所指子树中“最左下”的元素</li>
</ul></li>
</ul>
<p>删除后结点的关键字数＜<span class="math inline">\(\lceil m/2\rceil-1\)</span>时</p>
<p>右兄弟（或左兄弟）宽裕（关键字数＞<span class="math inline">\(\lceil m/2\rceil-1\)</span>）时，使用被删除关键字的后继、后继的后继（前驱、前驱的前驱）填补空缺</p>
<p>左兄弟和右兄弟都不宽裕（关键字数=<span class="math inline">\(\lceil m/2\rceil-1\)</span>）时，与左兄弟（或右兄弟）和父节点中的关键字进行合并，若合并后父结点关键字不足，则继续向上调整，直至根结点</p>
<h3 id="b树-1">B+树</h3>
<figure>
<img src="../images/b+树.png" alt="b+树" /><figcaption aria-hidden="true">b+树</figcaption>
</figure>
<p>一棵m阶的B+树需满足下列条件:</p>
<ul>
<li>每个分支结点最多有m棵子树(孩子结点)</li>
<li>非叶根结点至少有两棵子树，其他每个分支结点至少有<span class="math inline">\(\lceil m/2\rceil\)</span>棵子树</li>
<li>结点的子树个数与关键字个数相等（B树和B+树的区别）</li>
<li>所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来（支持顺序查找）</li>
<li>所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针</li>
</ul>
<h4 id="插入-5">插入</h4>
<p>若插入结点关键字数＜m，则直接插入</p>
<p>若插入结点关键字数=m，则从<span class="math inline">\(\lceil m/2\rceil\)</span>处将其中的关键字分为两部分，左部分（$k_1到k_{m/2} <span class="math inline">\(）置于原结点，右部分（\)</span>k_{m/2+1}到k_m <span class="math inline">\(）置于新结点，同时中间位置(\)</span>k_{m/2}$) 的关键字插入原结点的父结点</p>
<p>若父节点溢出则向上进一步调整，直至根结点，而根节点溢出时，则在分裂后将中间位置的结点置为新的根结点，树的高度+1</p>
<h2 id="散列哈希查找">散列（哈希）查找*</h2>
<p>散列表，又称哈希表，数据元素的关键字与其存储地址直接相关</p>
<p>散列函数的构造方法：</p>
<ul>
<li>直接定址法：H(key) = key 或 H(key) = a × key + b，适合关键字分布基本连续的情况</li>
<li>保留余数法：H(key) = key % p，其中p为不大于表长m的最大素数（用质数取模，分布相对均匀，冲突少，牺牲了m-p的存储空间）</li>
<li>数字分析法：取关键字的数码较为均匀的若干位作为散列地址，如手机号的尾号</li>
<li>平方取中法：取关键字的平方的中间若干位作为散列地址，其与关键字的每一位都有联系，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数</li>
</ul>
<p>处理冲突的方法：</p>
<ul>
<li>开放定址法：空闲地址既向同义词表项开放，又向非同义词表项开放，地址为<span class="math inline">\(H_i=(H(key)+d_i)\%m\)</span>，其中m为表长，<span class="math inline">\(d_i\)</span>为递增序列，i为第i次发生冲突
<ul>
<li>线性探测法：<span class="math inline">\(d_i=0,1,2,...,k(k≤m-1)\)</span>，容易造成“堆积”现象，由于在查找时，遇到空闲地址说明无同义词，即可停止查找，然而堆积现象填满了空闲地址导致查找不能快速地停止，效率大大降低。同时，在删除结点时，不能简单地将被删除节点的空间置为空，否则将阶段在其之后填入散列表的同义词的查找路径，可以使用删除标记进行逻辑删除</li>
<li>平方探测法：<span class="math inline">\(d_i=0^2,1^2,-1^2,...,k^2,-k^2(k≤m/2)\)</span>，同时列表长度m必须可以表示成4k+3才能够探测到所有位置</li>
<li>伪随机序列法：<span class="math inline">\(d_i\)</span>为伪随机数序列</li>
<li>再散列法：<span class="math inline">\(d_i=RH_i(key)\)</span>，准备多个散列函数，冲突了就换下一个</li>
</ul></li>
<li>拉链法（链地址法）：把所有同义词表项储存在一个链表中</li>
</ul>
<h3 id="散列查找算法">散列查找算法</h3>
<h4 id="开放定址法的线性探测法">开放定址法的线性探测法</h4>
<figure>
<img src="../images/哈希_线性探测法.png" alt="哈希_线性探测法" /><figcaption aria-hidden="true">哈希_线性探测法</figcaption>
</figure>
<p>查找成功ASL=(1+1+1+2+4+1+1+3+3+1+3+9)/12=2.5</p>
<p>查找失败ASL=(1+13+12+11+10+9+8+7+6+5+4+3+2)/13=7（<span class="math inline">\(H_0\)</span>的范围为[0, 12]）</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> RecType&#123;</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    KeyType key;</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    OtherType other;</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>&#125;RecType;</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> H(<span class="dt">int</span> key);</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Hash_Search(RecType HT[], KeyType key, <span class="dt">int</span> m)</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 使用开放地址法的线性探测法解决冲突，并进行散列查找</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> HT: 散列表</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> m: 散列表长度</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: int</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> h, i;</span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>    h = H(key);</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (i &lt; m &amp;&amp; !EQ(HT[h].key, NULLKEY))&#123;</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(HT[h].key, key))</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> h;</span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Hash_Search(HT, key, ++i);</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h4 id="拉链法">拉链法</h4>
<figure>
<img src="../images/哈希_拉链法.png" alt="哈希_拉链法" /><figcaption aria-hidden="true">哈希_拉链法</figcaption>
</figure>
<p>查找成功ASL=(1×6+2×4+3×1+4×1)/12=1.75</p>
<p>查找失败ASL=(4+2+2+1+2+1)/13=0.92</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> HashLNode&#123;</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    KeyType key;</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> HashLNode *next;</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>&#125;HashLNode;</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>HashLNode *Hash_Search_Link(HashLNode *HT[], KeyType key)</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 使用拉链法解决冲突，并进行散列查找</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> HT: 散列表</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: HashLnode</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>    HashLNode *p;</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>    i = H(key);</span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (HT[i] == NULL)</span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> NULL;</span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>    p = HT[i];</span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(p-&gt;key, key))</span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> p;</span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;next;</span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> NULL;</span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h1 id="排序">8. 排序</h1>
<p>算法的稳定性：排序后关键值相等的记录的相对位置不变称为稳定的，否则不稳定</p>
<p>内部排序：数据都在内存中</p>
<table>
<thead>
<tr class="header">
<th>排序方法</th>
<th>平均时间</th>
<th>最坏时间</th>
<th>最好时间</th>
<th>空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>直接插入</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>逆序<span class="math inline">\(O(n^2)\)</span></td>
<td>有序<span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>稳定</td>
</tr>
<tr class="even">
<td>希尔</td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td>优于<span class="math inline">\(O(n^2)\)</span></td>
<td>有序<span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>不稳定</td>
</tr>
<tr class="odd">
<td>冒泡</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>逆序<span class="math inline">\(O(n^2)\)</span></td>
<td>有序<span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>稳定</td>
</tr>
<tr class="even">
<td>快速</td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td>有序<span class="math inline">\(O(n^2)\)</span></td>
<td>平均划分 <span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td>不稳定</td>
</tr>
<tr class="odd">
<td>直接选择</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>不稳定</td>
</tr>
<tr class="even">
<td>堆</td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>不稳定</td>
</tr>
<tr class="odd">
<td>归并</td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>稳定</td>
</tr>
<tr class="even">
<td>基数</td>
<td><span class="math inline">\(O(d(n+r))\)</span></td>
<td><span class="math inline">\(O(d(n+r))\)</span></td>
<td><span class="math inline">\(O(d(n+r))\)</span></td>
<td><span class="math inline">\(O(d(n+r))\)</span></td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h2 id="插入排序">插入排序</h2>
<h3 id="直接插入排序">直接插入排序</h3>
<p>每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Insert_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 直接插入排序</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j;</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt; n; i++)&#123;</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>        temp = R[i];</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 无序区第一个元素插入有序区</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = i - <span class="dv">1</span>; j &gt;= <span class="dv">0</span> &amp;&amp; temp.key &lt; R[j].key; j--)</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>            R[j + <span class="dv">1</span>] = R[j];</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>        R[j + <span class="dv">1</span>] = temp;</span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="希尔排序">希尔排序</h3>
<p>分组插入排序：先将待排序表分割成若干形如L[i, i + d, i + 2d, ..., i + kd]的子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Shell_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 希尔排序</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j;</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> d = n / <span class="dv">2</span>; d &gt; <span class="dv">0</span>; d /= <span class="dv">2</span>)&#123;</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i = d; i &lt; n; i++)&#123;</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (j = i - d; j &gt;= <span class="dv">0</span> &amp;&amp; R[j].key &gt; R[j + d].key; j -= d)&#123;</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>                temp = R[j];</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>                R[j] = R[j + d];</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>                R[j + d] = temp;</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="交换排序">交换排序</h2>
<h3 id="冒泡排序">冒泡排序</h3>
<p>从后往前（或从前往后）两两比较相邻元素的值，若为逆序则交换它们，直到序列比较完。称这样过程为一趟冒泡排序，最多只需n-1趟排序，每趟排序可使一个元素的移动到最终位置，已经确定最终位置的元素在之后的处理中无需再对比。若某一趟排序过程中未发生交换，则算法可提前结束</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Bubble_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 冒泡排序</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j;</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; n - <span class="dv">1</span>; i++)&#123;</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = n - <span class="dv">1</span>; j &gt; i; j--)&#123;</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (R[j].key &lt; R[j - <span class="dv">1</span>].key)&#123;</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>                temp = R[j];</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>                R[j] = R[j - <span class="dv">1</span>];</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>                R[j - <span class="dv">1</span>] = temp;</span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="快速排序">快速排序</h3>
<p>在待排序表中任取一个元素作为枢轴元素pivot（通常取首元素），通过一趟排序将待排序表划分为独立的两部分使得左边所有元素小于pivot，右边所有元素大于等于pivot，则pivot最终落在空出来的位置上，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至两部分内只有一个元素或空为止</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Quick_Sort(RecType R[], <span class="dt">int</span> low, <span class="dt">int</span> high)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 快速排序</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> low: 表头下标</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> high: 表尾下标</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i = low, j = high;</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 递归结束条件，区间内至少存在一个元素</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (low &lt; high)&#123;</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>        temp = R[low];</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (i != j)&#123;</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 跳过右边大于枢轴的，直到找到一个小于的</span></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (i &lt; j &amp;&amp; R[j].key &gt; temp.key) j--;</span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (i &lt; j)&#123;</span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>                R[i] = R[j];</span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>                i++;</span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 跳过左边小于枢轴的，直到找到一个大于的</span></span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (i &lt; j &amp;&amp; R[i].key &lt; temp.key) i++;</span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (i &lt; j)&#123;</span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>                R[j] = R[i];</span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a>                j--;</span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a>        R[i] = temp;</span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a>        Quick_Sort(R, low, i - <span class="dv">1</span>);</span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>        Quick_Sort(R, i + <span class="dv">1</span>, high);</span>
<span id="cb63-32"><a href="#cb63-32" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb63-33"><a href="#cb63-33" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="选择排序">选择排序</h2>
<h3 id="直接选择排序">直接选择排序</h3>
<p>每一趟在待排序元素中选取关键字最小的元素加入有序子序列，必须进行n-1趟处理</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Select_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 直接选择排序</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k;</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; n - <span class="dv">1</span>; i++)&#123;</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 找到[i, n-1]中最小的关键字的下标</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (k = i, j = i + <span class="dv">1</span>; j &lt; n; j++)</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (R[j].key &lt; R[k].key)</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>                k = j;</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (k != i)&#123;</span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>            temp = R[i];</span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>            R[i] = R[k];</span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>            R[k] = temp;</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="堆排序">堆排序</h3>
<p>堆：顺序存储的完全二叉树，大根堆（根≥左右），小根堆（根≤左右），结点i的左孩子是2i，右孩子是2i+1，父节点是i/2；编号≤n/2的结点都是分支结点</p>
<p>建堆：编号≤n/2的所有分支结点依次下坠调整（与关键字更大的孩子交换），建堆的复杂度为O(n)</p>
<p>排序：将堆顶元素加入有序子序列(堆顶元素与堆底元素交换)，堆底元素换到堆顶后，需要进行下坠调整，恢复大根堆，上述过程重复n-1趟</p>
<p>基于大根堆排序得递增，小根堆递减</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Sift(RecType R[], <span class="dt">int</span> low, <span class="dt">int</span> high)</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 堆排序下降操作</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> low: 表头</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> high: 表尾</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i = low, j = <span class="dv">2</span> * i;</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    RecType temp = R[i];</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (j &lt;= high)&#123;</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 比较左右孩子哪一个更大</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (j &lt; high &amp;&amp; R[j].key &lt; R[j + <span class="dv">1</span>].key) j++;</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 若该分支节点小于更大的孩子，则执行下降操作</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (temp.key &lt; R[j].key)&#123;</span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>            R[i] = R[j];</span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>            i = j;</span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>            j = <span class="dv">2</span> * i;</span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> <span class="cf">break</span>;</span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>    R[i] = temp;</span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Heap_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 堆排序</span></span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb65-33"><a href="#cb65-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb65-34"><a href="#cb65-34" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb65-35"><a href="#cb65-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 构造大根堆</span></span>
<span id="cb65-36"><a href="#cb65-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = n / <span class="dv">2</span> - <span class="dv">1</span>; i &gt;= <span class="dv">1</span>; i--)</span>
<span id="cb65-37"><a href="#cb65-37" aria-hidden="true" tabindex="-1"></a>        Sift(R, i, n);</span>
<span id="cb65-38"><a href="#cb65-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 堆顶元素与堆底元素交换，并恢复大根堆，n-1次循环后完成排序</span></span>
<span id="cb65-39"><a href="#cb65-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = n; i &gt;= <span class="dv">2</span>; i--)&#123;</span>
<span id="cb65-40"><a href="#cb65-40" aria-hidden="true" tabindex="-1"></a>        temp = R[<span class="dv">1</span>];</span>
<span id="cb65-41"><a href="#cb65-41" aria-hidden="true" tabindex="-1"></a>        R[<span class="dv">1</span>] = R[i];</span>
<span id="cb65-42"><a href="#cb65-42" aria-hidden="true" tabindex="-1"></a>        R[i] = temp;</span>
<span id="cb65-43"><a href="#cb65-43" aria-hidden="true" tabindex="-1"></a>        Sift(R, <span class="dv">1</span>, i - <span class="dv">1</span>);</span>
<span id="cb65-44"><a href="#cb65-44" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb65-45"><a href="#cb65-45" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="归并排序">归并排序</h2>
<p>把两个或多个有序的子序列合并为一个，2路归并为二合一，k路归并为k合一</p>
<p>若low&gt;high, 则将序列分从中间mid=(low+high)/2分开，对左半部分[low, mid]和右半部分[mid+ 1, high]递归地进行归并排序，然后将左右两个有序子序列Merge为一个</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Merge(RecType R[], <span class="dt">int</span> low, <span class="dt">int</span> mid, <span class="dt">int</span> high)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 归并排序排序两个子表</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> low: 子表1表头</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> mid: 子表2表头</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> high: 表尾</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i、j分别为两段的下标，k为新表的下标</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i = low, j = mid, k = <span class="dv">0</span>;</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>    RecType *R1 = (RecType *)malloc ((high - low) * <span class="kw">sizeof</span>(RecType));</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (i &lt; mid &amp;&amp; j &lt; high)</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (R[i].key &lt;= R[j].key)&#123;</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>            R1[k] = R[i];</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>            i++;</span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>            k++;</span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> &#123;</span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>            R1[k] = R[j];</span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a>            j++;</span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a>            k++;</span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 处理剩余部分</span></span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (i &lt; mid)&#123;</span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>        R1[k] = R[i];</span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a>        i++;</span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a>        k++;</span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (j &lt; high)&#123;</span>
<span id="cb66-31"><a href="#cb66-31" aria-hidden="true" tabindex="-1"></a>        R1[k] = R[j];</span>
<span id="cb66-32"><a href="#cb66-32" aria-hidden="true" tabindex="-1"></a>        j++;</span>
<span id="cb66-33"><a href="#cb66-33" aria-hidden="true" tabindex="-1"></a>        k++;</span>
<span id="cb66-34"><a href="#cb66-34" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb66-35"><a href="#cb66-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 将结果复制回原表</span></span>
<span id="cb66-36"><a href="#cb66-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (k = <span class="dv">0</span>, i = low; i &lt; high; k++, i++)</span>
<span id="cb66-37"><a href="#cb66-37" aria-hidden="true" tabindex="-1"></a>        R[i] = R1[k];</span>
<span id="cb66-38"><a href="#cb66-38" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb66-39"><a href="#cb66-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-40"><a href="#cb66-40" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Merge_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb66-41"><a href="#cb66-41" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb66-42"><a href="#cb66-42" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 归并排序</span></span>
<span id="cb66-43"><a href="#cb66-43" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb66-44"><a href="#cb66-44" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb66-45"><a href="#cb66-45" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb66-46"><a href="#cb66-46" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb66-47"><a href="#cb66-47" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb66-48"><a href="#cb66-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, length;</span>
<span id="cb66-49"><a href="#cb66-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (length = <span class="dv">1</span>; length &lt; n; length = <span class="dv">2</span> * length)</span>
<span id="cb66-50"><a href="#cb66-50" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 归并两个相邻的子表</span></span>
<span id="cb66-51"><a href="#cb66-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i = <span class="dv">0</span>; i + <span class="dv">2</span> * length &lt;= n; i = i + <span class="dv">2</span> * length)</span>
<span id="cb66-52"><a href="#cb66-52" aria-hidden="true" tabindex="-1"></a>            Merge(R, i, i + length, i + <span class="dv">2</span> * length);</span>
<span id="cb66-53"><a href="#cb66-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 有可能余下两个子表，其中最后一个子表长度不足length</span></span>
<span id="cb66-54"><a href="#cb66-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (i + length &lt;= n)</span>
<span id="cb66-55"><a href="#cb66-55" aria-hidden="true" tabindex="-1"></a>            Merge(R, i , i + length, n);</span>
<span id="cb66-56"><a href="#cb66-56" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="基数排序">基数排序</h2>
<p>将整个关键字拆分为d位，当前处理的关键字位可能取得r个值，建立r个队列</p>
<p>按照各个关键字位权重递增的次序（如: 个、十、百），做d趟分配和收集：</p>
<ul>
<li><p>分配：顺序扫描各个元素，根据当前处理的关键字位，将元素插入相应队列。一趟分配复杂度O(n)</p></li>
<li><p>收集：把各个队列中的结点依次出队并链接。一趟收集复杂度O(r)</p></li>
</ul>
<p>适用情况：</p>
<ul>
<li><p>数据元素的关键字可以方便地拆分为d组，且d较小</p></li>
<li><p>每组关键字的取值范围不大，即r较小</p></li>
<li><p>数据元素个数n较大</p></li>
</ul>
<div class="sourceCode" id="cb67"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>RecLNode *Radix_Sort(RecLNode *p)</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 基数排序</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> p: 排序链表</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>    RecLNode *head[RADIX], *tail[RADIX], *ptail;</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k;</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = DIGIT - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; i--)&#123;</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 初始化首尾指针</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; RADIX; j++)</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>            head[j] = tail[j] = NULL;</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 遍历排序链表的每个结点</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span>(p != NULL)&#123;</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>            k = (<span class="dt">int</span>)p-&gt;data[i];</span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (head[k] == NULL)&#123;</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a>                head[k] = p;</span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a>                tail[k] = p;</span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a>            &#125; <span class="cf">else</span> &#123;</span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>                tail[k]-&gt;next = p;</span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>                tail[k] = p;</span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;next;</span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a>        p = NULL;</span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 收集</span></span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; RADIX; j++)&#123;</span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (head[j] != NULL)&#123;</span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (p == NULL)&#123;</span>
<span id="cb67-31"><a href="#cb67-31" aria-hidden="true" tabindex="-1"></a>                    p = head[j];</span>
<span id="cb67-32"><a href="#cb67-32" aria-hidden="true" tabindex="-1"></a>                    ptail = tail[j];</span>
<span id="cb67-33"><a href="#cb67-33" aria-hidden="true" tabindex="-1"></a>                &#125; <span class="cf">else</span> &#123;</span>
<span id="cb67-34"><a href="#cb67-34" aria-hidden="true" tabindex="-1"></a>                    ptail-&gt;next = head[j];</span>
<span id="cb67-35"><a href="#cb67-35" aria-hidden="true" tabindex="-1"></a>                    ptail = tail[j];</span>
<span id="cb67-36"><a href="#cb67-36" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb67-37"><a href="#cb67-37" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb67-38"><a href="#cb67-38" aria-hidden="true" tabindex="-1"></a>        &#125;        </span>
<span id="cb67-39"><a href="#cb67-39" aria-hidden="true" tabindex="-1"></a>        ptail-&gt;next = NULL;</span>
<span id="cb67-40"><a href="#cb67-40" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb67-41"><a href="#cb67-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p;</span>
<span id="cb67-42"><a href="#cb67-42" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h1 id="递归与分治">1. 递归与分治</h1>
<p>递归算法：直接或间接地调用自身的算法</p>
<p>递归函数：用函数自身的较小模式给出递归算法定义的函数</p>
<p>分治：将一个规模为n的问题分解为k个规模较小的子问题，若子问题的规模仍然不够小，则继续分解直到最够小为止，子问题间相互独立（不包含公共的子问题）且与原问题相同，递归地解出子问题，然后将各子问题的解合并得到原问题的解</p>
<p>分治法的时间复杂度： <span class="math display">\[
\begin{equation}
T(n)=
\begin{cases}
O(1)&amp;n=1
\\
kT(\frac{n}{m})+f(n)&amp;n\gt1
\end{cases}
\end{equation}
\]</span></p>
<p><span class="math display">\[
T(n)=n^{log_mk}+\sum_{j=0}^{log_mn-1}k^jf(\frac{n}{m^j})
\]</span></p>
<h2 id="折半查找-1">折半查找</h2>
<h2 id="合并排序">合并排序</h2>
<h2 id="快速排序-1">快速排序</h2>
<h2 id="大整数乘法">大整数乘法</h2>
<p>对于二进制整数X、Y有：<span class="math inline">\(XY=(A\times2^{n/2}+B)(C\times2^{n/2}+D)=AC\times2^{n/2}+((A-B)(D-C)+AC+BD)\times2^{n/2}+BD\)</span></p>
<p><span class="math inline">\(T(n)=O(n^{log_23})=O(n^{1.59}),优于O(n^2)\)</span></p>
<h2 id="strassen矩阵乘法">Strassen矩阵乘法</h2>
<p><span class="math inline">\(T(n)=O(n^{log_27})=O(n^{2.81}),优于O(n^3)\)</span></p>
<h2 id="棋盘覆盖">棋盘覆盖</h2>
<p><span class="math inline">\(T(n)=O(4^k),渐进意义下的最优算法\)</span></p>
<h1 id="动态规划">2. 动态规划</h1>
<p>动态规划算法：与分治法类似，对原问题进行分解，不同点在于动态规划分解得到的子问题不是相互独立的（包含公共的子问题）。使用一个表来记录所有已解决的公共子问题的答案，避免大量的重复计算</p>
<p>动态规划算法的基本要素：</p>
<ul>
<li>最优子结构：从问题的最优解导出的子问题的解也是最优的</li>
<li>重叠子问题：公共子问题</li>
<li>备忘录方法：用表格保存已解决的子问题的答案</li>
</ul>
<h2 id="矩阵连乘">矩阵连乘</h2>
<p>若n个矩阵是可连乘的，则加括号的方式，即计算次序会对计算量有很大影响</p>
<p>子问题的递归结构 <span class="math display">\[
\begin{equation}
m[i,j]=
\begin{cases}
0&amp;i=j
\\
min_{i\le k\lt j}\{m[i,k]+m[k+1,j]+p_{i-1}p_kp_j\}&amp;i\lt j
\end{cases}
\end{equation}
\]</span></p>
<p>时间复杂度<span class="math inline">\(O(n^3)\)</span></p>
<div class="sourceCode" id="cb68"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> MatrixChain(<span class="dt">int</span> n, <span class="dt">int</span> p[n + <span class="dv">1</span>], <span class="dt">int</span> m[n + <span class="dv">1</span>][n + <span class="dv">1</span>], <span class="dt">int</span> s[n + <span class="dv">1</span>][n + <span class="dv">1</span>])</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 矩阵连乘</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 矩阵数量</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> p: 矩阵维度</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> m: 用于储存公共子问题答案</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> s: 用于储存最优解的分界点位置</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i为头，j为尾，l为全局断开位置（当前子问题的限制长度），k为子问题用于的遍历的断开位置</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, l, k, temp;</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 初始化主对角线</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt;=n; i++) m[i][i] = <span class="dv">0</span>;</span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 分割子问题</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (l = <span class="dv">2</span>; l &lt;=n; l++)&#123;</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 遍历所有子问题</span></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt;= n - l + <span class="dv">1</span>; i++)&#123;</span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>            j = i + l - <span class="dv">1</span>;</span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 最优解初始值，值为从当前位置断开</span></span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>            m[i][j] = m[i + <span class="dv">1</span>][j] + p[i - <span class="dv">1</span>] * p[i] * p[j];</span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 分界点初始值，值为当前位置</span></span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a>            s[i][j] = i;</span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 遍历子问题的最优解</span></span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (k = i + <span class="dv">1</span>; k &lt; j; k++)&#123;</span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true" tabindex="-1"></a>                temp = m[i][k] + m[k + <span class="dv">1</span>][j] + p[i - <span class="dv">1</span>] * p[k] * p[j];</span>
<span id="cb68-27"><a href="#cb68-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (temp &lt; m[i][j])&#123;</span>
<span id="cb68-28"><a href="#cb68-28" aria-hidden="true" tabindex="-1"></a>                    m[i][j] = temp;</span>
<span id="cb68-29"><a href="#cb68-29" aria-hidden="true" tabindex="-1"></a>                    s[i][j] = k;</span>
<span id="cb68-30"><a href="#cb68-30" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb68-31"><a href="#cb68-31" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb68-32"><a href="#cb68-32" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb68-33"><a href="#cb68-33" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb68-34"><a href="#cb68-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 输出</span></span>
<span id="cb68-35"><a href="#cb68-35" aria-hidden="true" tabindex="-1"></a>    printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, m[<span class="dv">1</span>][<span class="dv">5</span>]);</span>
<span id="cb68-36"><a href="#cb68-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; i++)&#123;</span>
<span id="cb68-37"><a href="#cb68-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">1</span>; j &lt;= n; j++)&#123;</span>
<span id="cb68-38"><a href="#cb68-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (i &lt; j) printf(<span class="st">&quot;%d &quot;</span>, s[i][j]);</span>
<span id="cb68-39"><a href="#cb68-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> printf(<span class="st">&quot;0 &quot;</span>);</span>
<span id="cb68-40"><a href="#cb68-40" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb68-41"><a href="#cb68-41" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb68-42"><a href="#cb68-42" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb68-43"><a href="#cb68-43" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="最长公共子序列">最长公共子序列</h2>
<p>子问题的递归结构 <span class="math display">\[
\begin{equation}
c[i,j]=
\begin{cases}
0&amp;i*j=0
\\
c[i-1][j-1]+1&amp;i,j\gt0;x_i=y_j
\\
max\{c[i][j-1],c[i-1][j]\}&amp;i,j\gt0;x_i\ne y_j
\end{cases}
\end{equation}
\]</span> 时间复杂度<span class="math inline">\(O(mn)\)</span></p>
<h2 id="背包问题">0-1背包问题</h2>
<p>子问题的递归结构 <span class="math display">\[
\begin{equation}
B[k,w]=
\begin{cases}
B[k-1,w]&amp;w_k\gt w
\\
max\{B[k-1,w],B[k-1,w-w_k]+b_k\}&amp;w_k\le w
\end{cases}
\end{equation}
\]</span></p>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Knapsack(<span class="dt">int</span> n, <span class="dt">int</span> weight[], <span class="dt">int</span> value[], <span class="dt">int</span> WEIGHT, <span class="dt">int</span> VALUE[n + <span class="dv">1</span>][WEIGHT + <span class="dv">1</span>], <span class="dt">int</span> x[n + <span class="dv">1</span>])</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 背包问题（动态规划）</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> weight: 物品重量</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> value: 物品价值</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> WEIGHT: 背包最大重量</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> VALUE: 用于储存最优解的物品总价值</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> x: 用于储存物品的选择</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i为第i个物品，w为重量上限（当前子问题的限制重量）</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, w;</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 初始化未放入物品时的背包</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (w = <span class="dv">0</span>; w &lt;= WEIGHT; w++) VALUE[<span class="dv">0</span>][w] = <span class="dv">0</span>;</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 遍历所有物品</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt;= n; i++)&#123;</span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 初始化重量上限为0的情况</span></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>        VALUE[i][<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 遍历所有子问题</span></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (w = <span class="dv">1</span>; w &lt;= WEIGHT; w++)&#123;</span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 如果当前物品能够满足约束条件，则进行比较，若更优则替换上一物品的最优情况</span></span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (weight[i] &lt;= w)&#123;</span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (value[i] + VALUE[i - <span class="dv">1</span>][w - weight[i]] &gt; VALUE[i - <span class="dv">1</span>][w])&#123;</span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a>                    VALUE[i][w] = value[i] + VALUE[i - <span class="dv">1</span>][w - weight[i]];</span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a>                &#125; <span class="cf">else</span> &#123;</span>
<span id="cb69-28"><a href="#cb69-28" aria-hidden="true" tabindex="-1"></a>                    VALUE[i][w] = VALUE[i - <span class="dv">1</span>][w];</span>
<span id="cb69-29"><a href="#cb69-29" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb69-30"><a href="#cb69-30" aria-hidden="true" tabindex="-1"></a>            &#125; <span class="cf">else</span> &#123;</span>
<span id="cb69-31"><a href="#cb69-31" aria-hidden="true" tabindex="-1"></a>                VALUE[i][w] = VALUE[i - <span class="dv">1</span>][w];</span>
<span id="cb69-32"><a href="#cb69-32" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb69-33"><a href="#cb69-33" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb69-34"><a href="#cb69-34" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb69-35"><a href="#cb69-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 输出</span></span>
<span id="cb69-36"><a href="#cb69-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt;= n; i++)&#123;</span>
<span id="cb69-37"><a href="#cb69-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (w = <span class="dv">0</span>; w &lt;= WEIGHT; w++)&#123;</span>
<span id="cb69-38"><a href="#cb69-38" aria-hidden="true" tabindex="-1"></a>            printf(<span class="st">&quot;%d &quot;</span>, VALUE[i][w]);</span>
<span id="cb69-39"><a href="#cb69-39" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb69-40"><a href="#cb69-40" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb69-41"><a href="#cb69-41" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb69-42"><a href="#cb69-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// traceback</span></span>
<span id="cb69-43"><a href="#cb69-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = n; i &gt; <span class="dv">0</span>; i--)&#123;</span>
<span id="cb69-44"><a href="#cb69-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (VALUE[i][WEIGHT] == VALUE[i - <span class="dv">1</span>][WEIGHT])&#123;</span>
<span id="cb69-45"><a href="#cb69-45" aria-hidden="true" tabindex="-1"></a>            x[i] = <span class="dv">0</span>;</span>
<span id="cb69-46"><a href="#cb69-46" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> &#123;</span>
<span id="cb69-47"><a href="#cb69-47" aria-hidden="true" tabindex="-1"></a>            x[i] = <span class="dv">1</span>;</span>
<span id="cb69-48"><a href="#cb69-48" aria-hidden="true" tabindex="-1"></a>            WEIGHT -= weight[i];</span>
<span id="cb69-49"><a href="#cb69-49" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb69-50"><a href="#cb69-50" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb69-51"><a href="#cb69-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt;= n; i++)&#123;</span>
<span id="cb69-52"><a href="#cb69-52" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot;%d &quot;</span>, x[i]);</span>
<span id="cb69-53"><a href="#cb69-53" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb69-54"><a href="#cb69-54" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h1 id="贪心算法">3. 贪心算法</h1>
<p>贪心算法：不考虑总体最优，只作出局部最优</p>
<p>贪心算法的基本要素：</p>
<p>最优子结构：从问题的最优解导出的子问题的解也是最优的</p>
<p>贪心选择：所求问题的整体最优可以通过一系列的局部最优达到</p>
<h2 id="哈夫曼编码-1">哈夫曼编码</h2>
<h2 id="单源最短路径">单源最短路径</h2>
<h2 id="最小生成树">最小生成树</h2>
<h2 id="背包问题-1">背包问题</h2>
<p>与0-1背包问题类似，不同点在于可以将物品的一部分装入背包</p>
<p>优先选择平均价值更高的物品装入背包</p>
<h2 id="最优装载">最优装载</h2>
<p>优先选择重量最轻者装载</p>
<h1 id="回溯法">4. 回溯法</h1>
<p>回溯法：避免不必要的搜索的穷举法，以问题的可能解为叶子结点构造解空间树，按深度优先搜索解空间树，搜索时若当前结点不包含问题的解，则剪枝并回溯。搜索到叶子结点时则说明找到了问题的一个解，然后回溯，直至整个解空间树遍历完毕，能够找到所有满足约束条件的解。</p>
<h1 id="分支限界法">5. 分支限界法</h1>
<p>分支限界法：按广度优先或最小消耗/最大收益优先搜索解空间树，每一个活结点只有一次激活成为扩展结点，活结点一旦成为扩展结点，就一次性产生其所有儿子结点，其中不满足解或非最优解（儿子结点为叶子结点）被舍弃，剩余的儿子结点加入活结点，之后从活结点中取出下一个作为扩展结点，并重复扩展过程直至最优解为叶子结点，能够找到一个满足约束条件的解</p>

        </div>

    </div>

    

    

    

    
  <div class="article-copyright hairline">
    <p>
      本作品采用  <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议 (CC BY-NC-ND 4.0)</a> 进行许可。
    </p>
  </div>
  

    

    
<nav class="article-nav">
  
  
    <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">操作系统</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=数据结构 - NijiBlog&url=https%3A%2F%2Fkinniji.github.io%2F%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%2F">
            <ion-icon name="logo-twitter"></ion-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=数据结构 - NijiBlog&u=https%3A%2F%2Fkinniji.github.io%2F%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%2F">
            <ion-icon name="logo-facebook"></ion-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=数据结构 - NijiBlog&url=https://kinniji.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>
















<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/NLP/">NLP</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/KR/">KR</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8C%BB%E5%AD%A6/">医学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6/">统计学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%80%83%E7%A0%94/">考研</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E5%BA%93/Neo4j/">Neo4j</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C/">网络</a></li></ul></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%95%E9%A2%98/" rel="tag">试题</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
          </li>
        
          <li>
            <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
          </li>
        
          <li>
            <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9B%E7%BA%A7/">数据库四级</a>
          </li>
        
          <li>
            <a href="/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%EF%BC%88%E5%90%AB%E8%AF%95%E9%A2%98%EF%BC%89/">信息安全（含试题）</a>
          </li>
        
          <li>
            <a href="/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E5%AD%A6%EF%BC%88%E5%90%AB%E8%AF%95%E9%A2%98%EF%BC%89/">医学影像学（含试题）</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <div class="footer-wrap">
        <div class="footer-inner"> 
            NijiBlog &copy; 2022<br>
            Powered By <a href="https://hexo.io/zh-cn/" target="_blank">Hexo</a> ·
            Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>

<script type="module" src="https://unpkg.com/ionicons@6.0.2/dist/ionicons/ionicons.esm.js"></script>






<script src="/dist/build.js?1654266144177.js"></script>


<script src="/dist/custom.js?1654266144177.js"></script>













<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>