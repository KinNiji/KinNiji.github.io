<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>知识表示 | NijiBlog</title>

    <meta name="description" content="NijiBlog">
    <meta name="keywords" content="">

    

    <meta property="og:locale" content="cn" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "知识表示 | NijiBlog"  />
    <meta property="og:description" content= "NijiBlog" />
    <meta property="og:url" content="https://kinniji.github.io/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="Niji" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="NijiBlog" />
    <meta name="twitter:title" content="知识表示 | NijiBlog"/>
    <meta name="twitter:description" content="NijiBlog"/>
    <script type="application/ld+json">
        {
            "description": "NijiBlog",
            "author": { "@type": "Person", "name": "Niji" },
            "@type": "BlogPosting",
            "url": "https://kinniji.github.io/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "https://KinNiji.github.ioundefined"
            },
            "name": "Niji"
            },
            "headline": "知识表示 | NijiBlog",
            "datePublished": "2022-01-14T16:00:00.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https://kinniji.github.io/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1654266144177.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1654266144177.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>NijiBlog</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="">
        <ion-icon name=""></ion-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-cl7hpgb43000070k14o2chn4t" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      知识表示
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2022-01-14T16:00:00.000Z" itemprop="datePublished">2022/01/15</time>
</div>

            
            <div class="article-category">
                <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
            </div>
            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KR/" rel="tag">KR</a></li></ul>
            </div>
            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <h2 id="知识">知识</h2>
<p>知识的分类：</p>
<ul>
<li>陈述性知识（Declarative knowledge）指个人具有有意识的提取线索，因而能直接陈述的知识。是关于“是什么”、“为什么”的知识。</li>
<li>程序性知识（Procedural knowledge）个人没有有意识提取线索，只能借助某种作业形式间接推论其存在的知识。是关于“怎么办”的知识。一套办事的操作步骤。</li>
<li>显性知识（Explicit Knowledge）“能明确表达的知识”，“可以写下来，能说出来的知识”。</li>
<li>隐性知识（Tacit Knowledge）波兰尼（Michael Polanyi）在1958年从哲学领域提出的概念。</li>
<li>根据作用范围：
<ul>
<li>常识性知识</li>
<li>领域性知识</li>
</ul></li>
<li>根据确定程度：
<ul>
<li>确定性知识</li>
<li>不确定性知识</li>
</ul></li>
<li>根据结构及表现形式：
<ul>
<li>逻辑性知识</li>
<li>形象性知识</li>
</ul></li>
<li>根据表达的内容：
<ul>
<li>事实性知识</li>
<li>过程性知识（有一定规律性的处理问题的方法）</li>
<li>控制性知识（对事物的一些控制规则）</li>
<li>行为性知识（常表示为某种数学模型）</li>
<li>实例性知识（只给出实例而规律隐藏在其中的案例）</li>
<li>类比性知识（只能给出相似性的描述而不能完整刻画事物的一些比喻等）</li>
<li>元知识（关于知识的知识）</li>
</ul></li>
</ul>
<p>知识的特性：</p>
<ul>
<li>相对正确性：任何知识都是在一定的条件及环境下产生的，在这种条件和环境下才是正确的。</li>
<li>不确定性：随机性、模糊性、经验和不完全性引起的不确定性。</li>
<li>可表示性与可利用性 ：可表示性指用适当的形式表示知识。可利用性是指知识可以被利用。</li>
</ul>
<h2 id="知识工程">知识工程</h2>
<p>知识工程：以知识为处理对象，研究知识系统的知识表示、处理和应用的方法和开发工具的学科</p>
<p>传统KE的基本特点：</p>
<ul>
<li>自上而下</li>
<li>严重依赖专家和人的干预</li>
<li>规模有限，质量存疑</li>
</ul>
<p>传统KE的主要挑战：</p>
<ul>
<li>知识获取困难
<ul>
<li>隐性知识、过程知识等难以表达</li>
<li>领域知识的形式化表达较为困难</li>
<li>专家知识不可避免地存在主观性</li>
<li>不同专家之间知识可能存在不一致性</li>
<li>知识表达难以完备，缺漏是常态</li>
</ul></li>
<li>知识应用困难
<ul>
<li>应用易于超出预先设定的知识边界</li>
<li>很多应用需要常识的支撑</li>
<li>难以处理异常情况</li>
<li>难以处理不确定性推理</li>
<li>知识更新困难</li>
</ul></li>
</ul>
<p>大数据知识工程（BigKE）的特点：互联网上的搜索关键字具有开放性、规模巨大等特点</p>
<ul>
<li>大规模开放性应用：永远不知道用户下一个搜索关键字是什么</li>
<li>精度要求不高：搜索引擎从来不需要保证每个搜索的理解和检索都是正确的</li>
<li>应用/推理简单：大部分搜索理解与回答只需要实现简单的推理</li>
</ul>
<h2 id="知识表示">知识表示</h2>
<p>知识表示的用途或特点：</p>
<ul>
<li>客观事物的机器标识（KR is a Surrogate)，定义客观实体的机器指代或指称。</li>
<li>一组本体约定和概念模型（A KR is a Set of Ontological Commitments)，定义用于描述客观事物的概念和类别体系。</li>
<li>支持推理的表示基础（A KR is a Theory of Intelligent Reasoning)，提供机器推理的模型与方法。</li>
<li>用于高效计算的数据结构（A KR is a medium for Efficient Computation)，知识表示也是一种用于高效计算的数据结构。</li>
<li>人可理解的机器语言（A KR is a Medium of Human Expression)，接近于人的认知，是人可理解的机器语言。</li>
</ul>
<p>知识表示方法的选择：方法的选择关系到知识的有效存储，影响知识推理效率和对新知识的获取能力。</p>
<ul>
<li>能充分表示领域知识：足够的表示能力，能正确有效地表示问题求解所需的各种知识。</li>
<li>具有较高的知识使用效率：清晰自然的模块结构，有利于对知识的利用。表示模型简单、有效，便于领域问题求解策略的推理和对知识库的搜索实现。</li>
<li>易于扩展与管理：易于新知识的获取和知识库的维护、扩充与完善。</li>
<li>知识和元知识的统一表达：知识和知识元属于不同层次的知识，使用统一的表示方法可以简化知识处理。</li>
<li>便于理解与实现：好的知识表示是同时为机器和人设计的。</li>
</ul>
<p>医学知识表示的挑战：</p>
<ul>
<li>医学词汇、本体、CIGs和EHRs的整合</li>
<li>知识的更新和维护</li>
<li>精准医疗的知识定制和总结</li>
<li>为了支持数据驱动的医学大数据分析</li>
<li>多重病症</li>
<li>将遗传和组学知识纳入医疗保健</li>
<li>促进将基于知识的技术和系统纳入卫生保健</li>
<li>扩展这些技术和系统的用途</li>
</ul>
<h3 id="早期方法">早期方法</h3>
<h4 id="命题逻辑">命题逻辑</h4>
<p>命题（Proposition）：具有“真假”意义的陈述句。</p>
<p>原子命题：不能被分解成更为简单的陈述句。（不包含任何逻辑联结词的命题）</p>
<p>复合命题：由联结词、标点符号和原子命题等组合构成的命题。</p>
<p>命题演算的判定问题：通过有限步骤确定给定命题是永真式、永假式或可满足的问题。</p>
<p>范式：当命题中原子命题的数目较大时，用真值表演算太麻烦，可把命题公式化为某种标准型。</p>
<p>个体（Individual）：原子命题中所描述的对象。指可以独立存在的事物，可以是抽象的概念，也可以是具体的实体。任意一个个体都有一个讨论范围，称为论域（Universe of Discourse），通常用D表示。个体相当于论域中的元素。</p>
<p>谓词（Predicates）：在原子命题中用以描述个体的性质或个体间关系的部分。</p>
<p>命题的谓词形式：一个命题用一个谓词和n个有次序的个体表示成 P(a1, a2, …, an）。个体的出现顺序影响命题的真值。谓词中的个体数目称为谓词的元数。</p>
<p>函词（Function）：指以论域为定义域和值域的一种映射，用来表示函数。在原子命题中用以描述个体的性质或个体间关系的部分。</p>
<p>量词（Quantifier）：</p>
<ul>
<li>全称量词（∀）：“所有的”，“任意的”，“每一个”</li>
<li>存在量词（∃）：“存在一些”，“对于某些”，“至少有”</li>
</ul>
<h4 id="谓词逻辑">谓词逻辑</h4>
<p>谓词逻辑：人工智能领域的一种知识表示方法。</p>
<p>谓词逻辑翻译的一般步骤：</p>
<ul>
<li>正确理解给定命题。必要时把命题改叙，使其能表达每个原子命题及原子命题间的关系。</li>
<li>把每个原子命题分解成个体、谓词和量词。在全论域中讨论时，要给出特性谓词约束范围。</li>
<li>找出适当的量词。全称量词后跟蕴含式，存在量词后跟合取式。</li>
<li>用适当的联结词把给定命题表示出来。</li>
</ul>
<p>谓词逻辑的特点：</p>
<ul>
<li>优点：
<ul>
<li>结构性。能把事物的属性以及事物间的各种语义联想显式地表示出来 。</li>
<li>严密性。有形式化的语法和语义，以及相关的推理规则。</li>
<li>可实现性。可判定，可以转换为计算机内部形式，以便用算法实现。</li>
</ul></li>
<li>缺点：
<ul>
<li>有限的可用性。</li>
<li>一阶逻辑的逻辑归结只是半可判定性的。</li>
<li>无法表示不确定性知识。</li>
</ul></li>
</ul>
<h4 id="霍恩逻辑">霍恩逻辑</h4>
<p>霍恩子句：带有最多一个肯定文字的子句。</p>
<p>霍恩逻辑（Hom Logic）：一阶逻辑的子集。</p>
<p>霍恩子句和霍恩逻辑的特点：</p>
<ul>
<li>优点：
<ul>
<li>结构性。能把事物的属性以及事物间的各种语义联想显式地表示出来。</li>
<li>严密性。有形式化的语法和语义，以及相关的推理规则。</li>
<li>易实现性。可判定，可以转换为计算机内部形式，以便用算法实现。</li>
</ul></li>
<li>缺点：
<ul>
<li>有限的表达能力。</li>
<li>不能定义类表达式。</li>
<li>不能够任意使用量化 。</li>
<li>无法表示不确定性知识。</li>
</ul></li>
</ul>
<h4 id="描述逻辑">描述逻辑</h4>
<p>描述逻辑：一阶逻辑的一个可判定子集 。</p>
<p>描述逻辑可以被看成是利用一阶逻辑对语义网络和框架进行形式化后的产物。</p>
<p>描述逻辑支持一元谓词和二元谓词 。</p>
<ul>
<li>一元谓词称为类（概念）</li>
<li>二元谓词称为关系</li>
</ul>
<p>描述逻辑的知识库 O:=&lt;T, A&gt;，T 即 T-box，A 即 A-box</p>
<ul>
<li>T-box（Terminology Box）包含内涵知识，描述概念的一般性质。由于概念之间存在包含关系，T-box 知识形成类似格的结构，这是由包含关系决定的，与具体实现无关。</li>
<li>A-box（Assertion Box）包含外延知识（又称断言知识），描述论域中的特定个体。</li>
<li>R-Box（Role Box）包含属性/关系知识（property axioms）</li>
</ul>
<p>描述逻辑同时具有很强的表达能力和可判定性。</p>
<p>描述逻辑近年来受到广泛关注，被选为 W3C 互联网本体语言 (OWL) 的理论基础。</p>
<p>描述逻辑的特点：</p>
<ul>
<li>优点：
<ul>
<li>结构性。能把事物的属性以及事物间的各种语义联想显式地表示出来。</li>
<li>严密性。有形式化的语法和语义，以及相关的推理规则。</li>
<li>易实现性。可判定，可以转换为计算机内部形式，以便用算法实现。</li>
<li>多样性。具有大量可判定的扩展，以满足不同应用场景的需求。</li>
</ul></li>
<li>缺点：
<ul>
<li>有限的表达能力。</li>
<li>不支持显式使用变量。</li>
<li>不能够任意使用量化。</li>
<li>无法表示不确定性知识。</li>
</ul></li>
</ul>
<h4 id="产生式规则">产生式规则</h4>
<p>产生式规则的一般形式：由条件和动作组成的指令，记为 C -&gt; A（IF C THEN A）</p>
<ul>
<li>C：产生式前提（前件），指出该产生式可用的条件。</li>
<li>A：一组结论或操作（后件），指出当C的条件成立时，应当获得的结论或执行的操作。</li>
</ul>
<p>产生式规则具有广泛的知识表示能力：既可以表示确定性知识，又可以表示不确定性知识。</p>
<p>产生式规则与逻辑蕴含式：</p>
<ul>
<li>逻辑蕴含式是产生式规则的一种。
<ul>
<li>逻辑蕴含式是一个逻辑表达式，值只有真和假，只能表示精确知识。产生式规则表示的知识可以是不确定的。</li>
<li>逻辑蕴含式的匹配要求一定是精确的，产生式规则的前提和结论都可以是不确定的，匹配自然是可以不确定的。</li>
</ul></li>
</ul>
<p>产生式规则系统的构成：</p>
<ul>
<li>产生式规则库（规则集）
<ul>
<li>由领域规则组成，以某种动态数据结构进行组织。</li>
<li>规则库中知识的完整性、一致性、准确性、组织的合理性直接影响系统的性能。</li>
</ul></li>
<li>综合数据库（事实库）
<ul>
<li>存放问题求解过程中各种当前信息的数据结构。如：问题的初始状态、原始证据、中间结论、最终结果。</li>
<li>当规则库中某条规则的前提与综合数据库中的某些已知事实匹配时，该产生式被激活，并将它推出的结论放入综合数据库，作为新的已知事实。</li>
</ul></li>
<li>控制系统（推理机）
<ul>
<li>一个解释程序，控制和协调规则库及综合数据库的运行。
<ul>
<li>按一定策略从规则库中选择规则，与综合数据库中的事实进行匹配。</li>
<li>对于匹配成功的多条规则进行消解，选出一条规则执行。</li>
<li>将规则结论存入综合数据库或执行相应的操作。</li>
<li>对于不确定性知识，计算结论的不确定性。</li>
<li>在适当的时候停止系统的运行。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="专家系统">专家系统</h4>
<p>专家系统：一种具有智能的计算机系统，它应用人工智能技术和计算机技术，内部含有大量的某个领域专家水平的知识与经验，能够利用这些知识和解决问题的方法进行推理和判断，模拟人类专家的决策过程。</p>
<p>专家系统的特征：</p>
<ul>
<li>具有专家水平的领域知识
<ul>
<li>数据级知识：初始事实，中间结论，最终结论等。如患者的症状、化验结果、专家系统推出的病因、治疗方案等。</li>
<li>知识库级知识：专家的知识。如医学常识、医生诊断疾病的经验等。（系统的性能取决于此类知识的质量和数量）</li>
<li>控制级知识：如何运用前两种知识的知识。如搜索策略、匹配算法等。</li>
</ul></li>
<li>能进行有效的推理
<ul>
<li>领域不同，要求的推理机制不同。如，精确推理、不确定性推理</li>
</ul></li>
<li>获取知识的能力
<ul>
<li>知识工程师和领域专家采用知识编辑器输入。</li>
<li>基于机器学习自动进化。</li>
</ul></li>
<li>灵活性：知识库与推理机分离。</li>
<li>透明性：系统自身及其行为能被用户所理解。</li>
<li>交互性：领域专家和知识工程师获取知识。获取求解问题时所需的已知事实。回答用户提问。</li>
<li>实用性：针对特定领域问题开发。</li>
</ul>
<p>专家系统的分类：</p>
<ul>
<li>解释专家系统：通过对已知信息和数据的分析与解释，确定它们的含义。</li>
<li>预测专家系统：通过对过去和现在已知状况的分析，推断未来可能发生的情况。</li>
<li>设计专家系统：根据设计要求，求出满足设计问题约束的目标配置。</li>
<li>诊断专家系统：根据观察到的数据推断某个对象机能失常（故障）的原因。</li>
<li>教学专家系统：根据学生的特点、弱点和基础知识，选择最适当的教案和教学方法。</li>
<li>控制专家系统：自适应地管理一个受控对象或客体的全部行为，使之满足预期要求。</li>
</ul>
<h4 id="框架">框架</h4>
<p>框架（Frame）：一种描述对象（事物 、事件或概念等）属性的数据结构。</p>
<p>框架的目标：更好地理解视觉推理和自然语言处理。</p>
<p>框架的基本思想：人们对现实世界中各种事物的认识都以一种类似于框架的结构存储在记忆中。当面临一个新事物时，就从记忆中找出一个合适的框架，并根据实际情况对其细节加以修改、补充，从而形成对当前事物的认识。</p>
<p>类：框架的基本单位。每个类有一些槽，每个槽又可分为若干“侧面”。</p>
<ul>
<li><p>槽（Slot）：表示描述对象的一个属性，</p></li>
<li><p>侧面（Facet）：表示槽属性的一个方面，</p></li>
<li><p>槽和侧面都可以有值，分别称为槽值和侧面值 。</p></li>
</ul>
<p>框架允许给属性设默认值，以及设立触发器以维护框架 。</p>
<p>框架是知识的基本单位，把一组有关的框架连结起来便可形成一个框架网络。</p>
<ul>
<li>纵向联系：继承</li>
<li>横向联系：用另一框架填写槽值或侧面值</li>
</ul>
<p>框架的特点：</p>
<ul>
<li>优点：
<ul>
<li>结构性，能把事物的属性以及事物间的各种语义联想显式地表示出来 。</li>
<li>框架对于知识的描述比较全面，支持默认值以及触发器。</li>
</ul></li>
<li>缺点：
<ul>
<li>构建成本非常高，对知识库的质量要求非常高 。</li>
<li>默认值会增大推理的复杂度。</li>
<li>无法表示不确定性知识 。</li>
</ul></li>
</ul>
<h4 id="语义网络">语义网络</h4>
<p>语义网络（Semantic Network)：概念及其语义关系组成的一种带标识的有向图。</p>
<ul>
<li>节点：各种事物、概念、情况、状态等。每个节点可以有若干属性。</li>
<li>边：也称连接弧或联想弧，表示各种语义联系、动作 。每个边有方向、有标注。</li>
</ul>
<p>语义网络的基本语义关系：</p>
<ol type="1">
<li><p>类属关系：具有共同属性的不同事物间的分类关系、成员关系或实例关系。“具体与抽象”、“个体与集体”的层次关系</p>
<ul>
<li><p>AKO (A-Kind-Of)：一个事物是另一个事物的一种类型。</p></li>
<li><p>AMO (A-Member-Of)：一个事物是另一个事物的成员。</p></li>
<li><p>ISA ( Is-A)：一个事物是另一个事物的实例。</p></li>
</ul></li>
<li><p>聚类关系（包含关系）：具有组织或结构特征的“部分与整体”之间的关系。</p>
<p>与类属关系的区别：聚类关系一般不具备属性的继承性。</p>
<ul>
<li>Part-of：一个事物是另一个事物的一部分。（脚， Part-of，肢体） ，（细胞核，Part-of，细胞）</li>
</ul></li>
<li><p>属性关系：事物和其属性之间的关系。</p>
<ul>
<li><p>Have：一个节点具有另一个节点所描述的属性。</p></li>
<li><p>Can：一个节点能做另一个节点的事情。（降压药，Can，降血压），（糖尿病，有症状，多饮）</p></li>
</ul></li>
<li><p>因果关系：由于某一事件的发生而导致另一个事件的发生，适合规则性知识。</p>
<ul>
<li>If-then：如果...那么...（超重，If-then，糖尿病高危人群）</li>
</ul></li>
<li><p>时间关系：不同事件在其发生时间方面的先后关系。</p>
<ul>
<li><p>Before：一个事件在另一个事件之前发生。（单药治疗， before，二联治疗）</p></li>
<li><p>After：表示一个事件在另一个事件之后发生。（三联治疗，after，二联治疗）</p></li>
</ul></li>
<li><p>位置关系</p>
<ul>
<li><p>Located-on（表皮， Located-on，真皮）</p></li>
<li><p>Located-at</p></li>
<li><p>Located-under</p></li>
<li><p>Located-inside（心脏，Located-inside，身体）</p></li>
<li><p>Located-outside</p></li>
</ul></li>
<li><p>相近关系（相似关系）：不同事物在形状、内容等方面相似或接近。</p>
<ul>
<li><p>Similar-to（相似）</p></li>
<li><p>Near-to（接近）</p></li>
</ul></li>
<li><p>组成关系：某一事物由其他一些事物构成。</p>
<ul>
<li>Composed-of</li>
</ul></li>
</ol>
<p>知识的语义网络表示：</p>
<ul>
<li>事实性知识的表示：
<ul>
<li>简单事实用两个节点和基本语义关系即可表示。</li>
<li>复杂事实通常涉及多个事物，通常用语义网络表示。</li>
</ul></li>
<li>情况、动作和事件的表示：
<ul>
<li>情况的表示：不及物动词语句的表示或没有间接宾语的及物动词语句，如果语句的动作表示了一些其他情况，如动作的时间等。增加一个情况节点用于指出各种不同的情况。</li>
<li>动作的表示：语句既有发出动作的主体，又有接受动作的客体。增加一个动作节点以指出动作的主体和客体。</li>
<li>事件的表示：增加一个事件节点表示事件知识。</li>
</ul></li>
<li>连词和量词的表示：
<ul>
<li>合取与析取的表示：增加合取节点和析取节点。</li>
</ul></li>
<li>存在量词和全称量词的表示：
<ul>
<li>存在量词用“是一种”，“是一个”表示。</li>
<li>全称量词用语义网络分区技术表示。把一个复杂的命题划分成若干个子命题，每个子命题用一个简单的语义网络表示，称为子空间，每个子空间看作大空间的一个节点，称为超节点。空间可以逐层嵌套，子空间之间用弧连接。</li>
</ul></li>
</ul>
<p>用语义网络表示知识的步骤：</p>
<ol type="1">
<li>确定问题中所有对象及其属性。</li>
<li>确定对象间的关系。</li>
<li>对语义网络中的节点及弧进行整理，包括增加节点、弧和归并节点等。
<ul>
<li>ISA、AKO、AMO等类属关系：下层节点对上层节点具有属性继承性。抽取同一层节点的共同属性加入上层节点中，避免信息冗余。</li>
<li>因果关系：增加情况节点，从该节点引出多条弧，将原因节点和结果节点连接起来。</li>
<li>动作关系：增加动作节点，从该节点引出多条弧，将动作的主体节点、客体节点连接起来。</li>
<li>“与”“或”关系：增加“与”节点和“或”节点，用弧将这些“与”“或”节点与其他节点连接起来以表示知识中的语义关系。</li>
<li>全称量词和存在量词：采用语义网络分区技术。</li>
<li>规则性知识：分析问题中的条件与结论，将它们作为语义网络中的两个节点，然后用 if-then 弧将它们连接起来。</li>
</ul></li>
<li>以对象作为节点，关系作为节点间的弧，连接形成语义网络。</li>
</ol>
<p>语义网络的推理方法：</p>
<ul>
<li><p>继承推理：下层节点继承上层节点的属性或方法。</p>
<ul>
<li>建立节点表，存放待求节点和所有以继承弧与此节点相连的那些节点。初始状态只有待求解的节点。</li>
<li>检查表中第一个节点是否有继承弧。如果有，从该弧所指的存放所有节点的节点表的末尾记录这些节点的所有属性，并从节点表中删除第一个节点。如果没有，仅从节点表中删除第一个节点。</li>
<li>重复检查表中的下一个节点是否有继承弧，直到节点表为空。记录下来的属性就是待求节点的所有属性。</li>
<li>推理规则：
<ul>
<li>IF X (AKO) Y AND Y (AKO) Z THEN X(AKO) Z</li>
<li>IF X (ISA) Y AND Y (AKO) Z THEN X (ISA) Z</li>
<li>IF X (AKO) Y AND Y (属性) Z THEN X (属性) Z</li>
<li>IF X (ISA) Y AND Y (属性) Z THEN X (属性) Z</li>
<li>IF X (属性) Y AND Y (AKO) Z THEN X (属性) Z</li>
<li>IF X (属性) Y AND Y (ISA) Z THEN X (属性) Z</li>
</ul></li>
</ul></li>
<li><p>匹配推理：在语义网络中寻找与待求问题相符的语义网络模式。</p>
<ul>
<li><p>根据问题的要求构造网络片段，片段中有些节点或弧为空，标记待求解的问题（询问处）。</p></li>
<li><p>根据片段在知识库中寻找相应的信息。</p></li>
<li><p>当待求的语义网络片段和知识库中的语义网络片段相匹配时，与询问处（待求解的地方）相匹配的事实就是问题的解。</p></li>
</ul></li>
</ul>
<p>语义网络的特点：</p>
<ul>
<li>优点：
<ul>
<li>联想性。最初是作为人类联想记忆模型提出来的。</li>
<li>自然性。直观地把事物的属性及其语义联系表示出来，便于理解，自然语言与语义网络的转换比较容易实现，故语义网络表示法在自然语言理解系统中的应用最为广泛 。</li>
<li>结构性。语义网络是一种结构化的知识表示方法，对数据子图特别有效 。它能把事物的属性以及事物间的各种语义联想显式地表示出来。</li>
<li>自索引性。用户通过与某一节点连接的弧很容易找出相关信息，不必查找整个知识库，可以避免搜索时的组合爆炸问题。</li>
</ul></li>
<li>缺点：
<ul>
<li>无形式化语法。
<ul>
<li>语义网络表示知识的手段多样，虽然灵活性很高，但是由于表示形式的不一致增加了对其处理的复杂性。</li>
</ul></li>
<li>无形式化语义。
<ul>
<li>与一阶谓词逻辑相比，语义网络没有公认的形式表示体系。一个给定的语义网络表达的含义完全依赖处理程序如何对它进行解释。通过推理网络而实现的推理不能保证其正确性。</li>
<li>采用量词的语义网络表示法在逻辑上是不充分的，可能存在二义性 。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="语义网">语义网</h3>
<p>语义网（Semantic Web）：核心是通过给万维网上的文档（如HTML文档、XML文档）添加能够被计算机所理解的语义“元数据”（Meta data），从而使整个互联网成为一个通用的信息交换媒介。</p>
<p>语义网的缺点： - 节点和边的值没有标准，完全是由用户自己定义。 - 多源数据融合比较困难，因为没有标准。 - 无法区分概念节点和对象节点。 - 无法对节点和边的标签进行定义。</p>
<h4 id="rdf">RDF</h4>
<p>RDF（Resource Description Framework）：Web中信息的表示框架。W3C的RDF工作组制定的关于知识图谱的国际标准，是W3C一系列语义网标准的核心。既满足计算机对Web中信息的处理，又便于人的阅读。RDF提供了一个用于表示该信息的公共框架，因此可以在应用程序之间交换信息，而不会失去意义。</p>
<p>资源（Resource）：IRI 或 literal，同义词：entity。可以是任何事物，包括物理实体、文档、抽象概念、数字和字符串。</p>
<ul>
<li>字面量（literal）有数据类型，例如 strings, numbers, and dates。可以通过语言标记（langString）指定字面量的语言类型。</li>
</ul>
<p>RDF图中知识以三元组的形式表示。一个RDF三元组被称为一个RDF语句（statement）：(subject，predicate，object)</p>
<ul>
<li>主语：是一个个体（Individual），个体是类的实例。</li>
<li>谓语：是一个属性。属性可以连接两个个体，或者连接一个个体和一个数据类型的实例。</li>
<li>宾语：可以是一个个体，也可以是一个数据类型的实例。</li>
</ul>
<p>RDF图中可以3种节点：IRI, literal, blank node。</p>
<ul>
<li>IRI (Internationalized Resource Identifier)：国际化资源标识符，URI的超集，字符集被扩展到通用字符集Unicode
<ul>
<li>URI：统一资源标识符，字符集被限制为US-ASCII
<ul>
<li>URN：统一资源名称，由命名空间标识符（NID）和命名空间特定字符串（NSS）组成</li>
<li>URL：统一资源定位符，即网址，通常指的是不包含URN的URI子集</li>
</ul></li>
</ul></li>
<li>字面量（literal）由两个或三个元素组成：
<ul>
<li>词汇形式，是Unicode字符串，</li>
<li>一个数据类型 IRI ，作为一个识别数据类型的 IRI ，决定了词汇形式如何映射到一个字面量（IBM-Talk, talkDate, “05-10-2012” ^xsd:date）</li>
</ul></li>
<li>空白节点（Blank Node）：RDF中没有全局标识的节点，前缀为“_”。</li>
</ul>
<p>RDF图：一组RDF三元组。一个RDF graph也有对应的 IRI。</p>
<p>IRI 命名空间：RDF词汇表中的 IRIs 通常从称为命名空间 IRI 的公共子字符串开始。</p>
<p>RDF是抽象的数据模型，支持不同的序列化格式，例如 RDF/XML、Turtle 和 N-Triple：</p>
<ul>
<li>XML的格式太冗长，不便于阅读，通常不会使用这种方式来处理RDF数据。</li>
<li>Turtle是使用得最多的一种RDF序列化方式。比RDF/XML紧凑，可读性比N-Triples好。</li>
<li>N-Triples用多个三元组来表示RDF数据集，是最直观的表示方法。在文件中，每一行表示一个三元组，方便机器解析和处理。开放领域知识图谱DBpedia通常是用这种格式来发布数据的</li>
</ul>
<p>RDF 图谱里的知识有可能是不完备的，这符合 Web 的开放性特点和要求。经典数据库采用封闭世界假设， RDF采用的是开放世界假设：</p>
<ul>
<li>开放世界假设：没有明确的包含的所有元组，都被假定为是未知的事实而不是假的。</li>
<li>封闭世界假设：所有没有明确包含在表中的记录都假定表示这是假的事实。</li>
</ul>
<h4 id="rdfs">RDFS</h4>
<p>RDFS（RDF Schema）：RDF的语义扩展。用RDF编写，为RDF数据提供了数据建模词汇表，提供了描述相关资源组和这些资源之间关系的机制。</p>
<p>RDFS 提供了最基本的对类和属性的描述元语</p>
<ul>
<li>rdfs:subClassOf: 用于指定类的父类</li>
<li>rdfs:subPropertyOf: 用于指定属性的父属性</li>
<li>rdfs:domain: 用于指定属性的定义域</li>
<li>rdfs:range: 用于指定属性的值域</li>
<li>rdfs:subPropertyOf：用于描述该属性的父属性</li>
<li>rdfs:label：用于描述人可读的资源名字</li>
<li>rdfs:comment：为资源提供人可读的文本描述</li>
<li>rdfs:seeAlso：声明对当前资源提供了额外信息的资源。</li>
<li>rdfs:isDefinedBy：用于描述当前资源是由哪个资源定义的</li>
<li>rdfs:Class：所有类的类</li>
<li>rdfs:Resource：所有资源的类</li>
<li>rdfs:Literal：字符串和整数等字面量的类
<ul>
<li>属性值如文本字符串是rdfs:Literal的实例。</li>
<li>rdfs:Literal是rdfs:Class的一个实例。</li>
<li>rdfs:Literal是rdfs:Resource的子类。</li>
</ul></li>
<li>rdfs:Datatype：数据类型的类。
<ul>
<li>rdfs:Datatype的所有实例对应于RDF概念规范中描述的RDF模型数据类型。</li>
<li>rdfs:Datatype是rdfs:Class的一个实例和子类。</li>
<li>rdfs:Datatype的每个实例都是rdfs:Literal的一个子类。</li>
</ul></li>
</ul>
<p>在更复杂的场景下，RDFS 的语义表达能力不够，缺少一些常用的特征 :</p>
<ul>
<li>对于局部值域的属性定义
<ul>
<li>RDFS 中通过 rdfs:range 定义了属性的值域，该值域是全局性的，无法说明该属性应用于某些具体的类时具有的特殊值域限制，如无法声明父母至少有一个孩子 。</li>
</ul></li>
<li>类、属性、个体的等价性
<ul>
<li>RDFS 中无法声明两个类或多个类、属性和个体是等价还是不等价。如，无法声明 Tim-BemsLee和T.B.Lee是同一个人。</li>
</ul></li>
<li>不相交类的定义
<ul>
<li>在 RDFS 中只能声明子类关系，但无法声明这两个类是不相交的 。如，男人和女人是不相交的类</li>
</ul></li>
<li>基数约束
<ul>
<li>对某属性值可能或必需的取值范围进行约束，如说明一个人有双亲 (包括两个人)，一门课至少有一名教师等。</li>
</ul></li>
<li>关于属性特性的描述
<ul>
<li>声明属性的某些特性，如传递性、函数性、对称性，以及声明一个属性是另一个属性的逆属性等，如大于关系的逆关系是小于关系。</li>
</ul></li>
</ul>
<h4 id="owl">OWL</h4>
<figure>
<img src="https://img-blog.csdnimg.cn/20200807211114841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY1MDgx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>OWL语言的选择：在要求简单是可采用OWL Lite，通常可采用OWL DL，对概念要求定义精确时采用OWL Full。</p>
<ul>
<li>选择 OWL Lite 还是 OWL DL 主要取决于用户需要整个语言在多大程度上给出约束的可表达性。</li>
<li>选择 OWL DL 还是 OWL Full 主要取决于用户在多大程度上需要 RDF 的元模型机制，如定义类型的类型以及为类型赋予属性。</li>
<li>当使 用 OWL Full 而不是 OWL DL 时，推理的支持可能不能工作，因为目前还没有完全支持 OWL Full 的系统实现。</li>
</ul>
<p>OWL和RDF的关系：</p>
<ul>
<li>OWL Full可以看成是RDF的扩展</li>
<li>OWL Lite和OWL DL可以看成是一个约束化的RDF的扩展</li>
<li>所有的OWL文档（Lite, DL, Full）都是一个RDF文档</li>
<li>所有的RDF文档都是一个OWL Full文档</li>
<li>只有一些RDF文档是一个合法的OWL Lite和OWL DL文档</li>
</ul>
<h4 id="owl-2">OWL 2</h4>
<p>OWL 2 ：OWL 1的扩展，增加了新的功能和特性。</p>
<p>OWL 2 本体包括：classes, properties, individuals, and data values</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2020080721151672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY1MDgx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>OWL2 QL适合概念多的情况，OWL2 EL适合实例较多的情况，如医学领域，OWL2 RL适合高效推理。</p>
<p>OWL2 QL：QL代表query language的意思，专为基于本体的查询设计。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200807211600434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY1MDgx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>OWL2 EL：是基于描述逻辑语言EL++定义的，专为概念术语描述,推理而设计：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200807211710240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY1MDgx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>OWL 2 RL：在RDFS的基础上引入属性的特殊特性 (函数性,互反性,对称性)；允许声明等价性；允许属性的局部约束。OWL 2 RL与描述逻辑没有直接关系。专为高效推理设计（推理针对的是实例数据）。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200807211728526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY1MDgx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h3 id="本体">本体</h3>
<p>本体：共享概念模型的明确的形式化规范说明。</p>
<p>本体形式化表示为，O={C，H， P，A，I}：</p>
<ul>
<li>C，概念集合，如事物性概念和事件类概念。
<ul>
<li>例如：二甲双胍</li>
</ul></li>
<li>H，概念的上下位关系集合，也称为Taxonomy 知识。
<ul>
<li>例如：“糖尿病”与“2型糖尿病”</li>
</ul></li>
<li>P，属性集合，描述概念所具有的特征。
<ul>
<li>例如：病人具有年龄、性别、诊断等属性</li>
</ul></li>
<li>A，规则集合，描述领域规则。
<ul>
<li>例如：用Swrl描述的一条规则：age(?a), ‘cardiovascular disease’(?z1), patient(?x), ‘patient profile’(?y), has_demographic(?y, ?a), has_patient_profile(?x, ?y), has_complication(?y, ?z1), has_quantitatie_Value(?a, ?v), greaterThanOrEqual(?v, 45) à ‘symptomatic patient’(?x)</li>
</ul></li>
<li>I ，实例集合，用来描述实例-属性-值。</li>
</ul>
<p>本体的分类：</p>
<ul>
<li><p>按详细程度（详细程度指描述、刻画建模对象的程度）分</p>
<ul>
<li>参考（Reference）本体，详细程度高</li>
<li>共享（Share）本体，详细程度低</li>
</ul></li>
<li><p>按领域依赖度分</p>
<ul>
<li><p>顶层（Top level）本体：描述最普遍的概念及概念间的关系，表达常识性知识，与具体应用无关。如：空间、时间、事件、行为等</p></li>
<li><p>领域（Domain）本体：描述特定领域的概念及概念间关系。如：医学、药学、商业等</p></li>
<li><p>任务（Task）本体：描述特定任务或行为这的概念及概念间关系。如：治疗、医院管理、随访等</p></li>
<li><p>应用（Application）本体：描述依赖于特定领域和任务的概念及概念间关系。</p>
<table>
<thead>
<tr class="header">
<th>本体类型</th>
<th>典型代表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>顶层本体</td>
<td>BFO、GFO、SUMO等</td>
</tr>
<tr class="even">
<td>领域本体</td>
<td>DO、GO、OGMS、HPO等</td>
</tr>
<tr class="odd">
<td>应用本体</td>
<td>IDO、CIDO、KTAO、DMTO等</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>
<p>本体构建规则：</p>
<ul>
<li>明确性和客观性：本体应该用自然语言对所定义的术语给出明确的、客观的语义定义。</li>
<li>完全性：定义是完整的，完全能表达所描述术语的含义。</li>
<li>一致性：由术语得出的推论与术语本身的含义是相容的，不会产生矛盾。</li>
<li>最大单调可扩展性：向本体中添加通用或专用的术语时，不需要修改已有的内容。</li>
<li>最小承诺：对待建模对象给出尽可能少的约束。</li>
</ul>
<p><strong>本体的构建步骤：</strong></p>
<ol type="1">
<li><strong>确定本体的领域和范围</strong></li>
<li><strong>考虑重用现有的本体</strong></li>
<li><strong>列举本体论中的重要术语</strong></li>
<li><strong>定义类和类层次结构</strong></li>
<li><strong>定义类的属性——槽</strong></li>
<li><strong>定义槽的面（槽候选值、槽值类型、槽的域）</strong></li>
<li><strong>创建实例（选择一个类并创建类的个体实例，填入槽值）</strong></li>
</ol>
<p><strong>从文本中构建领域本体的步骤：</strong></p>
<ol type="1">
<li><strong>预处理 (preprocessing)：对输入的文本进行先期处理（如断句、分词、词性标注、短语识别等），使之符合后续任务对输入的格式要求。</strong></li>
<li><strong>术语抽取（term extraction）：从输入文本中提取那些和目标领域高度相关的领域术语。</strong></li>
<li><strong>概念抽取（concept extraction）：从输入文本中提取那些和目标领域高度相关的概念。</strong></li>
<li><strong>层次关系抽取（hierarchical relation extraction）：抽取本体概念之间的层次关系。</strong></li>
<li><strong>非层次关系抽取（non-hierarchical relation extraction）：抽取本体概念之间的层次关系以外的其它类型关系。</strong></li>
<li><strong>形成本体（form ontology）模块：将前面任务中抽取出来的术语、概念以及概念之间的各种关系进行整合，形成最终的目标本体。</strong></li>
</ol>
<ul>
<li>统计主导的本体构建方法：词汇单元（单个词、词组、短语、词串等）间的共现信息可以为识别它们之间的关系以及描述对应词汇的重要程度提供重要的指示信息，因而可直接应用在本体构建过程中的概念抽取及关系挖掘中。
<ul>
<li>常用的统计方法：聚类、词频统计、词共现分析、潜在语义分析、术语搭配、关系规则挖掘、浅层自然语言处理等。</li>
</ul></li>
<li>语言学方法主导的本体构建方法：在依据给定文本构建本体的过程中，本体概念以及概念之间的关系隐式地存在于输入文本中，这类知识只有通过全面而深入的文本分析技术才可以获得。
<ul>
<li>自然语言处理技术：词性标注、句法分析、依存分析、语义角色标注等。</li>
<li>一些语言相关的资源被广泛应用：语义词典、语义模板、词汇–句法模板等。</li>
</ul></li>
</ul>
<p>从文本中构建领域本体的问题与挑战：</p>
<ul>
<li>多数方法的移植性较差，无法被应用在构建大规模、实用化的本体。</li>
<li>本体更新：对于领域内出现的新概念需要能快速有效地识别，并为之分配合适的关系及属性。由于当前许多本体概念识别方法都依赖于该概念在数据中出现的频率信息，而把新概念和老概念放在统一的数据源中进行重新学习，往往会得到偏倚（biased）结果。</li>
<li>关系消歧：如果关系获取由核心动词决定，由于自然文本中一个核心动词往往具有多个语义，会造成由之确定的关系在实际应用中出现语义不确定性。</li>
<li>概念属性的自动获取以及概念消歧：目前大多数方法得到的本体是一种扁平化的结构。概念通常以单个词、词组或一个相近术语集合的形式给出，无法深入地揭示概念在一个特定领域中所具有的属性。本体概念的消歧问题将直接影响随后的关系抽取任务。</li>
</ul>
<p>生物医学本体：</p>
<ul>
<li>BioPortal</li>
<li>Gene Ontology</li>
<li>SNOMED CT：临床医学系统术语（The Systematized Nomenclature of Medicine - Clinical Terms）</li>
<li>UMLS：（Unified Medical Language System）</li>
<li>HPO：（Human Phenotype Ontology）</li>
<li>OBO：（Open Biomedical Ontologies）</li>
</ul>
<p>本体应用：</p>
<ul>
<li>KPMP：（Kidney Precision Medicine Project）基于 KTAO（Kidney Tissue Atlas Ontology）</li>
<li>Ontology based CDSS</li>
</ul>
<h2 id="知识库">知识库</h2>
<p>知识库：人类知识组织成结构化的知识系统。主要研究目标是从无（半）结构的互联网信息中获取有结构知识，自动融合构建知识库、服务知识推理等相关应用。以网络的形式组织知识库中的知识获得广泛认可。</p>
<p>知识库构建的难题：</p>
<ul>
<li>计算效率问题：每个实体用不同的节点表示。当利用知识库计算实体间的语义或推理关系时，往往需要人们设计专门的图算法来实现，可移植性差。基于图的算法计算复杂度高、可扩展性差，当知识库达到一定规模时，很难较好地满足实时计算的需求。</li>
<li>数据稀疏问题：与其他类型的大规模数据类似，大规模知识库也遵守长尾分布，在长尾部分的实体和关系上，面临严重的数据稀疏问题。例如，对于长尾部分的罕见实体，由于只有极少的知识或路径涉及它们，对这些实体的语义或推理关系的计算往往准确率极低。</li>
</ul>
<p>知识库的符号表示：G = (E, R, S)</p>
<ul>
<li>E是知识库中的实体集合。</li>
<li>R是知识库中的关系集合。</li>
<li>S 属于 E × R × E，代表知识库中的三元组集合，一般表示为 (h, r, t)，h和t表示头实体和尾实体，r表示h和t之间的关系。</li>
</ul>
<p>早期的知识库项目：</p>
<ul>
<li><p>Cyc知识库主要由术语（Term）和断言（Assertion）组成 。术语包含概念、 关系和实体的定义。断言用来建立术语之间的关系，既包括事实（Fact） 描述，也包含规则（Rule）描述。主要特点：基于形式化的知识表示方法来刻画知识。优点：可以支持复杂的推理。缺点：过于形式化导致知识库的扩展性和应用的灵活性不够。</p></li>
<li><p>WordNet最著名的英文词典知识库，主要用于词义消歧。主要定义了名词、动词、形容词和副词之间的语义关系。名词之间的上下位关系（如：“猫科动物”是“猫”的上位词）动词之间的蕴含关系（如：“打鼾”蕴含着“睡眠”）等。</p></li>
<li><p>ConceptNet多语言常识知识库。以三元组形式的关系型知识构成。构建方法：互联网众包、专家创建和游戏。与Cyc相比，ConceptNet采用了非形式化、更加接近自然语言的描述，而不是像Cyc那样采用形式化的谓词逻辑。与链接数据和谷歌知识图谱相比，ConceptNet比较侧重于词与词之间的关系。从这个角度看，ConceptNet更加接近于WordNet，但是又比WordNet包含的关系类型多。</p></li>
</ul>
<h2 id="知识图谱">知识图谱</h2>
<p>互联网时代的知识库——知识图谱：</p>
<ul>
<li><p>Wikidata一个免费开放、多语言、任何人或机器都可以编辑修改的大规模链接知识库。继承了Wikipedia的众包协作的机制，但与Wikipedia不同，WikiData支持的是以三元组为基础的知识条目（Items）的自由编辑。一个三元组代表一个关于该条目的陈述（Statements）。例如：给“地球”的条目增加“&lt;地球，地表面积是，五亿平方公里&gt;”的三元组陈述。</p></li>
<li><p>DBpedia是早期的语义网项目，意指数据库版本的Wikipedia，是从Wikipedia抽取出来的链接数据集。采用了较为严格的RDF语义数据模型本体，包含人、地点、音乐、电影、组织机构、物种、疾病等类定义。与Freebase，Open CYC、Bio2RDF等多个数据集建立了数据链接。</p></li>
<li><p>Schema.org支持各个网站采用语义标签（Semantic Markup）的方式将语义化的链接数据嵌入到网页中。搜索引擎自动搜集和归集这些，快速的从网页中抽取语义化的数据。提供了一个词汇本体用于描述这些语义标签。词汇本体已经包含600多个类和900多个关系，覆盖范围包括：个人、组织机构、地点、时间、医疗、商品等。本质是采用互联网众包的方式生成和收集高质量的知识图谱数据。</p></li>
<li><p>BabelNet类似于WordNet的多语言词典知识库。目标是解决WordNet在非英语语种中数据缺乏的问题。BabelNet采用将WordNet词典与Wikipedia百科集成的方法，首先建立WordNet中的词与Wikipedia的页面标题的映射，然后利用Wikipedia中的多语言链接，再辅以机器翻译技术，来给WordNet增加多种语言的词汇。BabelNet 4.0 包含了284种语言，1600万同义词组，36.4万词语关系和3.8亿从Wikipedia中抽取的链接关系，总计超过19亿RDF三元组。BabelNet集成WordNet在词语关系上的优势和Wikipedia在多语言语料方面的优势，构建成功了目前最大规模的多语言词典知识库。</p></li>
<li><p>NELL（Never-Ending Language Learner）主要采用互联网挖掘的方法从Web自动抽取三元组知识。NELL的基本理念：给定一个初始的本体（少量类和关系的定义）和少量样本，让机器能够通过自学习的方式不断的从Web学习和抽取新的知识。</p></li>
<li><p>LOD（LOD-Linked Open）实现Tim Berners-Lee在2006年发表的有关链接数据（Linked Data）作为语义网的一种实现的设想。LOD遵循了Tim提出的进行数据链接的四个规则：（1）使用URI标识万物（2）使用HTTP URI，以便用户可以（像访问网页一样）查看事物的描述（3）使用RDF和SPARQL标准（4）为事物添加与其它事物的URI链接，建立数据关联。</p></li>
</ul>
<p>知识图谱：事实的结构化表示，由实体、关系和语义描述组成。（本体是知识图谱<strong>核心</strong>和<strong>知识表示基础</strong>）</p>
<h2 id="其它">其它</h2>
<p>实体链接：将文本中的实体指称(Mention) 链向其在给定知识库中目标实体的过程。</p>
<ol type="1">
<li>实体指称识别</li>
<li>候选实体生成</li>
<li>候选实体消歧</li>
</ol>
<p>演绎推理：在给定的一个或多个前提的情况下，推断出一个必然成立的结论的过程。</p>
<p>归纳推理：基于已有的部分观察得出一般结论的过程。</p>
<ul>
<li>溯因推理：给定一个或多个已有观察事实 O (Observation)，并根据已有的知识 T(Theory) 推断出对已有观察最简单且最有可能的解释 E 的过程。</li>
</ul>
<p>知识融合：建立异构本体或异构实例之间的联系，使异构的知识图谱能相互沟通，实现它们之间的互操作，是解决知识图谱异构问题的有效途径 。</p>
<p>问答系统应具备的四大要素：</p>
<ol type="1">
<li>问题，问答系统的输入，问句、选择题、多选题、列举答案题和填空题等形式；</li>
<li>答案，问答系统的输出，文本表示的答案，一组答案、候选答案的选择、多媒体信息；</li>
<li>智能体，问答系统的执行者，理解问题的语义，使用知识库解答问题，生成人可读的答案；</li>
<li>知识库，存储了问答系统的知识，其形态可以是文本、数据库、知识图谱或者是逻辑规则、机器学习模型。</li>
</ol>
<p>本体映射：寻找本体间的映射规则。</p>

        </div>

    </div>

    

    

    

    
  <div class="article-copyright hairline">
    <p>
      本作品采用  <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议 (CC BY-NC-ND 4.0)</a> 进行许可。
    </p>
  </div>
  

    

    
<nav class="article-nav">
  
    <a href="/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          数据建模
        
      </div>
    </a>
  
  
    <a href="/Neo4j%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">Neo4j快速入门</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=知识表示 - NijiBlog&url=https%3A%2F%2Fkinniji.github.io%2F%25E7%259F%25A5%25E8%25AF%2586%25E8%25A1%25A8%25E7%25A4%25BA%2F">
            <ion-icon name="logo-twitter"></ion-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=知识表示 - NijiBlog&u=https%3A%2F%2Fkinniji.github.io%2F%25E7%259F%25A5%25E8%25AF%2586%25E8%25A1%25A8%25E7%25A4%25BA%2F">
            <ion-icon name="logo-facebook"></ion-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=知识表示 - NijiBlog&url=https://kinniji.github.io/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>
















</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%95%E9%A2%98/">试题</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI-NLP/" rel="tag">AI - NLP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KR/" rel="tag">KR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BB%E5%AD%A6/" rel="tag">医学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" rel="tag">统计学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">计算机 - 数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%95%B0%E6%8D%AE%E5%BA%93-Neo4j/" rel="tag">计算机 - 数据库 - Neo4j</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%BD%91%E7%BB%9C/" rel="tag">计算机 - 网络</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            NijiBlog &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>

<script type="module" src="https://unpkg.com/ionicons@6.0.2/dist/ionicons/ionicons.esm.js"></script>






<script src="/dist/build.js?1654266144177.js"></script>


<script src="/dist/custom.js?1654266144177.js"></script>













</body>

</html>