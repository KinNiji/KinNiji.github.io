<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>NijiBlog</title>

    <meta name="description" content="NijiBlog">
    <meta name="keywords" content="">

    



    <meta property="og:type" content="website"/>
    <meta property="og:title" content=""/>
    <meta property="og:description" content=""/>
    <meta property="og:locale" content="cn" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://kinniji.github.io/index.html" />
    <meta property="og:site_name" content="Niji" />
    <meta property="article:publisher" content="" />
    <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "",
            "description": "",
            "publisher": {
                "@type": "Organization",
                "name": "Niji"
            },
        }
    </script>


    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1654266144177.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1654266144177.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>NijiBlog</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="">
        <ion-icon name=""></ion-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-数据结构"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="绪论">0. 绪论</h1>
<p>O(1) &lt; O(<span class="math inline">\(log_2n\)</span>) &lt; O(n) &lt; O(<span class="math inline">\(nlog_2n\)</span>) &lt; O(<span class="math inline">\(n^2\)</span>) &lt; O(<span class="math inline">\(n^3\)</span>) &lt; O(<span class="math inline">\(2^n\)</span>) &lt; O(n!) &lt; O(<span class="math inline">\(n^n\)</span>)</p>
<p>常数 &lt; 对数函数 &lt; 幂函数 &lt; 指数函数 &lt; 阶乘</p>
<p>比较时求极限洛必达</p>
<h1 id="线性表">1. 线性表</h1>
<p>线性表：由n个数据元素组成的有限序列，所有元素具有相同的数据类型。</p>
<h2 id="顺序表">***顺序表</h2>
<h3 id="存储结构">存储结构</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序表</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> SqList&#123;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    ElemType *elem;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>&#125;SqList;</span></code></pre></div>
<h3 id="初始化">初始化</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Status Init_SqList(SqList *L)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序表的初始化</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    L-&gt;elem = (ElemType *) malloc(MAX_SIZE * <span class="kw">sizeof</span>(ElemType));</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (!L-&gt;elem)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        L-&gt;length = <span class="dv">0</span>;</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OK;</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="插入">插入</h3>
<p>复杂度O(n)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>Status Insert_SqList(SqList *L, <span class="dt">int</span> i, ElemType e)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 在顺序表索引为i处插入元素</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 索引错误</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i &lt; <span class="dv">0</span> || i &gt; L-&gt;length-<span class="dv">1</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 溢出错误</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L-&gt;length &gt;= MAX_SIZE)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OVERFLOW;</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i-1后的所有元素后移</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> j = L-&gt;length-<span class="dv">1</span>; j &gt;= i-<span class="dv">1</span>; --j)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        L-&gt;elem[j+<span class="dv">1</span>] = L-&gt;elem[j];</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 在i-1插入新元素</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    L-&gt;elem[i-<span class="dv">1</span>] = e;</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 长度加1</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    L-&gt;length++;</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="删除">删除</h3>
<p>复杂度O(n)</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>ElemType Delete_SqList(SqList *L, <span class="dt">int</span> i)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 删除顺序表中索引为i的元素</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: ElemType 被删除元素的值</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 空表错误</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L-&gt;length == <span class="dv">0</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 索引错误</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i &lt; <span class="dv">0</span> || i &gt; L-&gt;length-<span class="dv">1</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 保存被删除元素的值</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    ElemType x = L-&gt;elem[i-<span class="dv">1</span>];</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i后的所有元素前移</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> j = i; j &lt;= L-&gt;length; j++)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        L-&gt;elem[j-<span class="dv">1</span>] = L-&gt;elem[j];</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 长度减1</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    L-&gt;length--;</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 返回被删除元素的值</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x;</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="查找">查找</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Locate_Elem(SqList *L, ElemType e)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 定位顺序表中第一个指定值的元素</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: int 元素索引（未找到返回-1）</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; L-&gt;length; i++)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (L-&gt;elem[i] == e)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> i;</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="单链表">***单链表</h2>
<h3 id="存储结构-1">存储结构</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 单链表</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> LNode&#123;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 数据域</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指针域</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> LNode *next;</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>&#125;LNode, *LinkList;</span></code></pre></div>
<h3 id="初始化-1">初始化</h3>
<p>头插法</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>LinkList HeadInsert_LinkList(<span class="dt">void</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 头插法创建单链表</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> null:</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: LNode 链表的头结点head</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data;</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    LNode *head, *p;</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 创建头结点head</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    head = (LinkList) malloc(<span class="kw">sizeof</span>(LNode));</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    head-&gt;next = NULL;</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 从data读入数据，以32767作为结束标志</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    scanf(<span class="st">&quot;%d&quot;</span>, &amp;data);</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(data != <span class="dv">32767</span>)&#123;</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 创建新结点p并赋值</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        p = (LinkList) malloc(<span class="kw">sizeof</span>(LNode));</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        p-&gt;data = data;</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 钩链</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = head-&gt;next;</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        head-&gt;next = p;</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 返回头结点head</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> head;</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>尾插法</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>LinkList TailInsert_LinkList(<span class="dt">void</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 尾插法创建单链表（区别在于使用了一个额外的指针q代替head不断向后）</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> null:</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: LNode 链表的头结点head</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data;</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    LNode *head, *p, *q;</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 创建头结点head，结点q</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    head = q = (LinkList) malloc(<span class="kw">sizeof</span>(LNode));</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    q-&gt;next = NULL;</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 从data读入数据，以32767作为结束标志</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    scanf(<span class="st">&quot;%d&quot;</span>, &amp;data);</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span>(data != <span class="dv">32767</span>)&#123;</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 创建新结点q并赋值</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        p = (LinkList) malloc(<span class="kw">sizeof</span>(LNode));</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        p-&gt;data = data;</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 钩链</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = q-&gt;next;</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        q-&gt;next = p;</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        q = p;</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 返回头结点head</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> head;</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="插入-1">插入</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Status Insert_LinkList(LinkList L, <span class="dt">int</span> i, ElemType e)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 创建值为e的结点并插入到单链表的第i个</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 值</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    LNode *p = L-&gt;next, *q;</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j;</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 跳过i-1个结点，单链表下一节点为空时跳出</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = <span class="dv">0</span>; p != NULL &amp;&amp; j &lt; i - <span class="dv">1</span>; j++)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        p = p-&gt;next;</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j != i - <span class="dv">1</span>)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        q = (LNode *) malloc(<span class="kw">sizeof</span>(LNode));</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        q-&gt;data = e;</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        q-&gt;next = p-&gt;next;</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = q;</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OK;</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="删除-1">删除</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Status Delete_LinkList(LinkList L, <span class="dt">int</span> i)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 删除单链表中第i个结点</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    LNode *p = L, *q = L-&gt;next;</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 跳过i-1个结点，单链表下一节点为空时跳出</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j;</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = <span class="dv">0</span>; q != NULL &amp;&amp; j &lt; i-<span class="dv">1</span>; j++)&#123;</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        p = q;</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        q = q-&gt;next;</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 索引错误或单链表长度为0</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j != i-<span class="dv">1</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = q-&gt;next;</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        free(q);</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OK;</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="查找-1">查找</h3>
<p>按序号查找</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>LNode *Get_Node(LinkList L, <span class="dt">int</span> i)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 取单链表中第i个结点</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: LNode 结点指针（未找到为NULL）</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    LNode *p = L-&gt;next;</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 跳过i个结点，单链表下一节点为空时跳出</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j;</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = <span class="dv">0</span>; p != NULL &amp;&amp; j &lt; i; j++)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        p = p-&gt;next;</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 索引错误或单链表长度为0</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j != i)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> NULL;</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p;</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>按值查找</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>LNode *Locate_Node(LNode *L, ElemType key)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 查找链表中值为key的第一个节点</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 关键值</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: LNode 结点指针（未找到为NULL）</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    LNode *p = L-&gt;next;</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL &amp;&amp; p-&gt;data != key)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        p = p-&gt;next;</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 没有符合条件的结点</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (p-&gt;data != key)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> NULL;</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p;</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="循环链表">***循环链表</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 判断是否为空</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>head-&gt;next == head</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 判断是否为链尾</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>p-&gt;next == head</span></code></pre></div>
<h2 id="双向链表">***双向链表</h2>
<h3 id="存储结构-2">存储结构</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 双向链表</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> DNode&#123;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 数据域</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指针域</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> DNode *prior, *next;</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>&#125;DNode, *DLinkList;</span></code></pre></div>
<h3 id="插入-2">插入</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>Status Insert_DLinkList(DLinkList L, <span class="dt">int</span> i, ElemType e)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 创建值为e的结点并插入到双向链表的第i个</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 值</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    DNode *p = L-&gt;next, *q;</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j;</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 跳过i-1个结点，单链表下一节点为空时跳出</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = <span class="dv">0</span>; p != NULL &amp;&amp; j &lt; i - <span class="dv">1</span>; j++)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        p = p-&gt;next;</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j != i - <span class="dv">1</span>)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        q = (DNode *) malloc(<span class="kw">sizeof</span>(DNode));</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        q-&gt;data = e;</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        q-&gt;next = p-&gt;next;</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 相对于单链表的额外步骤1</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        p-&gt;next-&gt;prior = q;</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = q;</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 相对于单链表的额外步骤2</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>        q-&gt;prior = p;</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OK;</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="删除-2">删除</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>Status Delete_DLinkList(DLinkList L, <span class="dt">int</span> i)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 删除双向链表中第i个结点</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> L: 变量指针</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 索引</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    DNode *p = L, *q = L-&gt;next;</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 跳过i-1个结点，单链表下一节点为空时跳出</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> j;</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = <span class="dv">0</span>; q != NULL &amp;&amp; j &lt; i-<span class="dv">1</span>; j++)&#123;</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        p = q;</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        q = q-&gt;next;</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 索引错误或单链表长度为0</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j != i-<span class="dv">1</span>)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        p-&gt;next = q-&gt;next;</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 相对于单链表的额外步骤</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>        q-&gt;next-&gt;prior = p-&gt;prior;</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>        free(q);</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OK;</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="稀疏多项式">*稀疏多项式</h2>
<h3 id="存储结构-3">存储结构</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序表一元多项式</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> Ploy&#123;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> coef;</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> expn;</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>&#125;Ploy;</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> PloySqList&#123;</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    Ploy *ploy;</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length;</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>&#125;PloySqList;</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链表一元多项式</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> PloyLNode&#123;</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> coef;</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> expn;</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> PloyLNode *next;</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>&#125;PloyLNode, *PloyLinkList;</span></code></pre></div>
<h3 id="运算">运算</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>PloyLinkList Add_PloyLinkList(PloyLinkList La, PloyLinkList Lb)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 两个有序多项式链表相加，生成一个新的结果有序多项式链表，且原来两个链表不变</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> La: 有序多项式链表a</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Lb: 有序多项式链表b</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: PloyLinkList</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    PloyLinkList Lc = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    PloyLNode *pa = La-&gt;next, *pb = Lb-&gt;next, *pc = Lc, *p;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> x;</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (pa != NULL &amp;&amp; pb != NULL)&#123;</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (pa-&gt;expn &lt; pb-&gt;expn)&#123;</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>            p = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>            p-&gt;coef = pa-&gt;coef;</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>            p-&gt;expn = pa-&gt;expn;</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>            p-&gt;next = NULL;</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>            pc-&gt;next = p;</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>            pc = p;</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>            pa = pa-&gt;next;</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> <span class="cf">if</span> (pa-&gt;expn &gt; pb-&gt;expn)&#123;</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>            p = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>            p-&gt;coef = pb-&gt;coef;</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>            p-&gt;expn = pb-&gt;expn;</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>            p-&gt;next = NULL;</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>            pc-&gt;next = p;</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>            pc = p;</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>            pb = pb-&gt;next;</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> &#123;</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>            x = pa-&gt;coef + pb-&gt;coef;</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (x &gt;= <span class="fl">1.0e-6</span> &amp;&amp; x &lt;= -<span class="fl">1.0e-6</span>)&#123;</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>                p = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>                p-&gt;coef = x;</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>                p-&gt;expn = pb-&gt;expn;</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>                p-&gt;next = NULL;</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>                pc-&gt;next = p;</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>                pc = p;</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>            pa = pa-&gt;next;</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>            pb = pb-&gt;next;</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (pa != NULL) &#123;</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (pa != NULL) &#123;</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>            p = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>            p-&gt;coef = pa-&gt;coef;</span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>            p-&gt;expn = pa-&gt;expn;</span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>            p-&gt;next = NULL;</span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>            pc-&gt;next = p;</span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>            pc = p;</span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>            pa = pa-&gt;next;</span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>    &#125; <span class="cf">else</span> &#123;</span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (pb != NULL) &#123;</span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a>            p = (PloyLNode *) malloc(<span class="kw">sizeof</span>(PloyLNode));</span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a>            p-&gt;coef = pb-&gt;coef;</span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a>            p-&gt;expn = pb-&gt;expn;</span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a>            p-&gt;next = NULL;</span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a>            pc-&gt;next = p;</span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a>            pc = p;</span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a>            pb = pb-&gt;next;</span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb18-64"><a href="#cb18-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Lc;</span>
<span id="cb18-65"><a href="#cb18-65" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="广义表">广义表</h2>
<p>广义表中的元素可以是原子项或广义表</p>
<p>表长：广义表中所包含的元素的个数</p>
<p>表深：广义表中括号的最大层数</p>
<h3 id="存储结构-4">存储结构</h3>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 广义表</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> GLNode&#123;</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 标志域，1为表结点，0为原子结点</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tag;</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 表结点和原子结点的共用体</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> &#123;</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 原子节点的值域</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        ElemType value;</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 表头表尾指针</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> &#123;</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">struct</span> GLNode *hp, *tp;</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        &#125;ptr;</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    &#125;Gdata;</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>&#125;GLNode;</span></code></pre></div>
<h3 id="扩展线性链表存储结构">扩展线性链表存储结构</h3>
<p>上面的存储方法表结点太多，造成空间浪费</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 扩展线性链表存储结构</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> gLNode&#123;</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 标志域，1为表结点，0为原子结点</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tag;</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 表结点和原子结点的共用体</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> &#123;</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 原子节点的值域</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        ElemType data;</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 表节点的值域</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> gLNode *sList;</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    &#125;;</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 原子结点或表结点的下一个同层结点</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> gLNode *link;</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>&#125;gLNode;</span></code></pre></div>
<h1 id="栈">2. 栈</h1>
<h2 id="基本概念">**基本概念</h2>
<p>栈：先进后出(FILO)线性表</p>
<p>栈顶/表尾(Top)：允许进行插入、删除操作的一端</p>
<p>栈底/表头(Bottom)：固定端</p>
<p>栈空：top=bottom</p>
<p>进栈(Push)：元素插入栈顶，top++</p>
<p>出栈(Pop)：先top--，此时top指向栈顶元素，然后取出该元素</p>
<h2 id="存储结构和基本操作">**存储结构和基本操作</h2>
<h3 id="动态顺序存储">动态顺序存储</h3>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 动态顺序栈</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> Stack</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    ElemType *bottom;</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    ElemType *top;</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size;</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>&#125;Stack;</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>Stack Init_Stack()</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 动态顺序栈的初始化</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Stack</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    Stack S;</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    S.bottom = (ElemType *)malloc (MAX_SIZE * <span class="kw">sizeof</span>(ElemType));</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    S.top = S.bottom;</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    S.size = MAX_SIZE;</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S;</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>Status Push_Stack(Stack S, ElemType e)</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 动态顺序栈的压栈</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 动态顺序栈</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (S.top - S.bottom &gt;= S.size - <span class="dv">1</span>)&#123;</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>        S.bottom = (ElemType *)realloc (S.bottom, (INCREASEMENT + S.size) * <span class="kw">sizeof</span>(ElemType));</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (!S.bottom)</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> ERROR;</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>        S.top = S.bottom + S.size;</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>        S.size += INCREASEMENT;</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>    *S.top = e;</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>    S.top++;</span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>Status Pop_Stack(Stack S, ElemType *e)</span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 动态顺序栈的出栈</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 动态顺序栈</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (S.top == S.bottom)</span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>    S.top--;</span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>    e = S.top;</span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="静态顺序存储">静态顺序存储</h3>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 静态顺序栈</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> SqStack&#123;</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    ElemType stackArray[MAX_SIZE];</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top;</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>&#125;SqStack;</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>SqStack Init_SqStack()</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 静态顺序栈的初始化</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: SqStack</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    SqStack S;</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    S.top = <span class="dv">0</span>;</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> S;</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>Status Push_SqStack(SqStack S, ElemType e)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 静态顺序栈的压栈</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 静态顺序栈</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span>&#123;</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (S.top == MAX_SIZE - <span class="dv">1</span>)</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OVERFLOW;</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>    S.stackArray[S.top++] = e;</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>Status Pop_SqStack(SqStack S, ElemType *e)</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 静态顺序栈的出栈</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 静态顺序栈</span></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (S.top == <span class="dv">0</span>)</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>    *e = S.stackArray[--S.top];</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="链式存储">链式存储</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式栈</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> StackLNode&#123;</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> StackLNode *next;</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>&#125;StackLNode, *LinkStack;</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>LinkStack Init_LinkStack()</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式栈的初始化</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 链式栈</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    StackLNode *top;</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>    top = (StackLNode *)malloc (<span class="kw">sizeof</span>(StackLNode));</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    top-&gt;next = NULL;</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> top;</span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>Status Push_LinkStack(StackLNode *top, ElemType e)</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式栈的压栈</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 链式栈</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>    StackLNode *p;</span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>    p = (StackLNode *)malloc (<span class="kw">sizeof</span>(StackLNode));</span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>    p-&gt;data = e;</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 头插法，返回头结点指针</span></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    p-&gt;next = top-&gt;next;</span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>    top-&gt;next = p;</span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>Status Pop_LinkStack(StackLNode *top, ElemType *e)</span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式栈的出栈</span></span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> S: 链式栈</span></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 元素</span></span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a>    StackLNode *p;</span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (top-&gt;next == NULL)</span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>    p = top-&gt;next;</span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a>    *e = p-&gt;data;</span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a>    top-&gt;next = p-&gt;next;</span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a>    free(p);</span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb23-56"><a href="#cb23-56" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h1 id="队列">3. 队列</h1>
<h2 id="基本概念-1">基本概念</h2>
<p>队列：先进先出(FIFO)线性表</p>
<p>队首(Front)：允许进行删除的一端</p>
<p>队尾(Rear)：允许进行插入的一端</p>
<p>队列空：front=rear</p>
<p>入队：元素插入队尾，rear++</p>
<p>出队：取出front所指向的元素，front++</p>
<h2 id="存储结构和基本操作-1">**存储结构和基本操作</h2>
<h3 id="顺序存储循环队列">顺序存储（循环队列）</h3>
<p>传统队列front和rear不断向前会造成假溢出现象，故需要通过对front和rear进行模运算（+1取模后若为0则取0）实现循环队列</p>
<p>对空和队满时，front均等于rear，因此入队前判断队满改为(rear + 1) % MAX_SIZE == fornt，如此一来rear所指单元始终为空（牺牲了一个存储单元）</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序储存队列（循环队列）</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> SqQueue&#123;</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    ElemType queueArray[MAX_SIZE];</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> front, rear;</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>&#125;SqQueue;</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>SqQueue *Init_CircularQueue()</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 循环队列的初始化</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: SqQueue</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    SqQueue *Q = (SqQueue *) malloc(<span class="kw">sizeof</span>(SqQueue));</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    Q-&gt;front = Q-&gt;rear = <span class="dv">0</span>;</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Q;</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>Status Insert_CircularQueue(SqQueue *Q, ElemType e)</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 循环队列的插入</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Q: 循环队列</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 插入元素</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ((Q-&gt;rear + <span class="dv">1</span>) % MAX_SIZE == Q-&gt;front)</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> OVERFLOW;</span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>    Q-&gt;queueArray[Q-&gt;rear] = e;</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>    Q-&gt;rear = (Q-&gt;rear + <span class="dv">1</span>) % MAX_SIZE;</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>Status Delete_CircularQueue(SqQueue *Q, ElemType *e)</span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 循环队列的删除</span></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Q: 循环队列</span></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 删除元素</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (Q-&gt;front == Q-&gt;rear)</span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a>    *e = Q-&gt;queueArray[Q-&gt;front];</span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a>    Q-&gt;front = (Q-&gt;front + <span class="dv">1</span>) % MAX_SIZE;</span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a>    r</span></code></pre></div>
<h3 id="链式存储-1">链式存储</h3>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式储存队列</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> QueueLNode&#123;</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> QueueLNode *next;</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>&#125;QueueLNode;</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> LinkQueue&#123;</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    QueueLNode *front, *rear;</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>&#125;LinkQueue;</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>LinkQueue *Init_LinkQueue()</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式队列的初始化</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: LinkQueue</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    LinkQueue *Q = (LinkQueue *)malloc (<span class="kw">sizeof</span>(LinkQueue));</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    QueueLNode *p = (QueueLNode *)malloc (<span class="kw">sizeof</span>(QueueLNode));</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    p-&gt;next = NULL;</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    Q-&gt;front = Q-&gt;rear = p;</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Q;</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>Status Insert_LinkQueue(LinkQueue *Q, ElemType e)</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式队列的插入</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Q: 链式队列</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 插入元素</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>    QueueLNode *p = (QueueLNode *)malloc (<span class="kw">sizeof</span>(QueueLNode));</span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>    p-&gt;data = e;</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>    p-&gt;next = NULL;</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>    Q-&gt;rear-&gt;next = p;</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>    Q-&gt;rear = p;</span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>Status Delete_LinkQueue(LinkQueue *Q, ElemType *e)</span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式队列的删除</span></span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Q: 链式队列</span></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> e: 删除元素</span></span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a>    QueueLNode *p;</span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (Q-&gt;front == Q-&gt;rear)</span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ERROR;</span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>    p = Q-&gt;front-&gt;next;</span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a>    *e = p-&gt;data;</span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>    Q-&gt;front-&gt;next = p-&gt;next;</span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 当队列只有一个结点时使队尾指针指向该结点</span></span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (p == Q-&gt;rear)</span>
<span id="cb25-58"><a href="#cb25-58" aria-hidden="true" tabindex="-1"></a>        Q-&gt;rear = Q-&gt;front;</span>
<span id="cb25-59"><a href="#cb25-59" aria-hidden="true" tabindex="-1"></a>    free(p);</span>
<span id="cb25-60"><a href="#cb25-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb25-61"><a href="#cb25-61" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb25-62"><a href="#cb25-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-63"><a href="#cb25-63" aria-hidden="true" tabindex="-1"></a>Status Destory_LinkQueue(LinkQueue *Q)</span>
<span id="cb25-64"><a href="#cb25-64" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb25-65"><a href="#cb25-65" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 链式队列的释放</span></span>
<span id="cb25-66"><a href="#cb25-66" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> Q: 链式队列</span></span>
<span id="cb25-67"><a href="#cb25-67" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb25-68"><a href="#cb25-68" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb25-69"><a href="#cb25-69" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb25-70"><a href="#cb25-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (Q-&gt;front != NULL)&#123;</span>
<span id="cb25-71"><a href="#cb25-71" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 从队首开始每次释放一个结点，直到所有结点都被释放</span></span>
<span id="cb25-72"><a href="#cb25-72" aria-hidden="true" tabindex="-1"></a>        Q-&gt;rear = Q-&gt;front-&gt;next;</span>
<span id="cb25-73"><a href="#cb25-73" aria-hidden="true" tabindex="-1"></a>        free(Q-&gt;front);</span>
<span id="cb25-74"><a href="#cb25-74" aria-hidden="true" tabindex="-1"></a>        Q-&gt;front = Q-&gt;rear;</span>
<span id="cb25-75"><a href="#cb25-75" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb25-76"><a href="#cb25-76" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h1 id="矩阵">4. 矩阵</h1>
<h2 id="稀疏矩阵">*稀疏矩阵</h2>
<p>稀疏矩阵：矩阵中有大量的零元素，对于m×n矩阵，稀疏因子δ=s/(m×n)≤0.05，其中s为非零元素个数</p>
<p>稀疏矩阵的三元组存储结构：所有非零元素只储存行下标、列下标、元素值</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 三元组</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> Triple&#123;</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> row, col;</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    ElemType elem;</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>&#125;Triple;</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 三元组稀疏矩阵</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> TMatrix&#123;</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> rowNum, colNum, nonzeroNum;</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    Triple data[MAX_SIZE];</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>&#125;TMatrix;</span></code></pre></div>
<p>稀疏矩阵的转置：</p>
<p>对于有t个非零元素的m×n矩阵，复杂度O(n×t)，当t与m×n一个数量级时，复杂度O(m×n^2)，而传统矩阵的转置复杂度O(m×n)，虽然节省了储存空间，但复杂度增加，故仅在t&lt;&lt;m×n时使用稀疏矩阵</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Transpose_TripleMatrix(TMatrix A, TMatrix B)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 稀疏矩阵的转置</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> A: 稀疏矩阵A</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> B: 空矩阵B，返回转置后的矩阵</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, col;</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    B.rowNum = A.colNum;</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    B.colNum = A.rowNum;</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    B.nonzeroNum = A.nonzeroNum;</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (B.nonzeroNum != <span class="dv">0</span>)&#123;</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>        j = <span class="dv">0</span>;</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 逐列遍历矩阵的非零元素</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (col = <span class="dv">1</span>; col &lt;= A.colNum; col++)</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; A.nonzeroNum; i++)</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (A.data[i].col == col)&#123;</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>                    B.data[j].row = A.data[i].col;</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>                    B.data[j].col = A.data[i].row;</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>                    B.data[j].elem = A.data[i].elem;</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>                    j++;</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>稀疏矩阵的乘法：</p>
<p>对于有t个非零元素的m×n矩阵A和n×p矩阵B，复杂度O(<span class="math inline">\(m×p+t_A×t_B/m\)</span>)，传统矩阵的转置复杂度O(m×n×p)</p>
<h1 id="树">5. 树</h1>
<h2 id="基本概念-2">*基本概念</h2>
<p>结点：一个数据元素及其若干指向其子树的分支</p>
<p>祖先结点、子孙结点、双亲结点（父节点）、孩子结点（子节点）、兄弟结点</p>
<p>度：结点的度等于结点子树的数量，树的度等于树中结点的度的最大值</p>
<p>m叉树：任意结点的度 ≤ m，可以为空树</p>
<p>叶子结点（终端结点）：度等于0的结点</p>
<p>分支结点（非终端结点）：度大于0的结点</p>
<p>结点的深度：自顶向下累加</p>
<p>结点的高度：自底向上累加</p>
<p>结点的层次：根节点为第一层，其子节点为第二层，以此类推</p>
<p>树的深度/高度：结点的最大层数</p>
<p>有序树：次序从左到右</p>
<p>无序树：兄弟结点之间没有次序</p>
<p>路径：两结点间所经过的结点序列构成路径，路径长度等于所经过的边的数量，路径的方向为自顶向下</p>
<p>树的路径长度：从根结点到每一个结点的路径长度之和</p>
<p>森林：若干互不相交的树的集合</p>
<p><strong>性质：</strong></p>
<p>结点数 = 所有结点度数和 + 1</p>
<p>度为m的树第i层至多有<span class="math inline">\(m^{i-1}\)</span>个结点</p>
<p>高度为h的m叉树至多有<span class="math inline">\(\frac{m^h-1}{m-1}\)</span>个结点（等比数列求和）</p>
<p>高度为h度为m的树至少有h + m - 1个结点</p>
<p>具有n个结点的m叉树最小高度为<span class="math inline">\(\lceil log_m(n(m-1)+1)\rceil\)</span>（<span class="math inline">\(\frac{m^{h-1}}{m-1}&lt;n≤\frac{m^h-1}{m-1}\)</span>）</p>
<h2 id="二叉树">***二叉树</h2>
<h3 id="基本概念-3">基本概念</h3>
<p>二叉树：每个结点至多有2棵子树</p>
<p>满二叉树：深度为k的二叉树有<span class="math inline">\(2^k-1\)</span>个结点，对其进行“自上而下，自左至右”的原则进行连续编号</p>
<p>完全二叉树：每一个结点与满二叉树的一一对应。</p>
<p>二叉排序/查找树(BST)：左子树上所有结点的关键字小于根节点，右子树上所有结点的关键字大于根节点</p>
<p>平衡二叉树(AVL)：任意结点的左子树与右子树的深度之差小于等于1，简写源自作者名</p>
<h3 id="性质">性质</h3>
<p>设度为0/1/2的结点个数分别为<span class="math inline">\(n_0/n_1/n_2\)</span>，有<span class="math inline">\(n_0+n_1+n_2=n1+2n_2+1\)</span>，即<span class="math inline">\(n_0=n_2+1\)</span></p>
<p>高度为k的二叉树至多有<span class="math inline">\(2^k-1\)</span>个结点，第i层至多有<span class="math inline">\(2^{i-1}\)</span>个结点</p>
<p>对于完全二叉树，i &gt; 1时：</p>
<ul>
<li><p>i所在层次为<span class="math inline">\(\lfloor log_2i\rfloor+1\)</span></p></li>
<li><p>i的父节点为<span class="math inline">\(\lfloor\frac{i}{2}\rfloor\)</span>：</p>
<ul>
<li><p>若i为偶，父节点为<span class="math inline">\(\frac{i}{2}\)</span>，i为父节点的左孩子</p></li>
<li><p>若i为奇，父节点为<span class="math inline">\(\frac{i-1}{2}\)</span>，i为父节点的右孩子</p></li>
</ul></li>
</ul>
<p>对于完全二叉树，结点数为n时：</p>
<p>高度为<span class="math inline">\(\lceil log_2(n+1)\rceil\)</span>或<span class="math inline">\(\lfloor log_2n\rfloor+1\)</span>（<span class="math inline">\(2^{h-1}&lt;n≤2^h-1\)</span>）</p>
<h3 id="存储结构-5">存储结构</h3>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉树顺序存储结构</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> ElemType BTSq[MAX_SIZE];</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉树链式存储结构</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> BTLNode&#123;</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> BTLNode *lChild, *rChild;</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>&#125;BTLNode;</span></code></pre></div>
<h3 id="遍历算法">遍历算法</h3>
<h4 id="先序遍历dlr">先序遍历DLR</h4>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Preorder_Traverse_Recursion(BTLNode *T)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 先序遍历递归实现</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>        Visit(T-&gt;data);</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>        Preorder_Traverse_Recursion(T-&gt;lChild);</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>        Preorder_Traverse_Recursion(T-&gt;rChild);</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Preorder_Traverse(BTLNode *T)</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 先序遍历非递归实现</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>    BTLNode *stack[MAX_NODE];</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>    stack[<span class="dv">0</span>] = NULL;</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>    BTLNode *p = T, *q;</span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top = <span class="dv">0</span>;</span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">do</span> &#123;</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 访问根结点</span></span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>            Visit(p-&gt;data);</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 若右子树非空则进栈</span></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>            q = p-&gt;rChild;</span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (q != NULL)</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>                stack[++top] = q;</span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 继续访问左子树</span></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;lChild;</span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 若左子树为空，栈顶右子树出栈</span></span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p == NULL)</span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>                p = stack[top--];</span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">while</span> (p != NULL);</span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h4 id="中序遍历ldr">中序遍历LDR</h4>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Inorder_Traverse_Recursion(BTLNode *T)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 中序遍历递归实现</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        Inorder_Traverse_Recursion(T-&gt;lChild);</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>        Visit(T-&gt;data);</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        Inorder_Traverse_Recursion(T-&gt;rChild);</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Inorder_Traverse(BTLNode *T)</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 中序遍历非递归实现</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>    BTLNode *stack[MAX_NODE];</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> flag = <span class="dv">1</span>;</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>    BTLNode *p = T;</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top = <span class="dv">0</span>;</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">do</span> &#123;</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 若根结点非空则入栈，然后指向左子树，循环直至左子树为空</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>                stack[++top] = p;</span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>                p = p-&gt;lChild;</span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (top != <span class="dv">0</span>)&#123;</span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 出栈并访问</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>                p = stack[top--];</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>                Visit(p-&gt;data);</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 若右子树非空则指向右子树</span></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>                p = p-&gt;rChild;</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>            &#125; <span class="cf">else</span> &#123;</span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a>                flag = <span class="dv">0</span>;</span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">while</span> (flag);</span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h4 id="后续遍历lrd">后续遍历LRD</h4>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Postorder_Traverse_Recursion(BTLNode *T)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 后序遍历递归实现</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>        Postorder_Traverse_Recursion(T-&gt;lChild);</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>        Postorder_Traverse_Recursion(T-&gt;rChild);</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>        Visit(T-&gt;data);</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Postorder_Traverse(BTLNode *T)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 后序遍历非递归实现</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    BTLNode *stack[MAX_NODE], *p = T;</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tag[MAX_NODE], top = <span class="dv">0</span>, flag = <span class="dv">1</span>;</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">do</span> &#123;</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 若根结点非空则进栈（未被经过，tag设置为0），然后指向左子树</span></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>                stack[++top] = p;</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>                tag[top] = <span class="dv">0</span>;</span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>                p = p-&gt;lChild;</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (top == <span class="dv">0</span>)</span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>                flag = <span class="dv">0</span>;</span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> (tag[top] == <span class="dv">0</span>)&#123;</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 若栈顶结点tag=0（左子树为空），则指向右子树，并更新tag</span></span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a>                p = stack[top]-&gt;rChild;</span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>                tag[top] = <span class="dv">1</span>;</span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a>            &#125; <span class="cf">else</span> &#123;</span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 若栈顶结点tag=1（左右子树都为空，访问根节点），则栈顶结点出栈</span></span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a>                p = stack[top--];</span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a>                Visit(p-&gt;data);</span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>                p = NULL;</span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">while</span> (flag != <span class="dv">0</span>);</span>
<span id="cb31-45"><a href="#cb31-45" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb31-46"><a href="#cb31-46" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h4 id="层次遍历">层次遍历</h4>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Level_Traverse(BTLNode *T)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 层次遍历</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 二叉树</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null </span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    BTLNode *Queue[MAX_NODE], *p = T;</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> front = <span class="dv">0</span>, rear = <span class="dv">0</span>;</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 根结点入队</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>        Queue[++rear] = p;</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (front &lt; rear)&#123;</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 队尾结点出队并访问</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>            p = Queue[++front];</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>            Visit(p-&gt;data);</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 左右子节点依次入队</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;lChild != NULL)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>                Queue[++rear] = p-&gt;lChild;</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;rChild != NULL)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>                Queue[++rear] = p-&gt;rChild;</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="线索二叉树">**线索二叉树</h2>
<p>线索化：修改空指针使其指向前驱或后继，使得遍历时不需要堆栈</p>
<h3 id="存储结构-6">存储结构</h3>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉线索树</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> BTTLNode&#123;</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> BTTLNode *lChild, *rChild;</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* lTag:    0   有左孩子结点，指向其左孩子结点</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="co">     *          1   无左孩子结点，指向其前驱</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="co">     * rTag:    0   有右孩子结点，指向其右孩子结点</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="co">     *          1   无右孩子结点，指向其后继</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> lTag, rTag;</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>&#125;BTTLNode;</span></code></pre></div>
<h3 id="线索化算法">线索化算法</h3>
<p>先序</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Preorder_Threading(BTTLNode *T)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 先序线索化二叉树</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 线索二叉树</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    BTTLNode *stack[MAX_NODE], *last = NULL, *p;</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top = <span class="dv">0</span>;</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>        stack[++top] = T;</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (top &gt; <span class="dv">0</span>)&#123;</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>            p = stack[top--];</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// p结点若无左孩子，则指向其前驱</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;lChild != NULL)</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>                p-&gt;lTag = <span class="dv">0</span>;</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> &#123;</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>                p-&gt;lTag = <span class="dv">1</span>;</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>                p-&gt;lChild = last;</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 更新其前驱，若前驱无右孩子，则指向p结点</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (last != NULL)&#123;</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (last-&gt;rChild != NULL)</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rTag = <span class="dv">0</span>;</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> &#123;</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rTag = <span class="dv">1</span>;</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rChild = p;</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 将前驱更新为p结点</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>            last = p;</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 右孩子先入栈，左孩子后入栈</span></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;rChild != NULL &amp;&amp; p-&gt;rTag == <span class="dv">0</span>)</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>                stack[++top] = p-&gt;rChild;</span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;lChild != NULL &amp;&amp; p-&gt;lTag == <span class="dv">0</span>)</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>                stack[++top] = p-&gt;lChild;</span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 最后一个结点无右孩子且无后继（rTag=1且rChild=NULL）</span></span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>        last-&gt;rTag = <span class="dv">1</span>;</span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>中序</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Inorder_Threading(BTTLNode *T)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 中序线索化二叉树</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 线索二叉树</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    BTTLNode *stack[MAX_NODE], *last = NULL, *p = T;</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top = <span class="dv">0</span>;</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL || top &gt; <span class="dv">0</span>)&#123;</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (p != NULL)&#123;</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 左孩子入栈直至左孩子为空</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>            stack[++top] = p;</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;lChild;</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> &#123;</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// p结点出栈，若无左孩子，则指向其前驱</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>            p = stack[top--];</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;lChild != NULL)</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>                p-&gt;lTag = <span class="dv">0</span>;</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> &#123;</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>                p-&gt;lTag = <span class="dv">1</span>;</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>                p-&gt;lChild = last;</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 更新其前驱，若前驱无右孩子，则指向p结点</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (last != NULL)&#123;</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (last-&gt;rChild != NULL)</span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rTag = <span class="dv">0</span>;</span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> &#123;</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rTag = <span class="dv">1</span>;</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>                    last-&gt;rChild = p;</span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 将前驱更新为p结点</span></span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>            last = p;</span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 左孩子和根节点已入栈，右孩子入栈</span></span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;rChild;</span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 最后一个结点无右孩子且无后继（rTag=1且rChild=NULL）</span></span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>    last-&gt;rTag = <span class="dv">1</span>;</span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="遍历算法-1">遍历算法</h3>
<p>先序</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Preorder_Traverse_BiThreadTree(BTTLNode *T)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 遍历先序线索化二叉树</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 线索二叉树</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    BTTLNode *p = T;</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>        Visit(p-&gt;data);</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (p-&gt;lTag == <span class="dv">0</span>)</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;lChild;</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;rChild;</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>中序</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Inorder_Traverse_BiThreadTree(BTTLNode *T)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 遍历中序线索化二叉树</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> T: 线索二叉树</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    BTTLNode *p;</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>        p = T;</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (p-&gt;lTag == <span class="dv">0</span>)</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;lChild;</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>            Visit(p-&gt;data);</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (p-&gt;rTag == <span class="dv">1</span>)</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>                p = p-&gt;rChild;</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> &#123;</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>                p = p-&gt;rChild;</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> (p-&gt;lTag == <span class="dv">0</span>)</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>                    p = p-&gt;lChild;</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="树和森林">**树和森林</h2>
<h3 id="树的存储结构">树的存储结构</h3>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 双亲表示法（顺序存储结构）</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> PTNode&#123;</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> parent;</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>&#125;PTNode;</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> PTree&#123;</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    PTNode nodes[MAX_SIZE];</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> root;</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num;</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>&#125;PTree;</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 孩子链表示法</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> CTableLNode&#123;</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> childNo;</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> CTableLNode *next;</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>&#125;CTableLNode;</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> CHeadLNode&#123;</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>    CTableLNode *first;</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>&#125;CHeadNode;</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> CTree&#123;</span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>    CHeadNode nodes[MAX_SIZE];</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> root;</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num;</span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>&#125;CTree;</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 孩子兄弟表示法（二叉树表示法）</span></span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> CSLNode&#123;</span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>    ElemType data;</span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> CSLNode *firstChild, *firstSibling;</span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>&#125;CSLNode;</span></code></pre></div>
<h3 id="树森林二叉树的相互转化">树、森林、二叉树的相互转化</h3>
<p>树 &lt;-&gt; 二叉树：用孩子兄弟表示法表示树，左孩子为第一个孩子，右孩子为第一个兄弟</p>
<p>森林 -&gt; 二叉树：森林的每棵树用孩子兄弟表示法表示，表示后的所有二叉树从第二棵开始每棵接在前一棵的根结点的右结点</p>
<p>二叉树 -&gt; 森林：二叉树从右结点断开，子树以此类推，所有二叉树再转化为树</p>
<h3 id="树和森林的遍历">树和森林的遍历</h3>
<p><strong>树：</strong></p>
<p>先根遍历：与对应二叉树的先序遍历相同</p>
<p>后根遍历：与对应二叉树的后序遍历相同</p>
<p>层序遍历：一层层地遍历</p>
<p><strong>森林</strong>：</p>
<p>先序遍历：按先根遍历的方式遍历森林中的每一棵树</p>
<p>中序遍历：按后根遍历的方式遍历森林中的每一棵树</p>
<h2 id="哈夫曼树">**哈夫曼树</h2>
<p>哈夫曼树又称最优二叉树。以字符集作为叶子结点，频度作为结点的权值构造哈夫曼树。</p>
<p>哈夫曼树左分支为0，右分支为1，从根结点到每个叶子结点的路径上的0和1所组成的字符串，为该结点所对应的哈夫曼编码。哈夫曼树中没有度为1的结点，n个叶子结点的哈夫曼树共有2n-1个结点。生成的哈夫曼树的根结点下标为2n-1。</p>
<h3 id="存储结构-7">存储结构</h3>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 哈夫曼树</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> HTNode&#123;</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> weight;</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> parent, lChild, rChild;</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>&#125;HTNode;</span></code></pre></div>
<h3 id="生成哈夫曼树">生成哈夫曼树</h3>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Create_HuffmanTree(<span class="dt">unsigned</span> n, HTNode HT[], <span class="dt">const</span> <span class="dt">char</span> c[], <span class="dt">const</span> <span class="dt">unsigned</span> weight[])</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 创建哈夫曼树</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 叶子结点数</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> HT: 用于生成哈夫曼树</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> c: 字符集</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> weight: 叶子结点权重</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> m: 总结点数</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j;</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 所有结点初始化权重</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; <span class="dv">2</span> * n - <span class="dv">1</span>; i++) &#123;</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (i &lt; n)</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>            HT[i].weight = weight[i];</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>            HT[i].weight = -<span class="dv">1</span>;</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>        HT[i].parent = HT[i].lChild = HT[i].rChild = -<span class="dv">1</span>;</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = (<span class="dt">int</span>)n; i &lt; <span class="dv">2</span> * n - <span class="dv">1</span>; i++) &#123;</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 保存最小的两个权值</span></span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> w1 = <span class="dv">32767</span>, w2 = <span class="dv">32767</span>;</span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 保存最小的两个权值的下标</span></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> p1 = <span class="dv">0</span>, p2 = <span class="dv">0</span>;</span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 遍历所有未合并的结点找到权值最小的两个</span></span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; i; j++) &#123;</span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 结点j尚未合并</span></span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (HT[j].parent == -<span class="dv">1</span>) &#123;</span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (HT[j].weight &lt; w1) &#123;</span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>                    w2 = w1;</span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>                    p2 = p1;</span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a>                    w1 = HT[j].weight;</span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>                    p1 = j;</span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> <span class="cf">if</span> (HT[j].weight &lt; w2) &#123;</span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>                    w2 = HT[j].weight;</span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>                    p2 = j;</span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 权值最小的两个结点合并为结点i</span></span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a>        HT[i].lChild = p1;</span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a>        HT[i].rChild = p2;</span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a>        HT[i].weight = w1 + w2;</span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a>        HT[p1].parent = i;</span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a>        HT[p2].parent = i;</span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb40-50"><a href="#cb40-50" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="哈夫曼编码">哈夫曼编码</h3>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Huffman_Coding(<span class="dt">unsigned</span> n, HTNode HT[], <span class="dt">const</span> <span class="dt">char</span> c[])</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 输出哈夫曼树的哈夫曼编码</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 叶子结点数</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> HT: 哈夫曼树</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> string_i, p, p_parent;</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 单个字符的编码的最大长度为n-1</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span>* string = (<span class="dt">char</span>*)malloc(n * <span class="kw">sizeof</span>(<span class="dt">char</span>)), * HC[n];</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 编码的结束标志</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    string[n] = <span class="ch">&#39;\0&#39;</span>;</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 遍历所有叶子结点</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; n; i++) &#123;</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>        string_i = n;</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>        p = i;</span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>        p_parent = HT[i].parent;</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (p_parent != -<span class="dv">1</span>) &#123;</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 左孩子为0，右孩子为1</span></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (HT[p_parent].lChild == p)</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>                string[--string_i] = <span class="ch">&#39;0&#39;</span>;</span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>                string[--string_i] = <span class="ch">&#39;1&#39;</span>;</span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 当父节点的父节点不为空，则指向父节点</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>            p = p_parent;</span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>            p_parent = HT[p].parent;</span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>        HC[i] = (<span class="dt">char</span>*) malloc(<span class="kw">sizeof</span>(<span class="dt">char</span>));</span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a>        strcpy(HC[i], &amp;string[string_i]);</span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h1 id="图">6. 图</h1>
<h2 id="基本概念-4">*基本概念</h2>
<p>顶点：点集V，点数|V|</p>
<p>度：依附于顶点V的边的条数，TD(V)</p>
<p>入度、出度：以顶点V为终点、起点的边的条数，ID(V)、OD(V)</p>
<p>弧、边（顶点之间的关系）：边集E，边数|E|，有向图为弧&lt;V1, V2&gt;，无向图为边(V1, V2)</p>
<p>权：边的权重</p>
<p>图：G=(V+E)</p>
<p>有向图：&lt;V1, V2&gt;，V1为弧尾/起点、V2为弧头/终点</p>
<p>无向图：&lt;V1, V2&gt;=&lt;V2, V1&gt;，(V1, V2)</p>
<p>简单图：不存在重复边、不存在顶点到自身的边。</p>
<p>多重图：不符合简单图</p>
<p>完全图：具有n(n-1)/2条边的无向图为完全无向图，具有n(n-1)条边的有向图为完全有向图</p>
<p>稠密图、稀疏图：视边数的多少的模糊定义，|E| &lt;&gt; |V|log|V|</p>
<p>带权图（网）：每条边都带权</p>
<p>连通、路径：V1经过若干条弧/边能够到达V2，则V1, V2连通，即有路径</p>
<p>简单路径：路径中的顶点没有重复</p>
<p>回路（环）：路径的第一个顶点和最后一个顶点相同</p>
<p>简单回路：回路中除了第一个顶点和最后一个顶点没有重复</p>
<p>连通图：无向图中，任意两个顶点V1, V2间都是连通的</p>
<p>连通分量：无向图中，极大的连通子图</p>
<p>强连通图：有向图中，任意两个顶点V1, V2间，有从V1到V2和从V2到V1的路径</p>
<p>强连通分量：有向图中，极大的连通子图</p>
<p>生成树：连通图中，包含图中全部顶点的一个极小连通子图（n个顶点的生成树有n-1条边）</p>
<p>最小生成树：带权连通图中，代价最小的生成树</p>
<p>生成森林：非连通图中，所有的连通分量构成生成森林</p>
<p>有向树：只有一个顶点入度为0，其余顶点入度为1</p>
<h2 id="存储结构-8">**存储结构</h2>
<h3 id="邻接矩阵">邻接矩阵</h3>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 邻接矩阵</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 邻接矩阵数据类型</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> AdjType;</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> AdjSqGraph&#123;</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 邻接矩阵</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    AdjType adj[MAX_VEX][MAX_VEX];</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点信息顺序表</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    VexType vexList[MAX_VEX];</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点数、边数</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> vexNum, arcNum;</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>&#125;ASGraph;</span></code></pre></div>
<h3 id="邻接链表">邻接链表</h3>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 邻接链表</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 表节点</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> ArcLNode&#123;</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 邻接点在顶点结点数组的下标</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> adjVex;</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 权重</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    WeightType weight;</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指向下一个表节点</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ArcLNode *next;</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>&#125;ArcLNode;</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a><span class="co">// 顶点结点</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> VexNode&#123;</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点信息</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>    VexType data;</span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点的度（入度或出度，正邻接出度直观，逆邻接入度直观）</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> degree;</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指向第一条依附于该顶点的弧的指针</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>    ArcLNode *first;</span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>&#125;VexNode, *AdjList;</span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> AdjListGraph&#123;</span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点结点数组</span></span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>    AdjList adjList[MAX_VEX];</span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点数</span></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> vexNum;</span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>&#125;ALGraph;</span></code></pre></div>
<h3 id="边表">边表</h3>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 边表</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> EdgeLNode&#123;</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 边所依附的两个顶点</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    VexType vex1, vex2;</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 边的权重</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    WeightType weight;</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>&#125;EdgeLNode, *EdgeList;</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> EdgeListGraph&#123;</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 边表</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    EdgeList edgeList[MAX_EDGE];</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点信息顺序表</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    VexType vexList[MAX_VEX];</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顶点数、边数</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> vexNum, arcNum;</span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>&#125;ELGraph;</span></code></pre></div>
<h3 id="十字链表邻接多重表">十字链表、邻接多重表</h3>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 有向图-&gt;十字链表</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * 弧结点：  </span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="co"> *      headvex     头域（弧头顶点在图中的位置）</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="co"> *      tailvex     尾域（弧尾顶点在图中的位置）</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co"> *      hlink       指向弧头相同的下一条弧</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="co"> *      tlink       指向弧尾相同的下一条弧</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * 顶点结点：</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="co"> *      data        数据信息</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="co"> *      firstin     指向以该顶点为弧头的第一个弧结点</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="co"> *      firstout    指向以该顶点为弧尾的第一个弧结点</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 无向图-&gt;邻接多重表</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * 边结点：</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a><span class="co"> *      mark        标志域（标记该边是否被搜索过）</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a><span class="co"> *      ivex        该边依附的顶点i</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a><span class="co"> *      jvex        该边依附的顶点j</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a><span class="co"> *      ilink       指向下一条依附于顶点i的边</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a><span class="co"> *      jlink       指向下一条依附于顶点j的边</span></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a><span class="co"> *      info        边的信息</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * 顶点结点：</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a><span class="co"> *      data        数据信息</span></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a><span class="co"> *      firstedge   指向第一条依附于该顶点的边</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span></code></pre></div>
<h2 id="遍历算法-2">***遍历算法</h2>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 访问标志</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">enum</span>&#123;FALSE, TRUE&#125; BOOLEAN;</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>BOOLEAN Visited[MAX_VEX];</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> Queue&#123;</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> elem[MAX_VEX];</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> front, rear;</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>&#125;Queue;</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Visit(<span class="dt">int</span> index, <span class="dt">int</span> data)&#123;</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    printf(<span class="st">&quot;index: %d, data: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, index, data);</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="深度优先dfs">深度优先DFS</h3>
<p>递归实现</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> DFS(ALGraph *G, <span class="dt">int</span> i)&#123;</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 更新访问标志</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    Visited[i] = TRUE;</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    Visit(i, G-&gt;adjList[i].data);</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指向表结点的第一个结点</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    ArcLNode *p = G-&gt;adjList[i].first;</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (!Visited[p-&gt;adjVex])</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>            DFS(G, p-&gt;adjVex);</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        p = p-&gt;next;</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> DFS_Traverse_Graph(ALGraph *G)</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 图的深度优先遍历递归实现</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v;</span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 访问标志初始化</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (v = <span class="dv">0</span>; v &lt; G-&gt;vexNum; v++)</span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>        Visited[v] = FALSE;</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 遍历顶点结点</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (v = <span class="dv">0</span>; v &lt; G-&gt;vexNum; v++)</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (!Visited[v])</span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>            DFS(G, v);</span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="广度优先bfs">广度优先BFS</h3>
<p>依靠队列实现</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> BFS_Traverse_Graph(ALGraph *G)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 图的广度优先遍历依靠队列实现</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j;</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    ArcLNode *p;</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 建立空队列</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    Queue *Q = (Queue *) malloc(<span class="kw">sizeof</span>(Queue));</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    Q-&gt;front = Q-&gt;rear = <span class="dv">0</span>;</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 访问标志初始化</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>        Visited[i] = FALSE;</span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 遍历顶点结点</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)&#123;</span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (!Visited[i])&#123;</span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 下标入队</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>            Q-&gt;elem[++Q-&gt;rear] = i;</span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 队列是否为空</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (Q-&gt;front != Q-&gt;rear)&#123;</span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 访问下标为队首元素的顶点结点</span></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>                j = Q-&gt;elem[++Q-&gt;front];</span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>                Visited[j] = TRUE;</span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>                Visit(j, G-&gt;adjList[j].data);</span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 顶点结点的所有表结点下标入队</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>                p = G-&gt;adjList[j].first;</span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// 未被访问过的下标才能入队</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> (!Visited[p-&gt;adjVex])</span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>                        Q-&gt;elem[++Q-&gt;rear] = p-&gt;adjVex;</span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a>                    p = p-&gt;next;</span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="最小生成树算法">**最小生成树算法</h2>
<h3 id="prim算法">Prim算法</h3>
<p>从某一个顶点开始构建生成树，每次将代价最小的新定点纳入生成树，直到所有顶点入树。</p>
<p>适用于稠密图，复杂度<span class="math inline">\(O(|V|^2)\)</span></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 比较数组，用于保存未入树顶点到已入树顶点的权值最小的边</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Example:</span><span class="co"> closeEdge[j].vex = k -&gt; cost(j, k) = closeEdge[j].cost</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Initialize:</span><span class="co"> 若从顶点s开始构建最小生成树</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="co"> *      closeEdge[s].cost = 0;</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span>&#123;</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 边依附的已入树顶点</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> vex;</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 最小的边的权值</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> cost;</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>&#125;closeEdge[MAX_EDGE];</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>EdgeList MST_Prim(ASGraph *G, <span class="dt">int</span> u)</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> Prime算法构建最小生成树</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图（邻接矩阵）</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> u: 从下标为u的顶点开始构建</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: EdgeList 边表</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>    EdgeList MT = (EdgeLNode *) malloc((G-&gt;vexNum - <span class="dv">1</span>) * <span class="kw">sizeof</span>(EdgeLNode));</span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k;</span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> min;</span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 初始化比较数组</span></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)&#123;</span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>        closeEdge[i].vex = u;</span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>        closeEdge[i].cost = G-&gt;adjVec[i][u];</span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>    closeEdge[u].cost = <span class="dv">0</span>;</span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 找到生成树的n-1条边</span></span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum - <span class="dv">1</span>; i++)&#123;</span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>        min = INFINITY;</span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)</span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (closeEdge[j].cost != <span class="dv">0</span> &amp;&amp; closeEdge[j].cost &lt; min)&#123;</span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>                min = closeEdge[j].cost;</span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>                k = j;</span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>        MT[i].vex1 = closeEdge[k].vex;</span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a>        MT[i].vex2 = k;</span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a>        MT[i].weight = closeEdge[k].cost;</span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>        closeEdge[k].cost = <span class="dv">0</span>;</span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 更新比较数组</span></span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)&#123;</span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (G-&gt;adjVec[j][k] &lt; closeEdge[j].cost)&#123;</span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a>                closeEdge[j].cost = G-&gt;adjVec[j][k];</span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a>                closeEdge[j].vex = k;</span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb49-50"><a href="#cb49-50" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb49-51"><a href="#cb49-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> MT;</span>
<span id="cb49-52"><a href="#cb49-52" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="kruskal算法">Kruskal算法</h3>
<p>每次选择一条权值最小的边，使边依附的两个顶点连通（若已经连通则跳过），直到所有顶点连通。</p>
<p>适用于稀疏图，复杂度<span class="math inline">\(O(|E|log_2|E|)\)</span></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>EdgeList MST_Kruskal(ELGraph *G)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> Kruskal算法最小生成树</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> G: 图</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: EdgeList 边表</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    EdgeList MT = (EdgeLNode *) malloc((G-&gt;vexNum - <span class="dv">1</span>) * <span class="kw">sizeof</span>(EdgeLNode));</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k, s1, s2, *Vest = (<span class="dt">int</span> *) malloc(G-&gt;vexNum * <span class="kw">sizeof</span>(<span class="dt">int</span>));</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 初始化连通数组</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* 若Vest[i] = Vest[j]，表明Vi和Vj在同一个连通分量中</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a><span class="co">     * 若Vest[i] ≠ Vest[j]，表明Vi和Vj之间没有回路</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>        Vest[i] = i;</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 边表按权重升序排序</span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    Sort_EdgeList(G-&gt;edgeList, G-&gt;arcNum);</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = j = <span class="dv">0</span>; i &lt; G-&gt;vexNum &amp;&amp; j &lt; G-&gt;vexNum - <span class="dv">1</span>;)&#123;</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 权值最小的边依附的两个顶点</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>        s1 = Vest[G-&gt;edgeList[i].vex1];</span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>        s2 = Vest[G-&gt;edgeList[i].vex2];</span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (s1 != s2)&#123;</span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a>            MT[j].vex1 = G-&gt;edgeList[i].vex1;</span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>            MT[j].vex2 = G-&gt;edgeList[i].vex2;</span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a>            MT[j].weight = G-&gt;edgeList[i].weight;</span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>            j++;</span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (k = <span class="dv">0</span>; k &lt; G-&gt;vexNum; k++)&#123;</span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 连通的顶点对应的于Vest中的值相等</span></span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (Vest[k] == s2)</span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>                    Vest[k] = s1;</span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a>        i++;</span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true" tabindex="-1"></a>    free(Vest);</span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> MT;</span>
<span id="cb50-38"><a href="#cb50-38" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="最短路径算法">*最短路径算法</h2>
<h3 id="dijkstra算法">Dijkstra算法</h3>
<p>求图的单源的最短路径</p>
<p>不能解决带负权值的图</p>
<p>复杂度<span class="math inline">\(O(|V|^2)\)</span></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 是否找到最短路径的标志</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>BOOLEAN final[MAX_VEX];</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 最短路径长度（为0表示到自身、为数值表示路径长度、为无穷表示无法到达）</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> dist[MAX_VEX];</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="co">// 路径上的前驱结点</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> pre[MAX_VEX];</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Path_Dijkstra(ASGraph *G, <span class="dt">int</span> u)</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> Dijkstra算法查找单源最短路径</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图（邻接链表）</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> u: 单源，即顶点u到其余所有顶点的最短路径</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null </span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k;</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> min;</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 初始化3个数组</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)&#123;</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>        pre[i] = u;</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>        final[i] = FALSE;</span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>        dist[i] = G-&gt;adjVec[u][i];</span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>    dist[u] = <span class="dv">0</span>;</span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>    final[u] = TRUE;</span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 遍历除了顶点u以外的顶点，找到没确定最短路径且dist最小的第k个顶点</span></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 说明顶点k到上一个的顶点的最短路径已经找到为dist</span></span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum - <span class="dv">1</span>; i++)&#123;</span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a>        k = <span class="dv">0</span>;</span>
<span id="cb51-30"><a href="#cb51-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (final[k])</span>
<span id="cb51-31"><a href="#cb51-31" aria-hidden="true" tabindex="-1"></a>            k++;</span>
<span id="cb51-32"><a href="#cb51-32" aria-hidden="true" tabindex="-1"></a>        min = INFINITY;</span>
<span id="cb51-33"><a href="#cb51-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)</span>
<span id="cb51-34"><a href="#cb51-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (!final[j] &amp;&amp; dist[k] &lt; min)&#123;</span>
<span id="cb51-35"><a href="#cb51-35" aria-hidden="true" tabindex="-1"></a>                min = dist[j];</span>
<span id="cb51-36"><a href="#cb51-36" aria-hidden="true" tabindex="-1"></a>                k = j;</span>
<span id="cb51-37"><a href="#cb51-37" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb51-38"><a href="#cb51-38" aria-hidden="true" tabindex="-1"></a>        final[k] = TRUE;</span>
<span id="cb51-39"><a href="#cb51-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 通过顶点k，上一个的顶点到与顶点k相邻的顶点是否存在更短路径</span></span>
<span id="cb51-40"><a href="#cb51-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> l = <span class="dv">0</span>; l &lt; G-&gt;vexNum; l++)</span>
<span id="cb51-41"><a href="#cb51-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (!final[l] &amp;&amp; dist[k] + G-&gt;adjVec[k][l] &lt; dist[l])&#123;</span>
<span id="cb51-42"><a href="#cb51-42" aria-hidden="true" tabindex="-1"></a>                dist[l] = dist[k] + G-&gt;adjVec[k][l];</span>
<span id="cb51-43"><a href="#cb51-43" aria-hidden="true" tabindex="-1"></a>                pre[l] = k;</span>
<span id="cb51-44"><a href="#cb51-44" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb51-45"><a href="#cb51-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 输出</span></span>
<span id="cb51-46"><a href="#cb51-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> l = <span class="dv">0</span>; l &lt; G-&gt;vexNum; l++)</span>
<span id="cb51-47"><a href="#cb51-47" aria-hidden="true" tabindex="-1"></a>            printf(<span class="st">&quot;%d</span><span class="sc">\t</span><span class="st">&quot;</span>, (<span class="dt">int</span>)final[l]);</span>
<span id="cb51-48"><a href="#cb51-48" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb51-49"><a href="#cb51-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> l = <span class="dv">0</span>; l &lt; G-&gt;vexNum; l++)</span>
<span id="cb51-50"><a href="#cb51-50" aria-hidden="true" tabindex="-1"></a>            printf(<span class="st">&quot;%d</span><span class="sc">\t</span><span class="st">&quot;</span>, (<span class="dt">int</span>)dist[l]);</span>
<span id="cb51-51"><a href="#cb51-51" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb51-52"><a href="#cb51-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (<span class="dt">int</span> l = <span class="dv">0</span>; l &lt; G-&gt;vexNum; l++)</span>
<span id="cb51-53"><a href="#cb51-53" aria-hidden="true" tabindex="-1"></a>            printf(<span class="st">&quot;%d</span><span class="sc">\t</span><span class="st">&quot;</span>, pre[l]);</span>
<span id="cb51-54"><a href="#cb51-54" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot;</span><span class="sc">\n\n</span><span class="st">&quot;</span>);</span>
<span id="cb51-55"><a href="#cb51-55" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb51-56"><a href="#cb51-56" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="floyd算法">Floyd算法</h3>
<p>求图的各顶点间的最短路径</p>
<p>不能解决带负权值回路的图</p>
<p>复杂度<span class="math inline">\(O(|V|^3)\)</span>​</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 任意两顶点间的最短距离（为0表示到自身、为数值表示路径长度、为无穷表示无法到达）</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> A[MAX_VEX][MAX_VEX];</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 最短路径上的中继顶点</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Path[MAX_VEX][MAX_VEX];</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Print_Path(<span class="dt">int</span> i, <span class="dt">int</span> j)</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 递归输出Floyd算法两顶点间的最短路径</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> i: 顶点i</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> j: 顶点j</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null </span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (Path[i][j] != -<span class="dv">1</span>)&#123;</span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>        Print_Path(i, Path[i][j]);</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>        printf(<span class="st">&quot; -&gt; %d&quot;</span>, Path[i][j]);</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>        Print_Path(Path[i][j], j);</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Path_Floyd(ASGraph *G)</span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> Floyd算法查找顶点间的最短路径</span></span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图（邻接矩阵）</span></span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k;</span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 初始化2个数组</span></span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j =<span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)&#123;</span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a>            A[i][j] = G-&gt;adjVec[i][j];</span>
<span id="cb52-33"><a href="#cb52-33" aria-hidden="true" tabindex="-1"></a>            Path[i][j] = -<span class="dv">1</span>;</span>
<span id="cb52-34"><a href="#cb52-34" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb52-35"><a href="#cb52-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 第k个顶点作为中继顶点，遍历距离矩阵</span></span>
<span id="cb52-36"><a href="#cb52-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 若加入中继顶点最短距离更短则替换</span></span>
<span id="cb52-37"><a href="#cb52-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (k = <span class="dv">0</span>; k &lt; G-&gt;vexNum; k++)</span>
<span id="cb52-38"><a href="#cb52-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb52-39"><a href="#cb52-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (j =<span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)</span>
<span id="cb52-40"><a href="#cb52-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (A[i][k] + A[k][j] &lt; A[i][j])&#123;</span>
<span id="cb52-41"><a href="#cb52-41" aria-hidden="true" tabindex="-1"></a>                    A[i][j] = A[i][k] + A[k][j];</span>
<span id="cb52-42"><a href="#cb52-42" aria-hidden="true" tabindex="-1"></a>                    Path[i][j] = k;</span>
<span id="cb52-43"><a href="#cb52-43" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb52-44"><a href="#cb52-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 输出路径</span></span>
<span id="cb52-45"><a href="#cb52-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb52-46"><a href="#cb52-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; G-&gt;vexNum; j++)</span>
<span id="cb52-47"><a href="#cb52-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (i != j)&#123;</span>
<span id="cb52-48"><a href="#cb52-48" aria-hidden="true" tabindex="-1"></a>                printf(<span class="st">&quot;%d&quot;</span>, i);</span>
<span id="cb52-49"><a href="#cb52-49" aria-hidden="true" tabindex="-1"></a>                Print_Path(i, j);</span>
<span id="cb52-50"><a href="#cb52-50" aria-hidden="true" tabindex="-1"></a>                printf(<span class="st">&quot; -&gt; %d</span><span class="sc">\n</span><span class="st">&quot;</span>, j);</span>
<span id="cb52-51"><a href="#cb52-51" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb52-52"><a href="#cb52-52" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="拓扑排序算法">*拓扑排序算法</h2>
<p>由某个集合上的一个偏序得到该集合上的一个全序的操作。</p>
<p>AOV网：顶点表示活动的有向无环图（Activity On Vertex），图中顶点表示活动，有向边表示活动之间的优先关系。对于有向边&lt;i, j&gt;或i到j的有向路径，i是j的前驱，j是i的后继。AOV网中不能有环。</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>BOOLEAN Topological_Sort(ALGraph *G, <span class="dt">int</span> topology[])</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 拓扑排序</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ALGraph: 图（邻接链表）</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> topology: 拓扑排序</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: BOOLEAN </span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="co"> *  TRUE：有拓扑排序</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a><span class="co"> *  FALSE：图中有环</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, k, adj_k, top = <span class="dv">0</span>, count = <span class="dv">0</span>;</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>    BOOLEAN <span class="dt">bool</span> = TRUE;</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> stack[MAX_VEX];</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>    ArcLNode *p;</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 入度为0的顶点入栈</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; G-&gt;vexNum; i++)</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (G-&gt;adjList[i].inDegree == <span class="dv">0</span>)</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>            stack[++top] = G-&gt;adjList[i].data;</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (top != <span class="dv">0</span>) &#123;</span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 栈顶出栈</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>        k = stack[top--];</span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>        topology[count++] = k;</span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>        p = G-&gt;adjList[k].first;</span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 所有顶点k的后继顶点入度减1（删除顶点k为弧尾的所有弧）</span></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>            adj_k = p-&gt;adjVex;</span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>            G-&gt;adjList[adj_k].inDegree--;</span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 入度为0的顶点入栈</span></span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (G-&gt;adjList[adj_k].inDegree == <span class="dv">0</span>)</span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>                stack[++top] = adj_k;</span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;next;</span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 还原图顶点的入度</span></span>
<span id="cb53-36"><a href="#cb53-36" aria-hidden="true" tabindex="-1"></a>    Count_ALGraph_InDegree(G);</span>
<span id="cb53-37"><a href="#cb53-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 拓扑序列长度小于顶点数，说明图中有环</span></span>
<span id="cb53-38"><a href="#cb53-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (count &lt; G-&gt;vexNum)</span>
<span id="cb53-39"><a href="#cb53-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FALSE;</span>
<span id="cb53-40"><a href="#cb53-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb53-41"><a href="#cb53-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> TRUE;</span></code></pre></div>
<h2 id="关键路径">*关键路径</h2>
<p>AOE网：边表示活动的有向无环图（Activity On Edge），图中顶点表示事件，每个事件表示在其前的所有活动已经完成，其后的活动可以开始；弧表示活动，弧上的权值表示相应活动所需的开销。</p>
<p>事件的最早发生时间ve：拓扑序列中每个顶点的所有（前驱顶点的最早发生时间+活动开销）的最大值</p>
<p>事件的最迟发生时间vl：逆拓扑序列中每个顶点的所有（后继顶点的最迟发生时间-活动开销）的最小值</p>
<p>关键事件：ve=vl</p>
<p>活动的最早发生时间e：等于弧尾最早发生时间</p>
<p>活动的最迟发生时间I：等于弧头最晚发生时间-活动开销</p>
<p>活动的时间余量d：l-e</p>
<p>关键活动：活动的时间余量d=0</p>
<figure>
<img src="../images/关键路径.jpg" alt="关键路径" /><figcaption aria-hidden="true">关键路径</figcaption>
</figure>
<h1 id="查找-2">7. 查找</h1>
<h2 id="基本概念-5">*基本概念</h2>
<p>查找：在数据集合中寻找满足某种条件的数据元素的过程</p>
<p>查找表（查找结构）：用于查找的数据集合，由同一类型的数据元素组成</p>
<p>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找的结果是唯一的</p>
<p>静态查找：在查找时只对查找表的数据元素进行查找，仅关注查找速度</p>
<p>动态查找：在实施查找的同时也要进行插入和删除，除了查找速度，也要关注插入和删除是否方便实现</p>
<p>查找方法的评价指标</p>
<p>查找长度：在查找运算中，需要对比关键字的次数</p>
<p>平均查找长度(ASL, Average Search Length)：所有查找过程中进行关键字的比较次数的平均值，<span class="math inline">\(ASL=\sum_{i=1}^{n}p_i*c_i\)</span>，其中n为元素个数，<span class="math inline">\(p_i\)</span>为查找第i个元素的概率（通常认为查找任何一个元素的概率都相同为1/n），<span class="math inline">\(c_i\)</span>为第i个元素的查找长度</p>
<h2 id="静态查找">**静态查找</h2>
<h3 id="顺序查找">顺序查找</h3>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序查找表</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * 第0个元素为哨兵元素，数据从第1个元素开始储存</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> SqTable&#123;</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    ElemType elem[MAX_SIZE];</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> length;</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>&#125;SqTable;</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>Status SeqSearch(SqTable ST, ElemType key)</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 顺序查找</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ST: 查找表</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> p;</span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 设置哨兵为要查找的元素</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>    ST.elem[<span class="dv">0</span>]=key;</span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 从最后一个元素开始，若要查找的元素与当前元素相同时，跳出循环。若为哨兵元素，此时p为0</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 优点是判断跳出循环的条件不需要检查是否越界</span></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (p = ST.length; !EQ(ST.elem[p], key); p--);</span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p;</span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="折半查找">折半查找</h3>
<p>也称二分查找</p>
<p>查找表是有序的</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>Status BinSearch(SqList ST, ElemType key)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 折半查找</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ST: 查找表（有序）</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> low = <span class="dv">1</span>, high = ST.length, mid;</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (low &lt; high)&#123;</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>        mid = (low + high) / <span class="dv">2</span>;</span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(ST.elem[mid], key))</span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mid;</span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> (LT(ST.elem[mid], key))</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>            low = mid + <span class="dv">1</span>;</span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>            high = mid - <span class="dv">1</span>;</span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<p>折半查找判定树：查找过程可用二叉树表示</p>
<figure>
<img src="../images/折半查找判定树.png" alt="折半查找判定树" /><figcaption aria-hidden="true">折半查找判定树</figcaption>
</figure>
<p>查找成功时，为每个结点的比较次数之和除以有序表长度</p>
<p>ASL=(1×1+2×2+3×4+4×3)/10=29/10</p>
<p>查找失败时，为每个外结点的比较次数之和除以外结点个数，外结点为每个结点的空指针指向的不存在的结点</p>
<p>ASL=(3×5+4×6)/11=39/11</p>
<h3 id="分块查找">分块查找</h3>
<p>也称索引顺序查找，分块有序，分块内无序（第i+1块关键字均大于第i块），分块对应索引表，分块内对应查找表</p>
<p>为顺序查找和折半查找的综合，对索引表折半查找，对查找表顺序查找</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 索引表</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> BlockIndex&#123;</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 块最大关键字</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    ElemType maxKey;</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 块起始位置和终止位置</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> low, high;</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>&#125;BlockIndex;</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>Status BlockSearch(ElemType ST[], BlockIndex index[], ElemType key, <span class="dt">int</span> n, <span class="dt">int</span> blocks)</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 分块查找（顺序查找索引表）</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ST: 查找表</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> index: 索引表</span></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 查找表长度</span></span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> blocks: 分块数</span></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i = <span class="dv">0</span>, j;</span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顺序查找索引表</span></span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> ((i &lt; blocks) &amp;&amp; LT(index[i].maxKey, key))</span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a>        i++;</span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i &gt; blocks)</span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 顺序查找块内</span></span>
<span id="cb56-29"><a href="#cb56-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (j = index[i].low; j &lt; index[i].high; j++)</span>
<span id="cb56-30"><a href="#cb56-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(ST[j], key))</span>
<span id="cb56-31"><a href="#cb56-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span>;</span>
<span id="cb56-32"><a href="#cb56-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (j &gt; n || !EQ(ST[j], key))</span>
<span id="cb56-33"><a href="#cb56-33" aria-hidden="true" tabindex="-1"></a>        j = <span class="dv">0</span>;</span>
<span id="cb56-34"><a href="#cb56-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> j;</span>
<span id="cb56-35"><a href="#cb56-35" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="动态查找">*动态查找</h2>
<h3 id="二叉排序树bst">二叉排序树BST</h3>
<p>概念见二叉树</p>
<h4 id="查找插入创建">查找、插入、创建</h4>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>BTLNode *Search_BST(BTLNode *T, ElemType key)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉排序树的查找</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ST: 二叉排序树</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: BTLNode</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T != NULL)&#123;</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(T-&gt;data, key))</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> T;</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> (LT(T-&gt;data, key))</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> BST_Search(T-&gt;lChild, key);</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> BST_Search(T-&gt;rChild, key);</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> NULL;</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a>Status Insert_BST(BTLNode *T, ElemType key)</span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉排序树的插入</span></span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> ST: 二叉排序树</span></span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 插入关键字</span></span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: Status</span></span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a>    BTLNode *p = (BTLNode *)malloc (<span class="kw">sizeof</span>(BTLNode));</span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a>    p-&gt;data = key;</span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true" tabindex="-1"></a>    p-&gt;lChild = p-&gt;rChild = NULL;</span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 若为空树，则插入根节点</span></span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (T == NULL)</span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true" tabindex="-1"></a>        T = p;</span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 不为空树</span></span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> &#123;</span>
<span id="cb57-36"><a href="#cb57-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 结点已存在</span></span>
<span id="cb57-37"><a href="#cb57-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(T-&gt;data, key))</span>
<span id="cb57-38"><a href="#cb57-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> OK;</span>
<span id="cb57-39"><a href="#cb57-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 插入左子树</span></span>
<span id="cb57-40"><a href="#cb57-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> (LT(p-&gt;data, key))</span>
<span id="cb57-41"><a href="#cb57-41" aria-hidden="true" tabindex="-1"></a>            BST_Insert(T-&gt;lChild, key);</span>
<span id="cb57-42"><a href="#cb57-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 插入右子树</span></span>
<span id="cb57-43"><a href="#cb57-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> </span>
<span id="cb57-44"><a href="#cb57-44" aria-hidden="true" tabindex="-1"></a>            BST_Insert(T-&gt;rChild, key);</span>
<span id="cb57-45"><a href="#cb57-45" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb57-46"><a href="#cb57-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> OK;</span>
<span id="cb57-47"><a href="#cb57-47" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb57-48"><a href="#cb57-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-49"><a href="#cb57-49" aria-hidden="true" tabindex="-1"></a>BTLNode *Create_BST(ElemType el[], <span class="dt">int</span> n)</span>
<span id="cb57-50"><a href="#cb57-50" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb57-51"><a href="#cb57-51" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 二叉排序树的创建</span></span>
<span id="cb57-52"><a href="#cb57-52" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> el: 数组</span></span>
<span id="cb57-53"><a href="#cb57-53" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 数组长度</span></span>
<span id="cb57-54"><a href="#cb57-54" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: BTLNode</span></span>
<span id="cb57-55"><a href="#cb57-55" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb57-56"><a href="#cb57-56" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb57-57"><a href="#cb57-57" aria-hidden="true" tabindex="-1"></a>    BTLNode *T = NULL;</span>
<span id="cb57-58"><a href="#cb57-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n ; i++)&#123;</span>
<span id="cb57-59"><a href="#cb57-59" aria-hidden="true" tabindex="-1"></a>        Insert_BST(T, el[i]);</span>
<span id="cb57-60"><a href="#cb57-60" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb57-61"><a href="#cb57-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> T;</span>
<span id="cb57-62"><a href="#cb57-62" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h4 id="删除-3">删除</h4>
<p>①若被删除结点p是叶结点，则直接删除，不会破坏二叉排序树的性质。</p>
<p>②若结点p只有一棵左子树或右子树，则让p的子树成为p父结点的子树，替代p的位置。</p>
<p>③若结点p有左、右两棵子树，则令p的直接后继或直接前驱替代p，然后从二叉排序树中删去这个直接后继或直接前驱，删去的过程同①②。</p>
<figure>
<img src="../images/BST的删除.png" alt="BST的删除" /><figcaption aria-hidden="true">BST的删除</figcaption>
</figure>
<h3 id="平衡二叉树avl">平衡二叉树AVL</h3>
<p>概念见二叉树</p>
<p>平衡因子：二叉树结点的左子树的深度减去右子树的深度，AVL的平衡因子只可能是-1/0/1</p>
<h4 id="插入-3">插入</h4>
<p>平衡化旋转：将不平衡二叉排序树转变为平衡二叉排序树</p>
<p>LL型：在A的左孩子的左子树中插入导致不平衡，调整: A的左孩子结点右旋</p>
<p>RR型：在A的右孩子的右子树中插入导致不平衡，调整: A的右孩子结点左旋</p>
<p>LR型：在A的左孩子的右子树中插入导致不平衡，调整: A的左孩子的右孩子先左旋再右旋</p>
<p>RL型：在A的右孩子的左子树中插入导致不平衡，调整: A的右孩子的左孩子先右旋后左旋</p>
<p>左孩子只能右旋，右孩子只能左旋</p>
<p>寻找不平衡结点：从插入结点向上回溯，找到第一个不平衡的结点，以该结点为根结点的子树即为最小不平衡子树</p>
<h4 id="删除-4">删除</h4>
<p>与插入类似，不同之处在于，若删除的结点使得最小不平衡子树在平衡后高度-1，则需要对祖先结点进行进一步调整，直至回溯到根结点。</p>
<h4 id="查找-3">查找</h4>
<p>在AVL上查找的复杂度O(<span class="math inline">\(log_2 n\)</span>)</p>
<h3 id="红黑树"><em>红黑树</em></h3>
<p>红黑树是满足红黑性质的二叉排序树：</p>
<ul>
<li>每个结点为红结点或黑结点</li>
<li>根结点为黑结点</li>
<li>叶节点、虚构外部结点、空节点为黑结点</li>
<li>不存在两个相邻的红结点（红结点的父子均为黑结点）</li>
<li>对于每个结点，从该结点到任一叶结点的简单路径上，所含黑结点数量相同</li>
</ul>
<h3 id="b树">B树</h3>
<p>又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶</p>
<figure>
<img src="../images/b树.png" alt="b树" /><figcaption aria-hidden="true">b树</figcaption>
</figure>
<p>一棵m阶B树满足如下条件:</p>
<ul>
<li><p>根结点的子树数∈[2, m]（若根结点为终端节点子树可为1），关键字数∈[1, m-1]</p>
<p>除根结点外的所有非叶子结点子树数∈[<span class="math inline">\(\lceil m/2\rceil\)</span>, m]，关键字数∈[<span class="math inline">\(\lceil m/2\rceil-1\)</span>, m-1]</p></li>
<li><p>关键字的值服从：子树0&lt;关键字1&lt;子树1&lt;关键字2&lt;子树2&lt;....</p></li>
<li><p>对任一结点，其所有子树高度相同；所有的叶子结点都出现在同一层次上，并且不带信息（为虚构外部结点，指向这些结点的指针为空，类似于折半查找判定树的查找失败结点)。</p></li>
</ul>
<p>含n个关键字的m阶B树，高度h的范围：</p>
<ul>
<li>最小高度——让各层的分叉尽可能多，每个结点都有m个分叉，则每个结点有m-1个关键字，通过关键字数构建不等式：<span class="math inline">\(n≤(m-1)(1+m+m^2+...+m^{h-1})=m^h-1\)</span>，即<span class="math inline">\(h≥log_m(n+1)\)</span></li>
<li>最大高度——让各层的分叉尽可能少，根结点只有两个分叉，其他结点只有<span class="math inline">\(\lceil m/2\rceil\)</span>个分叉；而n个关键字的B树必有n+1个叶子结点（每一个结点将-∞~+∞分隔，共分为n+1个区间），通过结点数构建不等式：<span class="math inline">\(n+1≥2\lceil m/2\rceil^{h-1}\)</span>，即<span class="math inline">\(h≤log_{\lceil m/2\rceil}\frac{n+1}{2}+1\)</span></li>
</ul>
<h4 id="插入-4">插入</h4>
<p>向最底层的某个终端结点插入，若插入后该结点关键字数≤m-1，则插入成功</p>
<p>若插入后该结点关键字数=m，则从<span class="math inline">\(\lceil m/2\rceil\)</span>处将其中的关键字分为两部分，左部分（$k_1到k_{m/2} <span class="math inline">\(）置于原结点，右部分（\)</span>k_{m/2+1}到k_m <span class="math inline">\(）置于新结点，中间位置(\)</span>k_{m/2}$) 的关键字插入原结点的父结点</p>
<p>若父节点溢出则向上进一步调整，直至根结点，而根节点溢出时，则在分裂后将中间位置的结点置为新的根结点，树的高度+1</p>
<h4 id="删除-5">删除</h4>
<p>删除后结点的关键字数≥<span class="math inline">\(\lceil m/2\rceil-1\)</span>时</p>
<ul>
<li>若被删除关键字在终端结点，则直接删除该关键字</li>
<li>若被删除关键字在非终端结点，则用直接前驱或直接后继来替代被删除的关键字，转化为对终端结点关键字的删除操作
<ul>
<li>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素</li>
<li>直接后继：当前关键字右侧指针所指子树中“最左下”的元素</li>
</ul></li>
</ul>
<p>删除后结点的关键字数＜<span class="math inline">\(\lceil m/2\rceil-1\)</span>时</p>
<p>右兄弟（或左兄弟）宽裕（关键字数＞<span class="math inline">\(\lceil m/2\rceil-1\)</span>）时，使用被删除关键字的后继、后继的后继（前驱、前驱的前驱）填补空缺</p>
<p>左兄弟和右兄弟都不宽裕（关键字数=<span class="math inline">\(\lceil m/2\rceil-1\)</span>）时，与左兄弟（或右兄弟）和父节点中的关键字进行合并，若合并后父结点关键字不足，则继续向上调整，直至根结点</p>
<h3 id="b树-1">B+树</h3>
<figure>
<img src="../images/b+树.png" alt="b+树" /><figcaption aria-hidden="true">b+树</figcaption>
</figure>
<p>一棵m阶的B+树需满足下列条件:</p>
<ul>
<li>每个分支结点最多有m棵子树(孩子结点)</li>
<li>非叶根结点至少有两棵子树，其他每个分支结点至少有<span class="math inline">\(\lceil m/2\rceil\)</span>棵子树</li>
<li>结点的子树个数与关键字个数相等（B树和B+树的区别）</li>
<li>所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来（支持顺序查找）</li>
<li>所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针</li>
</ul>
<h4 id="插入-5">插入</h4>
<p>若插入结点关键字数＜m，则直接插入</p>
<p>若插入结点关键字数=m，则从<span class="math inline">\(\lceil m/2\rceil\)</span>处将其中的关键字分为两部分，左部分（$k_1到k_{m/2} <span class="math inline">\(）置于原结点，右部分（\)</span>k_{m/2+1}到k_m <span class="math inline">\(）置于新结点，同时中间位置(\)</span>k_{m/2}$) 的关键字插入原结点的父结点</p>
<p>若父节点溢出则向上进一步调整，直至根结点，而根节点溢出时，则在分裂后将中间位置的结点置为新的根结点，树的高度+1</p>
<h2 id="散列哈希查找">*散列（哈希）查找</h2>
<p>散列表，又称哈希表，数据元素的关键字与其存储地址直接相关</p>
<p>散列函数的构造方法：</p>
<ul>
<li>直接定址法：H(key) = key 或 H(key) = a × key + b，适合关键字分布基本连续的情况</li>
<li>保留余数法：H(key) = key % p，其中p为不大于表长m的最大素数（用质数取模，分布相对均匀，冲突少，牺牲了m-p的存储空间）</li>
<li>数字分析法：取关键字的数码较为均匀的若干位作为散列地址，如手机号的尾号</li>
<li>平方取中法：取关键字的平方的中间若干位作为散列地址，其与关键字的每一位都有联系，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数</li>
</ul>
<p>处理冲突的方法：</p>
<ul>
<li>开放定址法：空闲地址既向同义词表项开放，又向非同义词表项开放，地址为<span class="math inline">\(H_i=(H(key)+d_i)\%m\)</span>，其中m为表长，<span class="math inline">\(d_i\)</span>为递增序列，i为第i次发生冲突
<ul>
<li>线性探测法：<span class="math inline">\(d_i=0,1,2,...,k(k≤m-1)\)</span>，容易造成“堆积”现象，由于在查找时，遇到空闲地址说明无同义词，即可停止查找，然而堆积现象填满了空闲地址导致查找不能快速地停止，效率大大降低。同时，在删除结点时，不能简单地将被删除节点的空间置为空，否则将阶段在其之后填入散列表的同义词的查找路径，可以使用删除标记进行逻辑删除</li>
<li>平方探测法：<span class="math inline">\(d_i=0^2,1^2,-1^2,...,k^2,-k^2(k≤m/2)\)</span>，同时列表长度m必须可以表示成4k+3才能够探测到所有位置</li>
<li>伪随机序列法：<span class="math inline">\(d_i\)</span>为伪随机数序列</li>
<li>再散列法：<span class="math inline">\(d_i=RH_i(key)\)</span>，准备多个散列函数，冲突了就换下一个</li>
</ul></li>
<li>拉链法（链地址法）：把所有同义词表项储存在一个链表中</li>
</ul>
<h3 id="散列查找算法">散列查找算法</h3>
<h4 id="开放定址法的线性探测法">开放定址法的线性探测法</h4>
<figure>
<img src="../images/哈希_线性探测法.png" alt="哈希_线性探测法" /><figcaption aria-hidden="true">哈希_线性探测法</figcaption>
</figure>
<p>查找成功ASL=(1+1+1+2+4+1+1+3+3+1+3+9)/12=2.5</p>
<p>查找失败ASL=(1+13+12+11+10+9+8+7+6+5+4+3+2)/13=7（<span class="math inline">\(H_0\)</span>的范围为[0, 12]）</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> RecType&#123;</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    KeyType key;</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    OtherType other;</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>&#125;RecType;</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> H(<span class="dt">int</span> key);</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Hash_Search(RecType HT[], KeyType key, <span class="dt">int</span> m)</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 使用开放地址法的线性探测法解决冲突，并进行散列查找</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> HT: 散列表</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> m: 散列表长度</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: int</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> h, i;</span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>    h = H(key);</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (i &lt; m &amp;&amp; !EQ(HT[h].key, NULLKEY))&#123;</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(HT[h].key, key))</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> h;</span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Hash_Search(HT, key, ++i);</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h4 id="拉链法">拉链法</h4>
<figure>
<img src="../images/哈希_拉链法.png" alt="哈希_拉链法" /><figcaption aria-hidden="true">哈希_拉链法</figcaption>
</figure>
<p>查找成功ASL=(1×6+2×4+3×1+4×1)/12=1.75</p>
<p>查找失败ASL=(4+2+2+1+2+1)/13=0.92</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> HashLNode&#123;</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    KeyType key;</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> HashLNode *next;</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>&#125;HashLNode;</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>HashLNode *Hash_Search_Link(HashLNode *HT[], KeyType key)</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 使用拉链法解决冲突，并进行散列查找</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> HT: 散列表</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> key: 查找关键字</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: HashLnode</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>    HashLNode *p;</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>    i = H(key);</span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (HT[i] == NULL)</span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> NULL;</span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>    p = HT[i];</span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (p != NULL)&#123;</span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (EQ(p-&gt;key, key))</span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> p;</span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;next;</span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> NULL;</span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h1 id="排序">8. 排序</h1>
<p>算法的稳定性：排序后关键值相等的记录的相对位置不变称为稳定的，否则不稳定</p>
<p>内部排序：数据都在内存中</p>
<table>
<thead>
<tr class="header">
<th>排序方法</th>
<th>平均时间</th>
<th>最坏时间</th>
<th>最好时间</th>
<th>空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>直接插入</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>逆序<span class="math inline">\(O(n^2)\)</span></td>
<td>有序<span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>稳定</td>
</tr>
<tr class="even">
<td>希尔</td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td>优于<span class="math inline">\(O(n^2)\)</span></td>
<td>有序<span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>不稳定</td>
</tr>
<tr class="odd">
<td>冒泡</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td>逆序<span class="math inline">\(O(n^2)\)</span></td>
<td>有序<span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>稳定</td>
</tr>
<tr class="even">
<td>快速</td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td>有序<span class="math inline">\(O(n^2)\)</span></td>
<td>平均划分 <span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td>不稳定</td>
</tr>
<tr class="odd">
<td>直接选择</td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(n^2)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>不稳定</td>
</tr>
<tr class="even">
<td>堆</td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td>不稳定</td>
</tr>
<tr class="odd">
<td>归并</td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(nlog_2n)\)</span></td>
<td><span class="math inline">\(O(n)\)</span></td>
<td>稳定</td>
</tr>
<tr class="even">
<td>基数</td>
<td><span class="math inline">\(O(d(n+r))\)</span></td>
<td><span class="math inline">\(O(d(n+r))\)</span></td>
<td><span class="math inline">\(O(d(n+r))\)</span></td>
<td><span class="math inline">\(O(d(n+r))\)</span></td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h2 id="插入排序">插入排序</h2>
<h3 id="直接插入排序">直接插入排序</h3>
<p>每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Insert_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 直接插入排序</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j;</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">1</span>; i &lt; n; i++)&#123;</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>        temp = R[i];</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 无序区第一个元素插入有序区</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = i - <span class="dv">1</span>; j &gt;= <span class="dv">0</span> &amp;&amp; temp.key &lt; R[j].key; j--)</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>            R[j + <span class="dv">1</span>] = R[j];</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>        R[j + <span class="dv">1</span>] = temp;</span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="希尔排序">希尔排序</h3>
<p>分组插入排序：先将待排序表分割成若干形如L[i, i + d, i + 2d, ..., i + kd]的子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d=1为止。</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Shell_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 希尔排序</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j;</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="dt">int</span> d = n / <span class="dv">2</span>; d &gt; <span class="dv">0</span>; d /= <span class="dv">2</span>)&#123;</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i = d; i &lt; n; i++)&#123;</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (j = i - d; j &gt;= <span class="dv">0</span> &amp;&amp; R[j].key &gt; R[j + d].key; j -= d)&#123;</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>                temp = R[j];</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>                R[j] = R[j + d];</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>                R[j + d] = temp;</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="交换排序">交换排序</h2>
<h3 id="冒泡排序">冒泡排序</h3>
<p>从后往前（或从前往后）两两比较相邻元素的值，若为逆序则交换它们，直到序列比较完。称这样过程为一趟冒泡排序，最多只需n-1趟排序，每趟排序可使一个元素的移动到最终位置，已经确定最终位置的元素在之后的处理中无需再对比。若某一趟排序过程中未发生交换，则算法可提前结束</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Bubble_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 冒泡排序</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j;</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; n - <span class="dv">1</span>; i++)&#123;</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = n - <span class="dv">1</span>; j &gt; i; j--)&#123;</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (R[j].key &lt; R[j - <span class="dv">1</span>].key)&#123;</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>                temp = R[j];</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>                R[j] = R[j - <span class="dv">1</span>];</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>                R[j - <span class="dv">1</span>] = temp;</span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="快速排序">快速排序</h3>
<p>在待排序表中任取一个元素作为枢轴元素pivot（通常取首元素），通过一趟排序将待排序表划分为独立的两部分使得左边所有元素小于pivot，右边所有元素大于等于pivot，则pivot最终落在空出来的位置上，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至两部分内只有一个元素或空为止</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Quick_Sort(RecType R[], <span class="dt">int</span> low, <span class="dt">int</span> high)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 快速排序</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> low: 表头下标</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> high: 表尾下标</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i = low, j = high;</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 递归结束条件，区间内至少存在一个元素</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (low &lt; high)&#123;</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>        temp = R[low];</span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> (i != j)&#123;</span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 跳过右边大于枢轴的，直到找到一个小于的</span></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (i &lt; j &amp;&amp; R[j].key &gt; temp.key) j--;</span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (i &lt; j)&#123;</span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>                R[i] = R[j];</span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>                i++;</span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 跳过左边小于枢轴的，直到找到一个大于的</span></span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> (i &lt; j &amp;&amp; R[i].key &lt; temp.key) i++;</span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (i &lt; j)&#123;</span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>                R[j] = R[i];</span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a>                j--;</span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a>        R[i] = temp;</span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a>        Quick_Sort(R, low, i - <span class="dv">1</span>);</span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>        Quick_Sort(R, i + <span class="dv">1</span>, high);</span>
<span id="cb63-32"><a href="#cb63-32" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb63-33"><a href="#cb63-33" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="选择排序">选择排序</h2>
<h3 id="直接选择排序">直接选择排序</h3>
<p>每一趟在待排序元素中选取关键字最小的元素加入有序子序列，必须进行n-1趟处理</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Select_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 直接选择排序</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k;</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; n - <span class="dv">1</span>; i++)&#123;</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 找到[i, n-1]中最小的关键字的下标</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (k = i, j = i + <span class="dv">1</span>; j &lt; n; j++)</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (R[j].key &lt; R[k].key)</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>                k = j;</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (k != i)&#123;</span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>            temp = R[i];</span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>            R[i] = R[k];</span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>            R[k] = temp;</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h3 id="堆排序">堆排序</h3>
<p>堆：顺序存储的完全二叉树，大根堆（根≥左右），小根堆（根≤左右），结点i的左孩子是2i，右孩子是2i+1，父节点是i/2；编号≤n/2的结点都是分支结点</p>
<p>建堆：编号≤n/2的所有分支结点依次下坠调整（与关键字更大的孩子交换），建堆的复杂度为O(n)</p>
<p>排序：将堆顶元素加入有序子序列(堆顶元素与堆底元素交换)，堆底元素换到堆顶后，需要进行下坠调整，恢复大根堆，上述过程重复n-1趟</p>
<p>基于大根堆排序得递增，小根堆递减</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Sift(RecType R[], <span class="dt">int</span> low, <span class="dt">int</span> high)</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 堆排序下降操作</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> low: 表头</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> high: 表尾</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i = low, j = <span class="dv">2</span> * i;</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    RecType temp = R[i];</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (j &lt;= high)&#123;</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 比较左右孩子哪一个更大</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (j &lt; high &amp;&amp; R[j].key &lt; R[j + <span class="dv">1</span>].key) j++;</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 若该分支节点小于更大的孩子，则执行下降操作</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (temp.key &lt; R[j].key)&#123;</span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>            R[i] = R[j];</span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>            i = j;</span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>            j = <span class="dv">2</span> * i;</span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> <span class="cf">break</span>;</span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>    R[i] = temp;</span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Heap_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 堆排序</span></span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb65-33"><a href="#cb65-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i;</span>
<span id="cb65-34"><a href="#cb65-34" aria-hidden="true" tabindex="-1"></a>    RecType temp;</span>
<span id="cb65-35"><a href="#cb65-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 构造大根堆</span></span>
<span id="cb65-36"><a href="#cb65-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = n / <span class="dv">2</span> - <span class="dv">1</span>; i &gt;= <span class="dv">1</span>; i--)</span>
<span id="cb65-37"><a href="#cb65-37" aria-hidden="true" tabindex="-1"></a>        Sift(R, i, n);</span>
<span id="cb65-38"><a href="#cb65-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 堆顶元素与堆底元素交换，并恢复大根堆，n-1次循环后完成排序</span></span>
<span id="cb65-39"><a href="#cb65-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = n; i &gt;= <span class="dv">2</span>; i--)&#123;</span>
<span id="cb65-40"><a href="#cb65-40" aria-hidden="true" tabindex="-1"></a>        temp = R[<span class="dv">1</span>];</span>
<span id="cb65-41"><a href="#cb65-41" aria-hidden="true" tabindex="-1"></a>        R[<span class="dv">1</span>] = R[i];</span>
<span id="cb65-42"><a href="#cb65-42" aria-hidden="true" tabindex="-1"></a>        R[i] = temp;</span>
<span id="cb65-43"><a href="#cb65-43" aria-hidden="true" tabindex="-1"></a>        Sift(R, <span class="dv">1</span>, i - <span class="dv">1</span>);</span>
<span id="cb65-44"><a href="#cb65-44" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb65-45"><a href="#cb65-45" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="归并排序">归并排序</h2>
<p>把两个或多个有序的子序列合并为一个，2路归并为二合一，k路归并为k合一</p>
<p>若low&gt;high, 则将序列分从中间mid=(low+high)/2分开，对左半部分[low, mid]和右半部分[mid+ 1, high]递归地进行归并排序，然后将左右两个有序子序列Merge为一个</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Merge(RecType R[], <span class="dt">int</span> low, <span class="dt">int</span> mid, <span class="dt">int</span> high)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 归并排序排序两个子表</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> low: 子表1表头</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> mid: 子表2表头</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> high: 表尾</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i、j分别为两段的下标，k为新表的下标</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i = low, j = mid, k = <span class="dv">0</span>;</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>    RecType *R1 = (RecType *)malloc ((high - low) * <span class="kw">sizeof</span>(RecType));</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (i &lt; mid &amp;&amp; j &lt; high)</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (R[i].key &lt;= R[j].key)&#123;</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>            R1[k] = R[i];</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>            i++;</span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>            k++;</span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>        &#125; <span class="cf">else</span> &#123;</span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>            R1[k] = R[j];</span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a>            j++;</span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a>            k++;</span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 处理剩余部分</span></span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (i &lt; mid)&#123;</span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>        R1[k] = R[i];</span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a>        i++;</span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a>        k++;</span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> (j &lt; high)&#123;</span>
<span id="cb66-31"><a href="#cb66-31" aria-hidden="true" tabindex="-1"></a>        R1[k] = R[j];</span>
<span id="cb66-32"><a href="#cb66-32" aria-hidden="true" tabindex="-1"></a>        j++;</span>
<span id="cb66-33"><a href="#cb66-33" aria-hidden="true" tabindex="-1"></a>        k++;</span>
<span id="cb66-34"><a href="#cb66-34" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb66-35"><a href="#cb66-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 将结果复制回原表</span></span>
<span id="cb66-36"><a href="#cb66-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (k = <span class="dv">0</span>, i = low; i &lt; high; k++, i++)</span>
<span id="cb66-37"><a href="#cb66-37" aria-hidden="true" tabindex="-1"></a>        R[i] = R1[k];</span>
<span id="cb66-38"><a href="#cb66-38" aria-hidden="true" tabindex="-1"></a>&#125;</span>
<span id="cb66-39"><a href="#cb66-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-40"><a href="#cb66-40" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Merge_Sort(RecType R[], <span class="dt">int</span> n)</span>
<span id="cb66-41"><a href="#cb66-41" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb66-42"><a href="#cb66-42" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 归并排序</span></span>
<span id="cb66-43"><a href="#cb66-43" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> R: 排序表</span></span>
<span id="cb66-44"><a href="#cb66-44" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> n: 表长</span></span>
<span id="cb66-45"><a href="#cb66-45" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb66-46"><a href="#cb66-46" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb66-47"><a href="#cb66-47" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb66-48"><a href="#cb66-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, length;</span>
<span id="cb66-49"><a href="#cb66-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (length = <span class="dv">1</span>; length &lt; n; length = <span class="dv">2</span> * length)</span>
<span id="cb66-50"><a href="#cb66-50" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 归并两个相邻的子表</span></span>
<span id="cb66-51"><a href="#cb66-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i = <span class="dv">0</span>; i + <span class="dv">2</span> * length &lt;= n; i = i + <span class="dv">2</span> * length)</span>
<span id="cb66-52"><a href="#cb66-52" aria-hidden="true" tabindex="-1"></a>            Merge(R, i, i + length, i + <span class="dv">2</span> * length);</span>
<span id="cb66-53"><a href="#cb66-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 有可能余下两个子表，其中最后一个子表长度不足length</span></span>
<span id="cb66-54"><a href="#cb66-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (i + length &lt;= n)</span>
<span id="cb66-55"><a href="#cb66-55" aria-hidden="true" tabindex="-1"></a>            Merge(R, i , i + length, n);</span>
<span id="cb66-56"><a href="#cb66-56" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>
<h2 id="基数排序">基数排序</h2>
<p>将整个关键字拆分为d位，当前处理的关键字位可能取得r个值，建立r个队列</p>
<p>按照各个关键字位权重递增的次序（如: 个、十、百），做d趟分配和收集：</p>
<ul>
<li><p>分配：顺序扫描各个元素，根据当前处理的关键字位，将元素插入相应队列。一趟分配复杂度O(n)</p></li>
<li><p>收集：把各个队列中的结点依次出队并链接。一趟收集复杂度O(r)</p></li>
</ul>
<p>适用情况：</p>
<ul>
<li><p>数据元素的关键字可以方便地拆分为d组，且d较小</p></li>
<li><p>每组关键字的取值范围不大，即r较小</p></li>
<li><p>数据元素个数n较大</p></li>
</ul>
<div class="sourceCode" id="cb67"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>RecLNode *Radix_Sort(RecLNode *p)</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Description:</span><span class="co"> 基数排序</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@Param</span><span class="co"> p: 排序链表</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@return</span><span class="co">: null</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="co"> **/</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>&#123;</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>    RecLNode *head[RADIX], *tail[RADIX], *ptail;</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i, j, k;</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i = DIGIT - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; i--)&#123;</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 初始化首尾指针</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; RADIX; j++)</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>            head[j] = tail[j] = NULL;</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 遍历排序链表的每个结点</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span>(p != NULL)&#123;</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>            k = (<span class="dt">int</span>)p-&gt;data[i];</span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (head[k] == NULL)&#123;</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a>                head[k] = p;</span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a>                tail[k] = p;</span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a>            &#125; <span class="cf">else</span> &#123;</span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>                tail[k]-&gt;next = p;</span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>                tail[k] = p;</span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a>            p = p-&gt;next;</span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a>        p = NULL;</span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 收集</span></span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; RADIX; j++)&#123;</span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (head[j] != NULL)&#123;</span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (p == NULL)&#123;</span>
<span id="cb67-31"><a href="#cb67-31" aria-hidden="true" tabindex="-1"></a>                    p = head[j];</span>
<span id="cb67-32"><a href="#cb67-32" aria-hidden="true" tabindex="-1"></a>                    ptail = tail[j];</span>
<span id="cb67-33"><a href="#cb67-33" aria-hidden="true" tabindex="-1"></a>                &#125; <span class="cf">else</span> &#123;</span>
<span id="cb67-34"><a href="#cb67-34" aria-hidden="true" tabindex="-1"></a>                    ptail-&gt;next = head[j];</span>
<span id="cb67-35"><a href="#cb67-35" aria-hidden="true" tabindex="-1"></a>                    ptail = tail[j];</span>
<span id="cb67-36"><a href="#cb67-36" aria-hidden="true" tabindex="-1"></a>                &#125;</span>
<span id="cb67-37"><a href="#cb67-37" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb67-38"><a href="#cb67-38" aria-hidden="true" tabindex="-1"></a>        &#125;        </span>
<span id="cb67-39"><a href="#cb67-39" aria-hidden="true" tabindex="-1"></a>        ptail-&gt;next = NULL;</span>
<span id="cb67-40"><a href="#cb67-40" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb67-41"><a href="#cb67-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p;</span>
<span id="cb67-42"><a href="#cb67-42" aria-hidden="true" tabindex="-1"></a>&#125;</span></code></pre></div>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-08-31T16:00:00.000Z" itemprop="datePublished">2022/09/01</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-自然语言处理"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/">自然语言处理</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="nlp基础与机器学习">NLP基础与机器学习</h1>
<figure>
<img src="../images/评价指标.png" alt="评价指标" /><figcaption aria-hidden="true">评价指标</figcaption>
</figure>
<p>中文分词方法：</p>
<p>基于词典的分词</p>
<p>基于统计的机器学习算法</p>
<h1 id="自然语言模型与词向量">自然语言模型与词向量</h1>
<h2 id="离散表示">离散表示</h2>
<h3 id="onehot模型">OneHot模型</h3>
<p>保留了原始句子的所有细节，包括语法和词序。</p>
<p>缺点是词表增大时，表示矩阵也会增大。</p>
<h3 id="词袋模型">词袋模型</h3>
<p>计算词在给定文本中出现的次数或者频率。</p>
<p>假设：一个词在文档中出现的次数越多，那么该词对文档的意义的贡献就越大。</p>
<h4 id="齐普夫定律">齐普夫定律</h4>
<p>齐普夫定律：在一个大的语料库中统计词频，然后将词按照词频从高到低的顺序排列成一张表。一个词的词频 f 和它在表中的序号 r 之间存在关系：<span class="math inline">\(f∝ \frac{1}{r}\)</span> 或 <span class="math inline">\(f \times r≈k\)</span>， k为常数。</p>
<p>在文本文档中，各频次词语以一定规律分布，词频统计方法利用统计学知识对词汇规律进行描述。齐普夫定律是对人类语言词频分布的一个粗糙而有用的描述:</p>
<ul>
<li>非常常用的词很少</li>
<li>中频词的数量中等</li>
<li>大量低频词</li>
</ul>
<p>省力原则（the Principle of Least Effort）：以最小的代价换取最大的收益。这是指导人类行为的一条根本性原则，各种资源(人力、货物、时间、技巧以及其他任何生产性资源)都存在一种进行自我调整以实现最小化工作量的趋向。</p>
<ul>
<li><p>讲者希望：用一个词表达所有的意义是最经济的。这样，说话人不需要花费气力去掌握更多的词汇，也不需要考虑如何从一堆词汇中选择一个合适的词。</p></li>
<li><p>听者希望：最省力的是每个词都只有一一个意义，词汇的形式和意义之间完全一一对应。</p></li>
</ul>
<h4 id="词项频率-tf">词项频率 TF</h4>
<p>某个词在给定文档中出现等次数为词项频率</p>
<p>归一化词频：<span class="math inline">\(TF = \frac{词t在文档中出现的次数}{文档总词数}\)</span></p>
<h4 id="逆文档频率-idf">逆文档频率 IDF</h4>
<p>逆文档频率：反映一个关键词在整个数据全局中重要性的全局性统计特征。</p>
<p>词计数是有用的，但是纯词计数，即使按照文档长度进行归一化处理，也不能告诉我们太多该词在当前文档相对于语料库中其他文档的重要信息。如果一个词在整个数据全集中出现的频度很小，则它应该是反映包含该类词的文档内容的重要词汇。因此，一个关键词的权重应该与该词所在的文档的总数成反比或近似反比的关系：<span class="math inline">\(IDF = log(\frac{N}{n_i}) = log(\frac{文档数}{包含词t的文档数})\)</span></p>
<p>如果一个词在某一个文档中出现很多次，但是在其他文档中几乎很少出现，那么可以认为这个词对当前文档很重要。</p>
<h4 id="tf-idf">TF-IDF</h4>
<p>对于语料库 D 中给定的文档 d 中的词 t，有</p>
<p><span class="math inline">\(TF(t,d) = log(\frac{t在d中出现的次数}{d的总词数})\)</span></p>
<p><span class="math inline">\(IDF(t,D) = log(\frac{D的总文档数}{包含t的文档数})\)</span></p>
<p><span class="math inline">\(TF-IDF(t,d,D) = TF(t,d) \times IDF(t,D)\)</span></p>
<h3 id="n-gram模型">N-gram模型</h3>
<h4 id="句子概率">句子概率</h4>
<figure>
<img src="../images/句子概率.png" alt="句子概率" /><figcaption aria-hidden="true">句子概率</figcaption>
</figure>
<p>给定一个句子中前面 n-1个词，预测下面的词是哪个词。由于语言的规律性，句子中前面出现的词对后面可能出现的词有很强的预示作用。</p>
<figure>
<img src="../images/N-gram模型.png" alt="N-gram模型" /><figcaption aria-hidden="true">N-gram模型</figcaption>
</figure>
<ul>
<li>n较大时
<ul>
<li>提供了更多的语境信息，语境更具区别性。</li>
<li>参数个数多、计算代价大、训练语料需要多、参数估计不可靠。</li>
</ul></li>
<li>n较小时
<ul>
<li>语境信息少，不具区别性。</li>
<li>参数个数少、计算代价小、训练语料无需太多、参数估计可靠。</li>
</ul></li>
</ul>
<h4 id="建立n-gram">建立N-gram</h4>
<p>数据准备:</p>
<ul>
<li>确定训练语料</li>
<li>对语料进行tokenization或切分</li>
<li>句子边界，增加两个特殊的词[B]和[E]</li>
</ul>
<figure>
<img src="../images/建立N-gram1.png" alt="建立N-gram" /><figcaption aria-hidden="true">建立N-gram</figcaption>
</figure>
<figure>
<img src="../images/建立N-gram2.png" alt="建立N-gram" /><figcaption aria-hidden="true">建立N-gram</figcaption>
</figure>
<figure>
<img src="../images/建立N-gram3.png" alt="建立N-gram" /><figcaption aria-hidden="true">建立N-gram</figcaption>
</figure>
<p>最大似然估计(MLE)给训练样本中未观察到的事件赋以0概率。若某N-gram在训练语料中没有出现，则该N-gram的概率必定是0。解决的办法是扩大训练语料的规模。但是无论怎样扩大训练语料，都不可能保证所有的词在训练语料中均出现。</p>
<p>由于训练样本不足而导致所估计的分布不可靠的问题，称为<strong>数据稀疏问题</strong>。在NLP领域中，数据稀疏问题永远存在，不太可能有一个足够大的训练语料，因为语言中的大部分词都属于低频词(齐普夫定律)。</p>
<h4 id="平滑技术">平滑技术</h4>
<p>为了解决数据稀疏问题，把在训练样本中出现过的事件的概率适当减小。把减小得到的概率密度分配给训练语料中没有出现过的事件。这个过程有时也称为discounting(减值)。</p>
<p>Add-one 平滑：每一种情况出现的次数加1。</p>
<p>训练语料中未出现的n- gram的概率不再为0，而是一一个大于0的较小的概率值。但由于训练语料中未出现n-gram数量太多，平滑后，所有未出现的n-gram占据了整个概率分布中的一个很大的比例，给训练语料中没有出现过的n-gram分配了太多的概率空间。</p>
<p>认为所有未出现的n-gram概率相等不合理；出现在训练语料中的n-gram，都增加同样的频度值不公平</p>
<p>Add-delta 平滑：加一个小于1的正数δ，效果比Add-one好，但是仍然不理想。</p>
<h3 id="统计语言模型的优缺点">统计语言模型的优缺点</h3>
<p>优点：</p>
<ul>
<li>统计语言模型非常容易训练(通过计数来估计概论)</li>
<li>在实际应用中有较好的效果</li>
</ul>
<p>缺点:</p>
<ul>
<li>模型复杂度较高: n-gram O(|V|^n)</li>
<li>模型的泛化性能差</li>
<li>平滑技术的适用性差</li>
</ul>
<h2 id="分布式表示">分布式表示</h2>
<h3 id="分布式假设">分布式假设</h3>
<p>一个词的含义可以通过它在语料中所有出现的上下文的聚合来表示，因此出现在相似上下文中的词的意义也相似。</p>
<h3 id="静态词向量">静态词向量</h3>
<p>词向量：是对词语语义或含义的数值向量表示，包括字面意义和隐含意义。词向量也称之为词嵌入(word embeddings)或者词表示(word representations)。</p>
<ul>
<li>把词表示成低维空间中的向量(100-1000)</li>
<li>句法语义特性相近的词在空间中距离相近</li>
<li>更为细致的语义结构信息——类比特性</li>
<li>分布假设(Distributional Hypothesis)：一个词的含义可以通过它在语料中所有出现的上下文的聚合来表示，因此出现在相似上下文中的词的意义也相似</li>
</ul>
<p>每一个词被表示为一个低维向量空间中的稠密向量，目的是使意义相近的词在空间中位置也相近。</p>
<h4 id="word2vec">Word2vec</h4>
<p>大规模未标注语料库中，每一句语料中的任意位置都有一个中心词(center word)c和上下文词(context word)o，c和o的相似度可用给定c的情况下o的条件概率来表示，不断的调整word vector使得这个概率最大化。每个单词w可用两个向量表示，一个是它作为center word时的向量Vw以及它作为context word时的向量Uw。</p>
<p><strong>Word2vec实现：</strong></p>
<ul>
<li><strong>CBOW（continuous bag-of-words）是根据中心词周围的上下文单词来预测该词的词向量。训练速度快。</strong></li>
<li><strong>Skip-Gram是根据中心词预测周围上下文的词的概率分布。处理生僻字能力高。</strong></li>
</ul>
<p><strong>训练方法：</strong></p>
<ul>
<li><strong>Negative Sampling（负采样）：通过抽取负样本来定义目标。对高频词更友好。</strong></li>
<li><strong>Hierarchical SoftMax（层次SoftMax）：通过Huffman树结构来计算所有词的概率来定义目标。对低频词更友好。</strong></li>
</ul>
<p>局限性：</p>
<ul>
<li>只考虑到上下文信息，忽略了全局信息。</li>
<li>只考虑上下文的共现性，忽略了顺序信息。</li>
</ul>
<h4 id="fasttext">FastText</h4>
<p>在word2vec中并没有直接利用构词学中的信息。无论是在跳字模型还是连续词袋模型中，我们都将形态不同的单词用不同的向量来表示。例如，“dog” 和“dogs"分别用两个不同的向量表示，而模型中并未直接表达这两个向量之间的关系。FastText提出了<strong>子词嵌入</strong>(sub word embedding)的方法， 从而试图将构词信息引入word2vec中的跳字模型。在FastText中，每个中心词被表示成子词的集合。FastText中词典规模更大，造成模型参数更多，同时一个词的向量需要对所有子词向量求和，继而导致计算复杂度更高。</p>
<p>优点：</p>
<ul>
<li><p>学习速度比较快</p></li>
<li><p>适用于分类类别非常大而且数据集足够多的情况</p></li>
</ul>
<p>缺点：</p>
<ul>
<li>当分类类别比较小或者数据集比较少的话，很容易过拟合</li>
</ul>
<h4 id="glove">GloVe</h4>
<p>Global Vectors，全局向量的词嵌入，GloVe是一种基于全局语料计数的无监督学习模型，但是采用log(X)作为label，故损失函数采用最小平方损失函数。从全局考虑输出词向量表征。</p>
<p>Word2vec与GloVe：</p>
<ul>
<li>word2Vec 是一种预测型模型，而GloVe是基于计数的模型。</li>
<li>word2vec是局部语料库训练的，其特征提取是基于滑窗的；而glove的滑窗是为了构建共现矩阵，是基于全局语料的，可见GloVe需要事先统计共现概率。因此，word2vec可以进行在线学习，GloVe则需要统计固定语料信息。</li>
<li>word2vec是无监督学习，同样由于不需要人工标注；GloVe通常被认为是无监督学习，但实际上GloVe还是有label的，即共现次数。</li>
<li>word2vec损失函数实质上是带权重的交叉熵，权重固定；GloVe的损失函数是最小平方损失函数，权重可以做映射变换。</li>
<li>总体来看，GloVe可以被看作是更换了目标函数和权重函数的全局word2vec。</li>
</ul>
<p>优点：</p>
<ul>
<li>快速训练</li>
<li>可扩展到大型语料库</li>
<li>即使是小的语料库和小的向量也表现良好</li>
<li>早停。当改进变小时，我们可以停止培训。</li>
</ul>
<p>缺点：</p>
<ul>
<li>占用大量内存：构造术语共生矩阵的最快方法是将其作为哈希图保存在RAM中，并以全局方式执行共生增量</li>
<li>有时对初始学习率非常敏感</li>
</ul>
<h3 id="词向量评价">词向量评价</h3>
<h4 id="类比推理">类比推理</h4>
<p>考察用词向量来推断不同单词之间的语义关系的能力，在这个任务中，三个单词a, b和s被给出，目标是推断出第四个单词t满足“a和b, t和s是相似的”。</p>
<h4 id="相似度评价">相似度评价</h4>
<p>评估词向量模型在两个词之间的语义紧密度和相关性的能力，例如男人与女人，中国与北京这些词对之间的相似度。在词相似度任务上，一般采用斯皮尔曼等级相关系数ρ (Spearman's rank correlation coefficient)作为评价指标，它是衡量两个变量的依赖性的指标，利用单调方程评价两个统计变量的相关性，如果数据中没有重复值，并且当两个变量完全单调相关时，斯皮尔曼相关系数则为+1或-1。</p>
<h1 id="卷积神经网络">卷积神经网络</h1>
<p>自然图像中的物体具有<strong>局部不变特征</strong>。</p>
<h2 id="卷积">卷积</h2>
<p><strong>卷积神经网络结构特性：</strong></p>
<ul>
<li><strong>局部连接</strong></li>
<li><strong>权重共享</strong></li>
<li><strong>空间或时间上的次采样</strong></li>
</ul>
<p><strong>扩大感受野：</strong></p>
<ul>
<li><strong>增加卷积核大小</strong></li>
<li><strong>增加层数</strong></li>
<li><strong>卷积前池化</strong></li>
<li><strong>空洞卷积</strong></li>
</ul>
<p>参数：</p>
<ul>
<li>in_size M0</li>
<li>out_size M1</li>
<li>in_channels D</li>
<li>out_channels 卷积核数量 K</li>
<li>kernel_size F</li>
<li>stride S</li>
<li>padding P</li>
</ul>
<p>计算：</p>
<ul>
<li><p>==<span class="math inline">\(M_1=\lfloor \frac{M_0+2P-F}{S}\rfloor+1\)</span>==</p></li>
<li><p>==<span class="math inline">\(参数量=(F^2D + 1)K\)</span>​，+1为偏置项，每个卷积核一个==</p></li>
</ul>
<p>1x1卷积：</p>
<ul>
<li>调节通道数：由于1x1卷积并不会改变高和宽，改变通道的第一个最直观的结果，就是可以将原本的数据量进行增加或者减少。</li>
<li>增加非线性：1x1卷积核，可以在保持特征图尺度不变的(即不改变)的前提下大幅增加非线性特性（利用后接的非线性激活函数如ReLU）。 非线性允许网络学习更复杂的功能，并且使得整个网络能够进一步加深。</li>
<li>跨通道信息交互：使用1x1卷积核，实现降维和升维的操作其实就是channel间通道信息的线性组合变化。</li>
<li>减少参数：前面所说的降维，其实也是减少了参数，因为特征图少了，参数也自然跟着就减少,相当于在特征图的通道数上进行卷积，压缩特征图，二次提取特征，使得新特征图的特征表达更佳。</li>
</ul>
<p>卷积方式：</p>
<ul>
<li>窄卷积：S=1 P=0 输出M-F+1</li>
<li>宽卷积：S=1 P=F-1 输出M+F-1</li>
<li>等宽卷积：S=1 P=(F-1)/2 输出M</li>
<li>转置卷积：低维特征映射到高维特征</li>
<li>空洞卷积：dilation</li>
</ul>
<h2 id="池化">池化</h2>
<p>向下采样Subsampling不会改变需要识别的目标，让图像变小了，需要更少的数据描述一个图像。</p>
<p>计算：</p>
<ul>
<li><span class="math inline">\(输出尺寸=向下取整(\frac{M-F}{S})+1\)</span></li>
<li><span class="math inline">\(输出维度=D\)</span></li>
</ul>
<h2 id="卷积网络结构">卷积网络结构</h2>
<p>卷积网络是由卷积层、汇聚层、全连接层交叉堆叠而成。</p>
<p>典型结构</p>
<figure>
<img src="../images/卷积网络结构.png" alt="卷积网络结构" /><figcaption aria-hidden="true">卷积网络结构</figcaption>
</figure>
<h2 id="经典cnn">经典CNN</h2>
<ul>
<li>LeNet5</li>
<li>AlexNet</li>
<li>VGG16</li>
<li>GoogleNet（Inception网络）：在卷积网络中，如何设置卷积层的卷积核大小是一个十分关键的问题。在Inception网络中，一个卷积层包含多个不同大小的卷积操作，称为Inception模块。Inception 模块同时使用1x1、3x3、5x5等不同大小的卷积核，并将得到的特征映射在深度上拼接(堆叠)起来作为输出特征映射。用多层的小卷积核来替换大的卷积核，以减少计算量和参数量。使用两层3x3的卷积来替换5x5的卷积；使用连续的nx1和1xn来替换nxn的卷积。</li>
<li>ResNet：残差网络(Residual Network，ResNet)是通过给非线性的卷积层增加直连边的方式来提高信息的传播效率，假设在一个深度网络中，我们期望一个非线性单元(可以为一层或多层的卷积层)f(x,θ)去逼近一个目标函数为h(x)。将目标函数拆分成两部分：恒等函数和残差函数。</li>
</ul>
<h2 id="文本cnn">文本CNN</h2>
<h3 id="textcnn">TextCNN</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TextCNN(nn.Module):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        n_vocab<span class="op">=</span><span class="va">None</span>,  <span class="co"># 词表长度</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        embed_dim<span class="op">=</span><span class="dv">300</span>,  <span class="co"># 词嵌入维度</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        num_filters<span class="op">=</span><span class="dv">256</span>,  <span class="co"># 卷积核数量</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        filter_sizes<span class="op">=</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>),  <span class="co"># 卷积核尺寸</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        dropout_rate<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        num_classes<span class="op">=</span><span class="va">None</span>  <span class="co"># 类别数</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    ):</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>(TextCNN, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.embedding <span class="op">=</span> nn.Embedding(</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            num_embeddings<span class="op">=</span>n_vocab,  <span class="co"># 词表长度</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            embedding_dim<span class="op">=</span>embed_dim,</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            padding_idx<span class="op">=</span>n_vocab<span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.convs <span class="op">=</span> nn.ModuleList([nn.Conv2d(<span class="dv">1</span>, num_filters, (k, embed_dim)) <span class="cf">for</span> k <span class="kw">in</span> filter_sizes])</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dropout <span class="op">=</span> nn.Dropout(dropout_rate)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.fc <span class="op">=</span> nn.Linear(num_filters <span class="op">*</span> <span class="bu">len</span>(filter_sizes), num_classes)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> conv_and_pool(x, conv):</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> F.relu(conv(x)).squeeze(<span class="dv">3</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> F.max_pool1d(x, x.size(<span class="dv">2</span>)).squeeze(<span class="dv">2</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        out <span class="op">=</span> <span class="va">self</span>.embedding(x[<span class="dv">0</span>])</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        out <span class="op">=</span> out.unsqueeze(<span class="dv">1</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        out <span class="op">=</span> torch.cat([<span class="va">self</span>.conv_and_pool(out, conv) <span class="cf">for</span> conv <span class="kw">in</span> <span class="va">self</span>.convs], <span class="dv">1</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        out <span class="op">=</span> <span class="va">self</span>.dropout(out)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        out <span class="op">=</span> <span class="va">self</span>.fc(out)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> out</span></code></pre></div>
<h3 id="siamese">Siamese</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SiaGRU(nn.Module):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        n_vocab<span class="op">=</span><span class="va">None</span>,  <span class="co"># 词表长度</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        embed_dim<span class="op">=</span><span class="dv">300</span>,  <span class="co"># 词嵌入维度</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        embed_dropout_rate<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        hidden_size<span class="op">=</span><span class="dv">300</span>,  <span class="co"># 隐藏状态h的特征数量</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        rnn_dropout_rate<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        num_layer<span class="op">=</span><span class="dv">2</span>,  <span class="co"># LSTM堆叠数量</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        device<span class="op">=</span><span class="st">&quot;cuda&quot;</span> <span class="cf">if</span> torch.cuda.is_available() <span class="cf">else</span> <span class="st">&quot;cpu&quot;</span>,</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        pad_size<span class="op">=</span>PAD_SIZE</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    ):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>(SiaGRU, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.name <span class="op">=</span> <span class="st">&#39;SiaGRU&#39;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.device <span class="op">=</span> device</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.embed_dim <span class="op">=</span> embed_dim</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.word_emb <span class="op">=</span> nn.Embedding(</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>            num_embeddings<span class="op">=</span>n_vocab,  <span class="co"># 词表长度</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            embedding_dim<span class="op">=</span><span class="va">self</span>.embed_dim,  <span class="co"># 词嵌入维度</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            padding_idx<span class="op">=</span>n_vocab<span class="op">-</span><span class="dv">1</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.embed_dropout_rate <span class="op">=</span> embed_dropout_rate</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_layer <span class="op">=</span> num_layer</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.gru <span class="op">=</span> nn.LSTM(</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.embed_dim,  <span class="co"># 词嵌入维度</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            hidden_size,  <span class="co"># 隐藏状态h的特征数量</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>            batch_first<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>            bidirectional<span class="op">=</span><span class="va">True</span>,  <span class="co"># 双向LSTM</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>            num_layers<span class="op">=</span><span class="dv">2</span>,  <span class="co"># 堆叠2个BiLSTM</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>            dropout<span class="op">=</span>rnn_dropout_rate</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.h0 <span class="op">=</span> <span class="va">self</span>.init_hidden((<span class="dv">2</span> <span class="op">*</span> <span class="va">self</span>.num_layer, <span class="dv">1</span>, hidden_size)).to(device)</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pred_fc <span class="op">=</span> nn.Linear(pad_size, <span class="dv">2</span>)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> init_hidden(size):</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        h0 <span class="op">=</span> nn.Parameter(torch.randn(size))</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        nn.init.xavier_normal_(h0)</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> h0</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward_once(<span class="va">self</span>, x):</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>        output, hidden <span class="op">=</span> <span class="va">self</span>.gru(x)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> output</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dropout(<span class="va">self</span>, v):</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> F.dropout(v, p<span class="op">=</span><span class="va">self</span>.embed_dropout_rate, training<span class="op">=</span><span class="va">self</span>.training)</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, q1, q2):</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 词嵌入：batch_size * seq_len =&gt; batch_size * seq_len * dim</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>        p_encode <span class="op">=</span> <span class="va">self</span>.dropout(<span class="va">self</span>.word_emb(q1))</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>        h_encode <span class="op">=</span> <span class="va">self</span>.dropout(<span class="va">self</span>.word_emb(q2))</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 词嵌入输入2个堆叠的BiLSTM</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        encoding1 <span class="op">=</span> <span class="va">self</span>.forward_once(p_encode)</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>        encoding2 <span class="op">=</span> <span class="va">self</span>.forward_once(h_encode)</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 计算相似度</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>        sim <span class="op">=</span> torch.exp(<span class="op">-</span>torch.norm(encoding1 <span class="op">-</span> encoding2, p<span class="op">=</span><span class="dv">2</span>, dim<span class="op">=-</span><span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)).squeeze(dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.pred_fc(sim)</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>        probabilities <span class="op">=</span> nn.functional.softmax(x, dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x, probabilities</span></code></pre></div>
<h2 id="卷积和全连接缺点">卷积和全连接缺点</h2>
<ul>
<li>文本作为一个整体处理</li>
<li>输入输出固定</li>
</ul>
<h1 id="dropout">Dropout</h1>
<p>当训练一个深度神经网络时，我们可以随机丟弃一部分神经元(同时丢弃其对应的连接边)来避免过拟合，这种方法称为丢弃法Dropout Method)。每次选择丢弃的神经元是随机的。</p>
<p>每做一次丢弃，相当于从原始的网络中采样得到一个子网络。每次迭代都相当于训练一个不同的子网络，这些子网络都共享原始网络的参数。那么，最终的网络可以近似看作集成了多个不同网络的组合模型。</p>
<h1 id="batch-normalization">Batch Normalization</h1>
<p>神经网络中应用BN时，是对神经网络输入数据的每一维分别进行归一化处理,使用多个输入样本的相同维数据计算出这一维数据的均值和方差,用于对本维数据进行归一化处理。</p>
<p>归一化可以有效提高训练效率的原因有以下几个方面:</p>
<p>更好的尺度不变性：在深度神经网络中，一个神经层的输入是之前神经层的输出。给定一个神经层l，它之前的神经层(1, ..., l-1)的参数变化会导致其输入的分布发生较大的改变。当使用随机梯度下降来训练网络时，每次参数更新都会导致该神经层的输入分布发生改变。越高的层，其输入分布会改变得越明显，就像一栋高楼， 低楼层发生一个较小的偏移，可能会导致高楼层较大的偏移。从机器学习角度来看，如果一个神经层的输入分布发生了改变，那么其参数需要重新学习，为了缓解这个问题，我们可以对每一个神经层的输入进行归一化操作，使其分布保持稳定。</p>
<p>更平滑的优化地形：逐层归一化一方面可以使得大部分神经层的输入处于不饱和区域，从而让梯度变大，避免梯度消失问题；另一方面还可以使得神经网络的优化地形(Optimization Landscape)更加平滑，以及使梯度变得更加稳定，从而允许我们使用更大的学习率，并提高收敛速度。</p>
<h1 id="layer-normalization">Layer Normalization</h1>
<p>解决batch normalization的问题：</p>
<ul>
<li>对batch size非常敏感。batch normalization的一个重要出发点是保持每层输入的数据同分布。</li>
<li>不适用于序列数据。</li>
</ul>
<p>层归一化：针对单个样本对每一层内的神经元进行归一化</p>
<h1 id="循环神经网络">循环神经网络</h1>
<p>循环神经网络通过使用带自反馈的神经元，能够处理任意长度的时序数据。</p>
<p>长程依赖问题：由于梯度爆炸或消失问题，实际上只能学习到短周期的依赖关系。</p>
<h2 id="lstm">LSTM</h2>
<figure>
<img src="https://zh-v2.d2l.ai/_images/lstm-3.svg?ynotemdtimestamp=1655558969941" alt="LSTM" /><figcaption aria-hidden="true">LSTM</figcaption>
</figure>
<p>在图中,Xt-1,Xt,Xt+1是三个神经元的输入,Xt表示的是当前细胞的输入。</p>
<p>ht表示的是当前细胞的输出。ht−1表示的是上一个cell的输出。ht加softmax即可作为真正输出，否则作为隐藏层。</p>
<p>σ表示Sigmoid激励函数。</p>
<p>tanh代表tanh激励函数。</p>
<p>×代表相乘操作,⊕代表相加操作,→代表向量传输。</p>
<p>LSTM关键：“细胞状态”：Ct</p>
<p>细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。LSTM使用“门”让信息选择性通过来控制“细胞状态”，来去除或者增加信息到细胞状态。包含一个sigmoid神经网络层和一个pointwise乘法操作。Sigmoid层输出0到1之间的概率值，描述每个部分有多少量可以通过。0代表“不许任何量通过”，1就指“允许任意量通过”。</p>
<p>第1步：决定从“细胞状态”中丢弃什么信息：遗忘门</p>
<p>第2步：决定放什么新信息到“细胞状态”中：输入门、候选记忆</p>
<p>Sigmoid层决定什么值需要更新，Tanh层创建一个新的候选值向量，上述2步是为状态更新做准备。</p>
<p>第3步：更新“细胞状态”</p>
<p>更新Ct-1为Ct，把旧状态与遗忘门输出相乘，丢弃掉需要丢弃的信息，加上输入门输出与候选记忆的乘积得到新的候选值。</p>
<p>第4步：基于“细胞状态”得到输出</p>
<p>首先运行一个sigmoid层来确定细胞状态的哪个部分将输出，接着用tanh处理细胞状态(得到一个在-1到1之间的值)，再将它和sigmoid门的输出相乘，输出确定输出的部分。</p>
<h2 id="gru">GRU</h2>
<figure>
<img src="https://zh-v2.d2l.ai/_images/gru-3.svg" alt="GRU" /><figcaption aria-hidden="true">GRU</figcaption>
</figure>
<p>门限循环单元( Gated Recurrent Unit，GRU) 是一种比LSTM更加简化的版本。在LSTM中，输入门和遗忘门是互补关系，因为同时用两个门比较冗余。GRU将输入门与和遗忘门合并成一个门：更新门(Update Gate)，同时还合并了记忆单元和神经元活性。GRU 模型中有两个门：更新门z和重置门r。更新门z用来控制当前的状态需要遗忘多少历史信息和接受多少新信息。重置门r用来控制候选状态中有多少信息是从历史信息中得到。</p>
<h2 id="srnn">SRNN</h2>
<p>堆叠循环神经网络(Stacked Recurrent Neural Network，SRNN)</p>
<h2 id="bilstm">BiLSTM</h2>
<p>双向循环神经网络(Bidirectional Recurrent Neural Network，Bi-RNN)</p>
<h1 id="医学自然语言处理任务">医学自然语言处理任务</h1>
<ul>
<li>病历文本数据挖掘</li>
<li>医疗知识库构建</li>
<li>病历检索</li>
</ul>
<ol type="1">
<li>分词</li>
<li>词性标注</li>
<li>实体识别</li>
<li>实体标准化：不规范输入、不同数据来源或不同人员在表达相同或类似概念时描述方式多种多样。</li>
<li>实体关系抽取</li>
<li>语义分析：电子病历中出现大量长句</li>
</ol>
<h2 id="文本分类">文本分类</h2>
<h2 id="文本匹配">文本匹配</h2>
<p>例如信息检索、自动问答、机器翻译、对话系统、复述问题。</p>
<h2 id="词性标注">词性标注</h2>
<h2 id="命名实体识别-ner">命名实体识别 NER</h2>
<p>命名实体(named entity, NE) ，命名实体识别实际的任务主要是识别人名、地名、机构名，是实体关系抽取、信息检索、机器翻译、间答系统等多种自然语言处理技术必不可少的组成部分。医学数据源中提取出特定类型的命名实体，主要有疾病、药物.症状、检查、手术操作、器官部位等。</p>
<p>类别：</p>
<ul>
<li>B-Person（人名的开始部分)</li>
<li>I- Person(人名的中间部分)</li>
<li>B-Organization(组织机构的开始部分)</li>
<li>l-Organization(组织机构的中间部分)</li>
<li>O(非实体信息)</li>
</ul>
<p>发射分数（状态分数）：来自BiLSTM层的输出，为一个词作为不同类别的可能性。</p>
<p>转移分数矩阵：所有类别间转移的分数。</p>
<h3 id="crf层">CRF层</h3>
<p>CRF层可以加入一些约束来保证最终预测结果是有效的。这些约束可以在训练数据时被CRF层自动学习得到。有了这些有用的约束，错误的预测序列将会大大减少。</p>
<p>可能的约束条件有:</p>
<ul>
<li>句子的开头应该是“B-"或“O”，而不是“I-”</li>
<li>"B-label1 I-label2 I-label3..."在该模式中，类别1,2,3应该是同一种实体类别。比如"B-Person I-Person"是正确的，而“ B-Person l-Organization"则是错误的。</li>
<li>"O I-label"是错误的，命名实体的开头应该是“B-" 而不是“I-"。</li>
</ul>
<p>CRF损失函数只需要两个得分：真实路径得分和所有可能路径总得分，真实路径得分的比例应随着训练不断增加。</p>
<h3 id="维特比算法">维特比算法</h3>
<p>HMM（隐马尔可夫模型）用到了2个假设：</p>
<ul>
<li>齐次马尔可夫性假设。t时刻的隐状态只和t-1时刻的隐状态相关，与其他时刻状态无关。</li>
<li>观测独立性假设。任意时刻的观测值依赖于该时刻的马尔可夫链的隐状态，与其他观测及隐状态无关。</li>
</ul>
<p>HMM的3大参数：</p>
<ul>
<li>π：初始隐状态概率向量</li>
<li>A：状态转移概率矩阵</li>
<li>B：发射概率（观测）矩阵</li>
</ul>
<p>维特比算法：在每一时刻，计算当前时刻落在每种隐状态的最大概率，并记录这个最大概率是从前一时刻哪一个隐状态转移过来的，最后再从结尾回溯最大概率，也就是最有可能的最优路径。</p>
<h2 id="关系抽取">关系抽取</h2>
<h2 id="情感分析">情感分析</h2>
<p>(Sentiment analysis)又称倾向性分析、意见抽取( Opinion extraction) 、意见挖掘( Opinion mining)、情感挖掘( Sentiment mining)、主观分析( Subjectivity analysis)等，它是对带有 情感色彩的主观性文本进行分析、处理、归纳和推理的过程。</p>
<ul>
<li>褒贬(中)分类：
<ul>
<li>一句话是褒义还是贬义</li>
</ul></li>
<li>细粒度分类：
<ul>
<li>喜怒悲恐惊(微博情绪指数系统)</li>
<li>将情感极性打分(例如1-5颗星)</li>
<li>褒贬中更细化(强褒义、褒义.些许褒义等)</li>
</ul></li>
<li>进阶分类：
<ul>
<li>一评价词 (Opinion)、 评价对象(Target)抽取</li>
<li>复杂观点抽取</li>
</ul></li>
</ul>
<h2 id="文本生成">文本生成</h2>
<p>如何构造样本训练RNN？切分语句，每一个切分作为输入，切分的下一个词作为输出。</p>
<p>主要挑战：</p>
<ul>
<li><p>一致性:内容应当准确忠实，不应语句前后矛盾、或与输入相悖</p></li>
<li><p>流畅性:语言应通顺易懂，不应不成句子</p></li>
<li><p>多样性:尽可能符合人类表达习惯，表达不应过于单一，尽可能提现情感倾向</p></li>
</ul>
<h2 id="文本摘要">文本摘要</h2>
<h2 id="问答系统">问答系统</h2>
<h2 id="看图说话">看图说话</h2>
<h1 id="seq2seq">Seq2Seq</h1>
<p>机器翻译(machine translation, MT)是用计算机把一种语言 (源语言, source language)翻译成另一种语言(目标语言, target language)的一门学科和技术。</p>
<p>机器翻译的困难</p>
<ul>
<li>自然语言中普遍存在的歧义和未知现象
<ul>
<li>句法结构歧义/词汇歧义/语用歧义..</li>
<li>新的词汇、术语、结构、语义..</li>
</ul></li>
<li>机器翻译不仅仅是字符串的转换
<ul>
<li>不同语言之间文化的差异</li>
<li>现有方法无法表示和利用世界知识和常识</li>
</ul></li>
<li>机器翻译的解不唯一，而且始终存在的人为的标准</li>
</ul>
<h2 id="编码器-解码器">编码器-解码器</h2>
<p>编码器读入源语言句子，生成源语言句子的向量表示；解码器基于源语言句子的向量表示生成目标语言句子。一体化模型(不存在独立的语言模型和翻译模型)</p>
<p>编码器的作用是把一个不定长的输入文本变换成一个定长的向量。</p>
<p>解码器的作用是把定长向量进行传递并输出不定长的输出文本。</p>
<p>形式化地，给定由t个单词组成的输入序列文本X = (x1, x2.... xt)，以及由t个单词组成的输出序列文本Y = (y1, y2.... yt)，“编码器 -解码器”框架就是使用最大似然估计方法，建模p(Y|X)。使用编码器中的循环神经网络计算得到输入序列的隐藏状态集合{h1, h2....ht}，解码器读取输入文本的状态，按序输出每个目标单词yj。</p>
<h3 id="搜索方式">搜索方式</h3>
<p>贪心搜索：在贪心策略中，遇到结束符就停止生成，例如:<START> he hit me with a pie <END></p>
<p>穷举搜索</p>
<p>束搜索：在束搜索策略中，会产生很多不同的语句。当一条语句遇到结束符，这个假设就停止。存储当前停止的假设，继续寻找其他语句。</p>
<h3 id="采样方式">采样方式</h3>
<p>随机采样：温度小的时候，倾向于使用常规词汇，而温度大的时候倾向于使用与上下文相关的词汇。</p>
<p>Top-K采样：挑选概率最高k个token， 然后重新过softmax 算概率，之后根据获得概率进行采样，接着进行下一步生成，不断重复。</p>
<p>Top-P采样：先设置一个概率界限，如p=0.9 ，然后从最大概率的token往下开始取，同时将概率累加起来，当取到大于等于p也就是0.9 时停止。</p>
<h2 id="训练方式">训练方式</h2>
<h3 id="free-running">Free running</h3>
<p>将解码器的猜测作为每个下一个输入。（预测时只能Free running）</p>
<h3 id="teacher-forcing">Teacher forcing</h3>
<p>将实际目标输出作为每个下一个输入，而不是将解码器的猜测用作下一个输入。使用Teacher forcing会使其更快地收敛。</p>
<h3 id="scheduled-sampling">scheduled sampling</h3>
<p>每一步以概率p靠自己上一步的输入来预测，以概率1-p根据老师的提示来预测</p>
<h2 id="attention">Attention</h2>
<figure>
<img src="../images/attention.png" alt="attention" /><figcaption aria-hidden="true">attention</figcaption>
</figure>
<p>==<span class="math inline">\(Attention(Q, K, V)=SoftMax(\frac{QK^T}{\sqrt{d_k}})V\)</span>==，<span class="math inline">\(d_k\)</span>表示K的维度</p>
<p><span class="math inline">\(d_k\)</span>较大时，向量内积容易取很大的值（query和key向量中的元素都是相互独立的均值为0，方差为1的随机变量，那么这两个向量的内积的均值为0，而方差为<span class="math inline">\(d_k\)</span>），SoftMax函数梯度很小趋于0。</p>
<p>除以<span class="math inline">\(\sqrt{d_k}\)</span>使得方差稳定到1，SoftMax的梯度不至于太小，有效控制了梯度消失问题。</p>
<h1 id="transformer">Transformer</h1>
<figure>
<img src="https://zh-v2.d2l.ai/_images/transformer.svg" alt="transformer" /><figcaption aria-hidden="true">transformer</figcaption>
</figure>
<p>Transformer包含一个编码器encoder和一个解码器decoder。</p>
<ul>
<li>编码器encoder包含一组6个相同的层Layer，每层包含两个子层Sublayer：
<ul>
<li>第一个子层是一个多头自注意力multi-head self attention层。</li>
<li>第二个子层是一个简单的全连接层。</li>
<li>每个子层都使用残差直连，并且残差直连之后跟随一个layer normalization。</li>
</ul></li>
<li>解码器decoder也包含一组6个相同的层Layer，但是每层包含三个子层Sublayer：
<ul>
<li>第一个子层也是一个多头自注意力multi-head masked self attention 层。</li>
<li>第二个子层是一个多头注意力multi-head attention层，用于捕获decoder output和encoder output之间的attention。</li>
<li>第三个子层是一个简单的全连接层。</li>
<li>每个子层都使用残差直连，并且残差直连之后跟随一个layer normalization。</li>
</ul></li>
</ul>
<h2 id="位置编码">位置编码</h2>
<p>在处理词元序列时，循环神经网络是逐个的重复地处理词元的，而自注意力则因为并行计算而放弃了顺序操作。为了使用序列的顺序信息，可以通过在输入表示中添加位置编码（positional encoding）来注入绝对的或相对的位置信息。位置编码不是模型架构的一部分，而只是预处理的一部分。生成的位置编码向量与每个词的嵌入向量大小维度相同。</p>
<p>常使用<strong>基于正弦函数和余弦函数的固定位置编码</strong>。</p>
<p>性质：</p>
<ul>
<li>两个位置编码的点积(dot product)仅取决于偏移量，也即两个位置编码的点积可以反应出两个位置编码间的距离。</li>
<li>位置编码的点积是无向的</li>
</ul>
<h2 id="self-attention">Self-Attention</h2>
<figure>
<img src="../images/self-attention.png" alt="self-attention" /><figcaption aria-hidden="true">self-attention</figcaption>
</figure>
<p>若更换输入X的顺序：Query、Key向量、Value向量和输出向量没有发生变化，只是顺序发生变化</p>
<h2 id="multi-head-attention">Multi-head Attention</h2>
<p>Multi-head Attention的本质是，在参数总量保持不变的情况下，将同样的query, key, value映射到原来的高维空间的不同子空间中进行attention的计算，在最后一步再合并不同子空间中的attention信息。</p>
<p>这样降低了计算每个head的attention时每个向量的维度，在某种意义上防止了过拟合；由于Attention在不同子空间中有不同的分布，Multi-head Attention实际上是寻找了序列之间不同角度的关联关系，并在最后concatenation这一步骤中，将不同子空间中捕获到的关联关系再综合起来。</p>
<p>多头保证了transformer可以注意到不同子空间的信息，捕捉到更加丰富的特征信息。</p>
<h2 id="masked-attention">Masked Attention</h2>
<p>为了使得decoder不能看见未来的信息。也就是对于一个序列，在time_ step为t的时刻，我们的解码输出应该只能依赖于t时刻之前的输出，而不能依赖t之后的输出。因此我们需要想一个办法，把t之后的信息给隐藏起来。</p>
<h1 id="自回归与非自回归建模">自回归与非自回归建模</h1>
<figure>
<img src="../images/自回归与非自回归.png" alt="自回归与非自回归" /><figcaption aria-hidden="true">自回归与非自回归</figcaption>
</figure>
<p>自回归：</p>
<p>优点：</p>
<ul>
<li>使用条件概率链式分解输出序列的联合分布，分解后的每项条件概率的分布更加简单，更容易被模型建模和拟合。</li>
<li>自回归建模方式模仿了序列产生的本质。</li>
<li>不需要显式建模源序列和目标序列之间的长度关系。</li>
<li>生成的效果较好（目前大多数序列生成任务的最好模型都是自回归的）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在生成序列时需要逐步生成，使得生成速度较慢，无法高效利用硬件的并行性。</li>
<li>在训练和生成时存在一定的差距（训练时用真实的上一时间步输出作为下一个时间步输入，而生成时使用模型上一时间步生成的输出作为下一个时间步输入）</li>
</ul>
<p>非自回归：</p>
<p>优点：</p>
<ul>
<li>一次性并行生成序列，而不需要逐步生成，充分利用了硬件的并行性，具有较快的生成速度。</li>
<li>直接建模联合分布，在训练和生成时均使用的输入数据一致,因此训练和生成差距较小。</li>
<li>建模方式简单，模型逻辑简单。</li>
</ul>
<p>缺点：</p>
<ul>
<li>联合分布通常具有多峰性(multimodal)，即对于一个X，可能存在多个合理的Y，大多数的损失函数难以刻画一个联合分布的多峰性，导致生成序列会存在过渡平滑(over-smoothing)问题。</li>
<li>跨模态翻译时，存在源序列和目标序列长度不一致问题。</li>
<li>在大多数任务中，性能上仍较难超过最好的自回归模型。</li>
</ul>
<h1 id="机器翻译评价标准">机器翻译评价标准</h1>
<h2 id="困惑度">困惑度</h2>
<p>困感度(Perplexity)是信息论的一个概念，可以用来衡量一个分布的不确定性。给定一个测试文本集合，一个好的序列生成模型应该使得测试集合中的句子的联合概率尽可能高。</p>
<p>困惑度可以衡量模型分布与样本经验分布之间的契合程度。<strong>困惑度越低则两个分布越接近</strong>。</p>
<p>困感度是与语料有关，两种语 言模型只有在使用相同评价语料的情况下才可以比较困惑度。</p>
<h2 id="belu">BELU</h2>
<p>BLEU (Bilingual Evaluation Understudy)是衡量模型生成序列和参考序列之间的N元词组(N-Gram)的重合度，最早用来评价机器翻译模型的质量，目前也广泛应用在各种序列生成任务中。</p>
<p>重合度越高越好，BELU分值0~1，越高译文质量越好。</p>
<h1 id="迁移学习">迁移学习</h1>
<p>把在某个领域获取的知识迁移到对另一个领域的学习中，也就是举一反三</p>
<ul>
<li>大数据与少标注之间的矛盾：迁移数据标注</li>
<li>大数据与弱计算之间的矛盾：模型迁移</li>
<li>普适化模型与个性化需求之间的矛盾：自适应学习</li>
<li>特定应用的需求：相似领域知识迁移</li>
</ul>
<p>迁移学习目的是借助一个源数据集来学习目标数据集的一个预测函数。</p>
<p>我们按照学习方法把迁移学习分成样本迁移、特征迁移、模型迁移和关系迁移四个类别：</p>
<ul>
<li>样本迁移：“各取所需”：剔除可能产生误导的样本；而对于特征相似、对任务有帮助的样本，则让其扩充训练数据，充分做到物尽其用。</li>
<li>特征迁移：通过引入源数据特征来帮助完成目标数据特征域的机器学习任务。
<ul>
<li>特征迁移通常假设源域和目标域间有一些交叉特征，是从共同的特征空间的角度迁移知识。</li>
</ul></li>
<li>模型迁移：从源域和目标域中找到他们之间共享的参数信息，以实现迁移的方法。
<ul>
<li>这种迁移方式要求的假设条件是源域中的数据与目标域中的数据可以共享一些模型的参数。</li>
</ul></li>
<li>关系迁移：源域和目标数据域之间关系的相似性，通过从源领域挖掘与目标数据相关的关系模式，帮助在目标数据上进行机器学习任务。</li>
</ul>
<h1 id="多任务学习">多任务学习</h1>
<p>多任务学习(Multi-task Learning)是指同时学习多个相关任务，让这些任务在学习过程 中共享知识，利用多个任务之间的相关性来改进模型在每个任务上的性能和泛化能力。</p>
<ul>
<li>硬共享模式：让不同任务的神经网络模型共同使用一些共享模块(一般是低层)来提取一些通用特征， 然后再针对每个不同的任务设置一些私有模块(一般是高层)来提取一些任务特定的特征。</li>
<li>软共享模式：不显式地设置共享模块，但每个任务都可以从其他任务中“窃取”一些信息来提高 自己的能力，窃取的方式包括直接复制使用其他任务的隐状态，或使用注意力机制来主动选取有用的信息。</li>
<li>层次共享模式：一般神经网络中不同层抽取的特征类型不同，低层一般抽取一些低级的局部特征，高层抽取一些高级的抽象语义特征，因此如果多任务学习中不同任务也有级别高低之分，那么一个合理的共享模式是让低级任务在低层输出，高级任务在高层输出。</li>
<li>共享-私有模式：一个更加分工明确的方式是将共享模块和任务特定(私有)模块的责任分开， 共享模块捕捉一些跨任务的共享特征，而私有模块只捕捉和特定任务相关的特征，最终的表示由共享特征和私有特征共同构成。</li>
</ul>
<p>多任务学习的流程可以分为两个阶段:</p>
<ul>
<li>联合训练阶段：每次迭代时，随机挑选一个任务，然后从这个任务中随机选择一些训练样本，计算梯度并更新参数。</li>
<li>单任务微调阶段：基于多任务学习得到的参数，分别在每个单独任务进行微调(Fine-Tuning)。其中单任务精调阶段为可选阶段。当多个任务的差异性比较大时，在每个单任务上继续优化参数可以进一步提升模型能力。</li>
</ul>
<p>多任务学习通常可以获得比单任务学习更好的泛化能力，主要有以下几个原因:</p>
<ul>
<li>多任务学习在多个任务的数据集上进行训练，比单任务学习的训练集更大，由于多个任务之间有一定的相关性，因此多 任务学习相当于是一种隐式的数据增强，可以提高模型的泛化能力。</li>
<li>多任务学习中的共享模块需要兼顾所有任务，这在一定程度上避免了模型过拟合到单个任务的训练集，可以看作一 种正则化。</li>
<li>既然一个好的表示通常需要适用于多个不同任务，多任务学习的机制使得它会比单任务学习获得更好的表示。</li>
<li>在多任务学习中， 每个任务都可以“选择性”利用其 他任务中学习到的隐藏特征，从而提高自身的能力。</li>
</ul>
<h1 id="预训练模型">预训练模型</h1>
<p>静态词向量的缺点：</p>
<ul>
<li>难以表达一词多义。</li>
<li>难以表达不同的语法或语义信息。</li>
<li>词向量是静态的，无法根据上下文进行调整。</li>
<li>词向量表示只有一个向量，糅合了太多信息，粒度较粗。</li>
</ul>
<p>词向量模型需要解决两个问题:</p>
<ul>
<li>词使用的复杂特性，如句法和语法。</li>
<li>如何在具体的语境下使用词，比如多义词的问题。</li>
</ul>
<h2 id="elmo">ELMo</h2>
<p>Embeddings from Language Models 基于语言模型的词嵌入</p>
<p>ELMo世界里，预训练好的模型不再只是向量对应关系，而是一个训练好的模型。使用时，将一句话或一段话输入模型， 模型会根据上下文来推断每个词对应的词向量。这样做之后明显的好处之一就是对于多义词，可以结合前后语境对多义词进行理解。</p>
<p>ELMO的结构：由一层input层和两层LSTM组合而成的</p>
<p>ELMO预训练：ELMO的三层每一层都有一个输出，将这三层的输出按比例相加后即为所得vector。 这个比例是模型学习得到的。得到加权后的向量后，如何使用取决于任务的效果。</p>
<h2 id="bert">BERT</h2>
<p>Bidirectional Encoder Representations from Transformers 基于Transformer的双向编码器表示</p>
<p>BERT结构：只有编码器的transformer</p>
<p>BERT输入：</p>
<ul>
<li>在BERT中，永远都将第一个位置输入分类提示符[CLS],如果执行的是分类任务,第一个位置最终会输出一个向量，作为分类依据。对于任何任务, BERT的输入永远都是将-对句子放在同一个序列中，无论这对句子是真正连续的上下文还是随机拼接的. BERT句子和句子之间用分隔符[SEP]隔开，在结尾也要加上一个[SEP]。</li>
<li>加入额外的片段嵌入</li>
<li>位置编码可学习</li>
</ul>
<p>BERT预训练：</p>
<ul>
<li>带掩码的语言模型：Transformer的编码器是双向，标准语言模型要求单向。带掩码的语言模型每次随机(15%概率)将一些词元换成<mask>因为微调任务中不出现<mask>：80%概率下，将选中的词元变成<mask>、10%概率下换成一个随机词元、10%概率下保持原有的词元</li>
<li>下一句子预测：预测一个句子对中两个句子是不是相邻。训练样本中：50%概率选择相邻句子对、50%概率选择随机句子对，将<cls>对应的输出放到一个全连接层来预测。</li>
</ul>
<p>BERT微调：</p>
<ul>
<li>句子分类：将<cls>对应的向量输入到全连接层分类。</li>
<li>命名实体识别：将非特殊词元放进全连接层分类</li>
<li>文本区间预测（给定问题和一段话，预测答案在这段话中的位置）：对片段中的每个词元预测它是不是回答的开头或结束</li>
</ul>
<h2 id="gpt">GPT</h2>
<p>Generative Pre-Training</p>
<p>GPT结构：只有解码器的transformer</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-06-30T16:00:00.000Z" itemprop="datePublished">2022/07/01</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI-NLP/" rel="tag">AI - NLP</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-自然语言处理重点"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E9%87%8D%E7%82%B9/">自然语言处理重点</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="大纲">大纲</h1>
<p>NLP基础与机器学习</p>
<ul>
<li>NLP的基本任务（给予描述、说出是哪种任务）</li>
<li>机器学习评价指标：ACC、F1（怎么算的）</li>
<li>中文分词（有哪些方法）</li>
</ul>
<p>词向量表示</p>
<ul>
<li>离散表示
<ul>
<li>OneHot</li>
<li>Bag of Words： TF-IDF（怎么计算）</li>
<li>N-gram：数据平滑</li>
<li>优缺点</li>
</ul></li>
<li>分布式表示
<ul>
<li>分布式假设</li>
<li>word2vec：
<ul>
<li>skip-gram、CBOW</li>
<li>负采样、层次SoftMax</li>
</ul></li>
<li>FastText</li>
<li>Glove</li>
</ul></li>
</ul>
<p>CNN</p>
<ul>
<li>卷积怎么扩大感受野</li>
<li>参数计算（给予输入算输出、算参数量）</li>
<li>TextCNN（结构，用PyTorch如何写）</li>
</ul>
<p>RNN</p>
<ul>
<li>梯度消失、梯度爆炸（如何解决）</li>
<li>LSTM结构（重点、为什么能够避免上述问题）</li>
<li>GRU结构（了解）</li>
</ul>
<p>Seq2Seq</p>
<ul>
<li>Seq2Seq结构（encoder、decoder）</li>
<li>解码方式</li>
<li>训练和推理（如何训练和测试、训练和测试为什么不一致）</li>
<li>Seq2Seq+Attention结构（在哪里加Attention）</li>
</ul>
<p>transformer</p>
<ul>
<li>transformer结构（部分去除后补充完整）</li>
<li>Self Attention、multi-head Attention、Mask Self Attention（区别）</li>
<li>Layer Normalization</li>
<li>残差连接</li>
</ul>
<p>BERT</p>
<ul>
<li>迁移学习、多任务学习</li>
<li>ELMO、BERT、GPT结构</li>
<li>BERT、ELMO的训练任务、使用方法</li>
</ul>
<h1 id="选择2x10">选择2’x10</h1>
<p>假设有一个5层的神经网络，4GB显存3小时完成训练，单个数据2s，现变幻架构，当评分是0.2和0.3时，分别在第二层和第四层添加dropout，新架构所用时间是多少？</p>
<p>会使用哪项技术来调整超参来最小化损失函数？</p>
<p>指出正确的训练测试代码</p>
<h1 id="判断2x5">判断2’x5</h1>
<p>某个词在文章中的TF-IDF越大，那么一般而言这个词在这篇文章的重要性越高。【对】</p>
<p>混沌度是一种常见的应用在处理NLP问题过程中的评估技术，混沌度越低越好。【对】</p>
<p>循环神经网络模型参数的数量随文本长度的增加而增长。【错，参数量不变】</p>
<h1 id="填空2x5">填空2’x5</h1>
<p>词向量的评价方法：</p>
<blockquote>
<p>【类比推理】、【相似度评价】</p>
</blockquote>
<p>seq2seq两种训练方式：</p>
<blockquote>
<p>【Teacher forcing】和【Free running】</p>
</blockquote>
<p>LSTM中遗忘门的激活函数：</p>
<blockquote>
<p>【sigmoid】</p>
</blockquote>
<p>机器翻译的评价标准：</p>
<blockquote>
<p>【困惑度】、【BELU】</p>
</blockquote>
<p>BERT的三个输入：</p>
<blockquote>
<p>【词嵌入（包括token）】、【片段嵌入】、【位置嵌入】</p>
</blockquote>
<p>迁移学习的分类：</p>
<blockquote>
<p>【样本迁移】、【特征迁移】、【模型迁移】、【关系迁移】</p>
</blockquote>
<p>多任务学习四种共享模式：</p>
<blockquote>
<p>【硬共享模式】、【软共享模式】、【层次共享模式】、【共享-私有模式】</p>
</blockquote>
<p>多任务学习的两个阶段：</p>
<blockquote>
<p>【联合训练阶段】、【单任务微调阶段】</p>
</blockquote>
<h1 id="简答10x6">简答10’x6</h1>
<p>Word2vec包含哪两种模型？并简述其基本思想</p>
<blockquote>
<p>word2vec包含跳字模型(skip-gram)和连续词袋(CBOW)模型。</p>
<p>连续词袋模型假设基于背景词来生成中心词。</p>
<p>跳字模型假设基于中心词来生成背景词。</p>
</blockquote>
<p>当词典很大时如何降低模型的计算量?</p>
<blockquote>
<p>负采样通过考虑同时含有正类样本和负类样本的相互独立事件来构造损失函数。其训练中每一步的梯度计算开销与采样的噪声词的个数线性相关。</p>
<p>层次SoftMax使用了二叉树，并根据根结点到叶结点的路径来构造损失函数。其训练中每一步的梯度计算开销与词典大小的对数相关。</p>
</blockquote>
<p>哪一种模型更能有效表示低频词?</p>
<blockquote>
<p>Hierarchical SoftMax（层次SoftMax）通过Huffman树结构来计算所有词的概率来定义目标，对低频词更友好。</p>
</blockquote>
<p>FastText在word2vec模型基础上进行了什么改进？</p>
<blockquote>
<p>FastText提出了子词嵌入法。它在word2vec中的跳字模型的基础上，将中心词向量表示成单词的子词向量之和。</p>
</blockquote>
<p>给出两种评价词嵌入模型性能的方法</p>
<blockquote>
<p>类比推理：考察用词向量来推断不同单词之间的语义关系的能力，在这个任务中，三个单词a, b和s被给出，目标是推断出第四个单词t满足“a和b, t和s是相似的”。</p>
<p>相似度评价：评估词向量模型在两个词之间的语义紧密度和相关性的能力，例如男人与女人，中国与北京这些词对之间的相似度。在词相似度任务上，一般采用斯皮尔曼等级相关系数ρ (Spearman's rank correlation coefficient)作为评价指标，它是衡量两个变量的依赖性的指标，利用单调方程评价两个统计变量的相关性，如果数据中没有重复值，并且当两个变量完全单调相关时，斯皮尔曼相关系数则为+1或-1。</p>
</blockquote>
<p>相比于全连接，CNN 为什么可以减少参数?</p>
<blockquote>
<p>局部连接</p>
<p>权重共享</p>
<p>空间或时间上的次采样</p>
</blockquote>
<p>神经网络中Dropout的作用?具体是怎么实现的?</p>
<blockquote>
<p>当训练一个深度神经网络时，我们可以随机丟弃一部分神经元(同时丢弃其对应的连接边)来避免过拟合，这种方法称为丢弃法Dropout Method)。每做一次丢弃，相当于从原始的网络中采样得到一个子网络。每次迭代都相当于训练一个不同的子网络，这些子网络都共享原始网络的参数。那么，最终的网络可以近似看作集成了多个不同网络的组合模型。</p>
</blockquote>
<p>解释批量归一化的原理</p>
<blockquote>
<p>更好的尺度不变性：在深度神经网络中，一个神经层的输入是之前神经层的输出，当使用随机梯度下降来训练网络时，每次参数更新都会导致该神经层的输入分布发生改变。越高的层，其输入分布会改变得越明显。对每一个神经层的输入进行归一化操作，使其分布保持稳定。</p>
<p>更平滑的优化地形：逐层归一化一方面可以使得大部分神经层的输入处于不饱和区域，从而让梯度变大，避免梯度消失问题；另一方面还可以使得神经网络的优化地形(Optimization Landscape)更加平滑，以及使梯度变得更加稳定，从而允许我们使用更大的学习率，并提高收敛速度。</p>
</blockquote>
<p>1x1卷积作用</p>
<blockquote>
<p>调节通道数：由于1x1卷积并不会改变高和宽，改变通道的第一个最直观的结果，就是可以将原本的数据量进行增加或者减少。</p>
<p>增加非线性：1x1卷积核，可以在保持特征图尺度不变的(即不改变)的前提下大幅增加非线性特性（利用后接的非线性激活函数如ReLU）。 非线性允许网络学习更复杂的功能，并且使得整个网络能够进一步加深。</p>
<p>跨通道信息：使用1x1卷积核，实现降维和升维的操作其实就是间通道信息的线性组合变化。</p>
<p>减少参数：前面所说的降维，其实也是减少了参数，因为特征图少了，参数也自然跟着就减少，相当于在特征图的通道数上进行卷积，压缩特征图，二次提取特征，使得新特征图的特征表达更佳。</p>
</blockquote>
<p>卷积神经网络如何用于文本分类任务?</p>
<blockquote>
<p>卷积神经网络的核心思想是捕捉局部特征，起初在图像领域取得了巨大的成功，后来在文本领域也得到了广泛的应用。对于文本来说，局部特征就是由若干单词组成的滑动窗口，类似于N-gram。卷积神经网络的优势在于能够自动地对N-gram特征进行组合和筛选，获得不同抽象层次的语义信息。由于在每次卷积中采用了共享权重的机制，因此它的训练速度相对较快，在实际的文 本分类任务中取得了非常不错的效果。</p>
</blockquote>
<p>给出一个防止过拟合的方法，是什么原理</p>
<blockquote>
<p>Dropout：见上</p>
</blockquote>
<p>RNN长程依赖问题</p>
<blockquote>
<p>RNN由于梯度爆炸或消失问题，实际上只能学习到短周期的依赖关系。</p>
</blockquote>
<p>如何解决梯度消失和梯度爆炸</p>
<blockquote>
<p>权重正则化</p>
<p>relu等激活函数</p>
<p>batch normalization</p>
<p>残差连接</p>
</blockquote>
<p>LSTM是如何实现长短期记忆的? (遗忘门和输入门的作用)</p>
<blockquote>
<p>LSTM主要通过遗忘门和输入门来实现长短期记忆。如果当前时间点的状态中没有重要信息，遗忘门f中各分量的值将接近1(f-&gt;1) ;输入门i中各分量的值将接近0(i-&gt;0）;此时过去的记忆将会被保存，从而实现长期记忆。</p>
<p>如果当前时间点的状态中出现了重要信息，且之前的记忆不再重要,则f-&gt;0， i-&gt;1;此时过去的记忆被遗忘，新的重要信息被保存，从而实现短期记忆。</p>
<p>如果当前时间点的状态中出现了重要信息，但旧的记忆也很重要，则f-&gt;1，i-&gt;1。</p>
</blockquote>
<p>LSTM里各部分使用了不同的激活函数，为什么?</p>
<blockquote>
<p>Sigmoid层决定什么值需要更新，Tanh层创建一个新的候选值向量。</p>
<p>Sigmoid的输出在0~1，符合门控的物理定义，且当输入较大或较小时，其输出会非常接近1或0，从而保证该门开或关，在生成候选记亿时。</p>
<p>tanh的输出在-1~-1，这与大多数场景下特征分布是0中心的吻合。此外，tanh函数在输入为0近相比Sigmoid函数有更大的梯度，通常使模型收敛更快。</p>
</blockquote>
<p>NER给定包含n个词的一句话，使用RNN对每一个词做人名，组织机构，其他命名实体识别任务，请简述其输出</p>
<blockquote>
<p>句子中的每个单词都被输入RNN，井且在每个时间步产生一个输出，对应于每个单词的预测标签的发射矩阵。</p>
</blockquote>
<p>NER中为什么要用CRF</p>
<blockquote>
<p>CRF层可以加入一些约束来保证最终预测结果是有效的，大大减少错误的预测序列。</p>
</blockquote>
<p>Seq2seq中为什么训练和预测时的Decoder不一样</p>
<blockquote>
<p>训练时使用Teacher forcing会使训练过程更快地收敛。</p>
</blockquote>
<p>Attention中为什么要除以<span class="math inline">\(\sqrt{d_k}\)</span></p>
<blockquote>
<p><span class="math inline">\(Attention(Q, K, V)=SoftMax(\frac{QK^T}{\sqrt{d_k}})V\)</span>，<span class="math inline">\(d_k\)</span>表示K的维度</p>
<p><span class="math inline">\(d_k\)</span>较大时，向量内积容易取很大的值（query和key向量中的元素都是相互独立的均值为0，方差为1的随机变量，那么这两个向量的内积的均值为0，而方差为<span class="math inline">\(d_k\)</span>），SoftMax函数梯度很小趋于0。</p>
<p>除以<span class="math inline">\(\sqrt{d_k}\)</span>使得方差稳定到1，SoftMax的梯度不至于太小，有效控制了梯度消失问题。</p>
</blockquote>
<p>Multi-head Attention的作用</p>
<blockquote>
<p>在某种意义上防止了过拟合。</p>
<p>多头保证了transformer可以注意到不同子空间的信息，捕捉到更加丰富的特征信息。</p>
</blockquote>
<p>Masked Attention的作用</p>
<blockquote>
<p>使得decoder不能看见未来的信息。在t时刻，解码输出应该只能依赖于t时刻之前的输出，而不能依赖t之后的输出。</p>
</blockquote>
<p>Yesterday turned out to be a terrible day. I overslept my alarm clock, and to make matters worse, my dog ate my homework. At least my dog seems happy.给定以上语句，使用RNN做情感分析得到是类别为：积极。请问什么原因?</p>
<blockquote>
<p>这句话的最后一个词是“happy"，属于非常积极的情绪词。由于我们只使用最终隐藏状态来计算输出，因此最终单词在分类中会产生太大的影响。此外，由于句子很长，早期时间步的信息可能由于消失梯度问题而无法保存。</p>
</blockquote>
<p>若更换Self-Attention中输入序列的顺序，其QKV和输出会发生什么变化</p>
<blockquote>
<p>Query、Key向量、Value向量和输出向量只是顺序发生变化</p>
</blockquote>
<p>ELMO结构及输入</p>
<blockquote>
<p>ELMO由一层input层和两层LSTM组合而成的。</p>
</blockquote>
<p>ELMO如何进行预训练，如何使用输出?</p>
<blockquote>
<p>ELMO的三层每一层都有一个输出，将这三层的输出按比例相加后即为所得vector。 这个比例是模型学习得到的。得到加权后的向量后，如何使用取决于任务的效果。</p>
</blockquote>
<p>为什么ELMO用两个单向的LSTM代替一个双向的LSTM</p>
<blockquote>
<p>用双向的模型结构去训练语言模型会导致“看到自己”或“看到答案”的问题。对于多层LSTM来说，涉及到序列前后信息泄露的问题，深层双向LSTM会被泄露上下文词语的位置信息，导致模型学到了不该学习的东西，也就失去了预训练的效果。</p>
</blockquote>
<p>多任务学习通常可以获得比单任务学习更好的泛化能力，主要是什么原因</p>
<blockquote>
<p>多任务学习在多个任务的数据集上进行训练，比单任务学习的训练集更大，由于多个任务之间有一定的相关性，因此多 任务学习相当于是一种隐式的数据增强，可以提高模型的泛化能力。</p>
<p>多任务学习中的共享模块需要兼顾所有任务，这在一定程度上避免了模型过拟合到单个任务的训练集，可以看作一种正则化。</p>
<p>既然一个好的表示通常需要适用于多个不同任务，多任务学习的机制使得它会比单任务学习获得更好的表示。</p>
<p>在多任务学习中， 每个任务都可以“选择性”利用其他任务中学习到的隐藏特征，从而提高自身的能力。</p>
</blockquote>
<p>设计一个文本匹配模型，给出输入、输出、损失函数</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-06-30T16:00:00.000Z" itemprop="datePublished">2022/07/01</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI-NLP/" rel="tag">AI - NLP</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-操作系统"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="操作系统">操作系统</h1>
<h2 id="概论">概论</h2>
<h3 id="常见操作系统名称">常见操作系统名称</h3>
<p>Ubuntu</p>
<p>Windows</p>
<p>UNIX</p>
<p>DOS</p>
<p>BSD</p>
<h3 id="操作系统类型">操作系统类型</h3>
<p>批处理：batch</p>
<ul>
<li>适用调度算法：先来先服务、最高响应比优先、高优先级优先</li>
</ul>
<p>交互式：interactive</p>
<ul>
<li>适用调度算法：多级反馈队列、时间片轮转、高优先级优先</li>
</ul>
<p>实时：real-time</p>
<p>分布式：distributed</p>
<p>个人计算机式</p>
<p>网络操作式</p>
<p>嵌入式</p>
<h3 id="操作系统的主要组成部分">操作系统的主要组成部分</h3>
<p>进程线程管理</p>
<p>内存管理</p>
<p>文件管理</p>
<p>设备管理</p>
<h3 id="操作系统管理的系统资源">操作系统管理的系统资源</h3>
<figure>
<img src="../images/系统资源.png" alt="系统资源" /><figcaption aria-hidden="true">系统资源</figcaption>
</figure>
<p>硬件、软件（代码、数据）</p>
<p>可共享资源（可以同时共享和互斥共享）：硬盘、CPU（中央处理单元，主要部件为：运算器、控制器、寄存器、高速缓存）、可重入代码</p>
<p>不可共享资源（必须互斥共享）：打印机、扫描仪、磁带机、投影仪、内存分配模块、时钟发生器</p>
<h4 id="寄存器">寄存器</h4>
<p>用户可见：数据寄存器、地址寄存器、条件码寄存器</p>
<p>用户不可见：程序状态字寄存器、程序计数寄存器、指令寄存器</p>
<h5 id="程序状态字psw">程序状态字（PSW）</h5>
<p>不在其中（列出部分页表标项信息）：驻留位（A）、保护位（P）、修改位（M）、访问位（R）</p>
<p>包含：CPU的工作状态代码、条件码、中断屏蔽码</p>
<h3 id="操作系统提供的内容">操作系统提供的内容</h3>
<p>计算机应用角度：人机交互接口</p>
<p>软件设计和开发角度：软件开发基础平台</p>
<p>计算机安全保护角度：第一道安全防线</p>
<p>计算机系统发展角度：虚拟机和扩展机</p>
<h3 id="操作系统的接口">操作系统的接口</h3>
<p>命令接口：提供组命令供用户直接或间接操作。根据作业的方式不同，命令接口又分为联机命令接口和脱机命令接口</p>
<p>程序接口：程序接口由一组系统调用命令组成，提供一组系统调用命令供用户程序使用</p>
<p>图形界面接口：通过图标、窗口、菜单、对话框及其他元素和文字组合在桌面上形成一个直观易懂，使用方便的计算机操作环境</p>
<h3 id="操作系统的状态转换">操作系统的状态转换</h3>
<p>CPU在运行时的状态：</p>
<ul>
<li>管态=内核态=特权态</li>
<li>目态=用户态=普通态</li>
</ul>
<p>内核态→用户态：修改程序状态字</p>
<p>用户态→内核态：调用访管指令</p>
<p>内核态指令：屏蔽中断、关中断</p>
<p>用户态指令：置移位方向标志</p>
<h3 id="中断和异常">中断和异常</h3>
<h4 id="中断">中断</h4>
<p>由外部事件引发，由软硬件相互配合实现</p>
<p>中断事件、中断源：引起中断的那些事件</p>
<p>中断请求：中断控制器向处理器发出的信号</p>
<p>中断响应：正在执行的程序暂停，请求处理，转而进入中断处理程序</p>
<p>中断断点：正在运行的程序的暂停点</p>
<p>例如：缓冲区满、鼠标操作、键盘输入、计时器归零</p>
<h4 id="异常">异常</h4>
<p>由正在执行的指令引发</p>
<p>例如：除以零、算术溢出、内存保护出错、虚拟储存中缺页、访问文件出错、对只读内存执行写指令、用户态执行内核态指令</p>
<h3 id="系统调用">系统调用</h3>
<p>传递参数方式：</p>
<ul>
<li>由陷人指令自带参数</li>
<li>通过有关通用寄存器来传递参数</li>
<li>专用堆栈区来传递参数</li>
</ul>
<p>传递返回值方式：</p>
<ul>
<li>通过专用堆栈区</li>
</ul>
<h2 id="进程与线程">进程与线程</h2>
<h3 id="进程必要组成部分">进程必要组成部分</h3>
<p>程序（代码）</p>
<p>数据</p>
<p>进程控制块</p>
<h3 id="进程控制块pcb">进程控制块（PCB）</h3>
<p>调度信息：</p>
<ul>
<li><p>进程标识符（进程名、进程号）</p></li>
<li><p>进程当前状态</p></li>
<li><p>进程优先级</p></li>
<li><p>存储信息</p></li>
<li><p>资源清单</p></li>
<li><p>家族关系</p></li>
<li><p>消息队列指针</p></li>
<li><p>进程队列指针</p></li>
<li><p>当前打开文件</p></li>
</ul>
<p>现场信息：</p>
<ul>
<li>程序状态字</li>
<li>时钟</li>
<li>界地址寄存器</li>
</ul>
<p>没有：用户栈、进程页表、动态链接库</p>
<h3 id="线程描述表">线程描述表</h3>
<p>线程ID</p>
<p>指令地址寄存器</p>
<p>处理器寄存器</p>
<p>硬件设备寄存器</p>
<p>栈现场状态</p>
<h3 id="线程操作">线程操作</h3>
<p>pthread_create，创建一个新线程。</p>
<p>pthread_join，以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果进程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。</p>
<p>pthread_yield，线程让出CPU。</p>
<p>pthread_exit，终止调用其的线程并返回一个指向某对象的指针。</p>
<p>pthread_mutex_init，创建一个互斥量。</p>
<h3 id="进线程状态">进线程状态</h3>
<figure>
<img src="../images/线程状态.png" alt="线程状态" /><figcaption aria-hidden="true">线程状态</figcaption>
</figure>
<h3 id="进线程调度">进线程调度</h3>
<p>引起调度：进程运行结束、运行的进程阻塞、运行的进程时间片到、进程所需资源没有准备好、进程出现错误</p>
<p>不会引起调度：创建新进程、进程唤醒后进入就绪队列</p>
<h3 id="进线程调度算法">进线程调度算法</h3>
<p>FCFS：先来先服务</p>
<p>SJF：短作业优先</p>
<p>HRRF：最高响应比优先</p>
<p>RR：时间片轮转</p>
<p>PF：高优先级优先</p>
<p>MLFQ：多级反馈队列</p>
<p>时间相关：先来先服务、短作业优先、最高响应比优先、时间片轮转</p>
<p>可采用进程调度算法：先来先服务、高优先级优先、时间片轮转、多级反馈队列</p>
<p>公平性：先来先服务、时间片轮转</p>
<h2 id="并发与同步">并发与同步</h2>
<h3 id="进程间的相互制约关系">进程间的相互制约关系</h3>
<figure>
<img src="../images/进程制约关系.png" alt="进程制约关系" /><figcaption aria-hidden="true">进程制约关系</figcaption>
</figure>
<h3 id="通信方式">通信方式</h3>
<p>共享内存：在相互通信的进程之间设一公共区域，一组进程向该公共区域写，另一组进程从公共区域读, 通过这种方式实现两组进程间的信息交换。</p>
<ul>
<li>优点：公共内存的互斥访问由程序员控制，相对较灵活</li>
</ul>
<p>消息缓冲：在内存中开辟若干区域，发送进程申请一个区域， 并将信息送入，然后把它插入到接收进程的相应队列中，之后通知接收进程。</p>
<ul>
<li>通信机制包含：消息缓冲区、消息队列首指针、同步互斥信号量和收发消息原语</li>
</ul>
<p>信箱：发送进程首先创建一个链接两个进程的通信机制， 然后把信息送入该机制;发送进程和接收进程不直接建立联系，而接收进程可以在任何时刻从该机制中取走信。</p>
<ul>
<li>优点：发送方和接收方不必直接建立联系</li>
</ul>
<p>管道：发送进程创建好连接两个进程的一个打开的共享文件，然后写入数据流；接收进程在需要时可以从该共享文件读出数据，写入和读出数据的长度是可变的。</p>
<ul>
<li>优点：同步与互斥都由操作系统自动进行，对用户是透明的</li>
</ul>
<h3 id="pv操作">PV操作</h3>
<p>P减V加</p>
<p>为了实现进程的互斥与同步</p>
<h3 id="信号量初始值">信号量初始值</h3>
<p>mutex = 1</p>
<p>empty = C</p>
<p>full = 0</p>
<h2 id="内存管理">内存管理</h2>
<h3 id="内存调度算法">内存调度算法</h3>
<p>最佳置换算法：OPT：置换以后不再需要的、或者在最长时间以后才会用到的页面</p>
<p>先进先出算法：FIFO：置换驻留在内存中时间最长的页面</p>
<p>最近最少使用置换算法：LRU：置换近期最长时间以来没被访问的页面（访问次数最多且访问位为0）</p>
<p>最近最不常用置换算法：LFU：根据一段时间内页面被使用的次数的多少选择调出的页面（只看访问次数最少）</p>
<p>最近末使用置换算法：NRU：（访问位和修改位为0）</p>
<p>第二次机会置换算法：检查进入内存时间最久页面的R位，如果是0，则置换该页；如果是1，就将R位清0，并把该页面放到链表的尾端，修改其进入时间，然后继续搜索</p>
<p>时钟算法：CLOCK：最近的一个时钟滴答中尽量置换一个没有被访问的和没有被修改过的页面</p>
<h3 id="内存碎片">内存碎片</h3>
<p>内部碎片：已经分配出去的内存中，没有得到利用的内存空间（页式、虚拟页式、段页式、固定分区：所有带页字的和固定分区）</p>
<p>外部碎片：内存空间大小无法满足分配要求的碎片（除了产生内部碎片的）</p>
<p>移动技术是将无法满足分配要求的外部碎片集中起来，使得集中后的未分配空间增大，从而满足分配要求，进而可以分配的技术，不能采用移动技术解决的碎片问题通常都是内部碎片的问题</p>
<h3 id="储存管理方法">储存管理方法</h3>
<p>固定分区</p>
<p>可变分区</p>
<ul>
<li>可变分区储存分配算法
<ul>
<li>最佳适配：空闲分区表按大小递增</li>
<li>最差适配：空闲分区表按大小递减</li>
<li>最先/首次适配：空闲分区表按地址递增</li>
<li>下次适配：上次分配后的下个地址</li>
<li>随机适配：纯随机</li>
</ul></li>
</ul>
<p>简单页式</p>
<p>虚拟页式：</p>
<ul>
<li>页面调入策略：请求调页、预调页</li>
<li>虚拟页式储存方案：
<ul>
<li>固定分配：为每一个进程分配固定数目的内存页面</li>
<li>可变分配：进程运行中，其内存页面可以动态增长或减少；为每个进程分配一定数目的内存页面</li>
<li>局部置换：进程运行中出现缺页，只能在本进程的页面中进行置换</li>
<li>全局置换：运行的进程当其页面不够时可以从系统中的任何进程处进行置换</li>
</ul></li>
</ul>
<p>简单段式</p>
<p>虚拟段式</p>
<p>段页式</p>
<p>可产生外部碎片：可变分区、段式</p>
<p>可进程部分交换：页式、段式、段页式</p>
<p>可进程整体交换：固定分区、可变分区</p>
<h3 id="页表表项信息">页表表项信息</h3>
<p>有效位（驻留位）</p>
<p>修改位</p>
<p>访问位（引用位）</p>
<p>页面修改、置换时：修改位、访问位</p>
<p>调入内存：内存块号、驻留位、访问位</p>
<p>淘汰：驻留位</p>
<h3 id="地址转换方式">地址转换方式</h3>
<p>基址寄存器和地址转换线路组合方式</p>
<p>重定位：逻辑地址→绝对地址</p>
<p>静态重定位：在装入一个程序时，把程序中的指令地址和数据地址全部转换成物理地址，这种转换工作是在程序开始前集中完成的，在程序执行过程中无须再进行地址转换。</p>
<p>动态重定位：在装入一个程序时，不进行地址转换，而是直接把程序装到分配的主区域中。在程序执行过程中，每当执行一条指令时都由硬件的地址转换机构转换成物理地址。 这种方式的地址转换是在程序执行时动态完成的，这种方式能保证一个程序在主存中被改变了存放位置后仍能正确执行。</p>
<h2 id="文件管理">文件管理</h2>
<h3 id="存储介质物理结构与存取方式">存储介质、物理结构与存取方式</h3>
<figure>
<img src="../images/存储.png" alt="存储" /><figcaption aria-hidden="true">存储</figcaption>
</figure>
<p>顺序结构的优点：</p>
<ul>
<li><p>文件的逻辑块号到物理块号的变换简单</p></li>
<li><p>支持顺序存取和随机存取</p></li>
<li><p>查找文件的速度较快</p></li>
</ul>
<p>顺序结构的缺点：</p>
<ul>
<li><p>文件内容不易动态增加</p></li>
<li><p>磁盘空间出现碎片较多</p></li>
</ul>
<p>链接结构的优点：</p>
<ul>
<li><p>适合顺序存取，<strong>不适合随机存取</strong></p></li>
<li><p>文件内容可以很容易动态增加</p></li>
<li><p>磁盘空间出现的碎片较少</p></li>
</ul>
<p>索引结构的优点：</p>
<ul>
<li><p>文件的逻辑块号到物理块号的变换简单</p></li>
<li><p>既适合顺序存取，又适合随机存取</p></li>
<li><p>文件内容可以很容易动态增加</p></li>
<li><p>文件查找速度较快</p></li>
</ul>
<h3 id="文件控制块fcb">文件控制块（FCB）</h3>
<p>包含以下的文件属性信息：</p>
<ul>
<li><p>文件标志和控制信息：文件名、文件号、文件类型、文件地址、文件属性、文件大小、文件创建时间、文件拥有者、文件访问权限</p></li>
<li><p>文件逻辑结构信息</p></li>
<li><p>文件物理结构信息</p></li>
<li><p>文件使用信息：文件建立日期、文件最后修改日期、文件最后访问日期、文件保存期限</p></li>
<li><p>文件管理信息</p></li>
</ul>
<p>不位于其中：文件修改次数、文件分配表、用户打开文件列表、文件目录、文件访问控制列表</p>
<h3 id="文件目录">文件目录</h3>
<p>所有文件的文件控制块有机地组织起来构成的一个有序集合</p>
<h3 id="磁盘磁臂调度算法">磁盘磁臂调度算法</h3>
<p>先来先服务调度：FCFS：按照访问请求的次序为各个进程服务。</p>
<p>电梯调度：SCAN：将依次升序访问比当前位置大的道，然后降序序访问比当前位置小的道。（也可指明方向）</p>
<p>循环扫描调度：C-SCAN：循环扫描算法修改了原扫描路径，将双向服务改为单向服务，即当磁头从外道移向内道时，如果经过的磁道有访问请求，则为其服务，直到最内端的请求服务完毕，然后立即快速回到最外边有请求的磁道(返程)，继续下一 个循环。</p>
<p>最短寻道优先调度：SSTF：根据磁头的当前位置，首先选择请求者中距磁头距离最短的请求为之服务。</p>
<h3 id="文件分类">文件分类</h3>
<p>按性质和用途：系统、程序库、用户</p>
<p>按保护方式：可执行、只读、读写、不保护</p>
<p>按存放时限：临时、永久、档案</p>
<p>按物理结构：顺序、链接、索引</p>
<p>按组织形式：普通、目录、特殊</p>
<h3 id="文件相关的操作顺序">文件相关的操作顺序</h3>
<p>创建文件：检查参数合法性→检查重名→查找FCB空闲位置→填写FCB</p>
<p>打开文件：查找FCB主部→检查打开方式→检查用户身份→填写进程打开文件表</p>
<p>修改文件：查找文件→修改FCB相关内容→置FCB为“非活跃"→写回磁盘</p>
<p>删除文件：查找文件→检查删除合法性→收回FCB资源→收回文件存储空间</p>
<h2 id="io设备管理">IO设备管理</h2>
<h3 id="io软件层次结构">IO软件层次结构</h3>
<p>用户IO软件层</p>
<p>与设备无关的操作系统软件层</p>
<p>设备驱动程序层</p>
<p>中断处理程序层</p>
<h3 id="io设备分类">IO设备分类</h3>
<p>按信息组织方式：块设备（如磁盘、磁带机）、字符设备（如键盘、终端、打印机）</p>
<p>按共享属性：独占设备（如打印机、扫描仪、时钟发生器）、共享设备（如串行通信端口、硬盘）</p>
<h3 id="设备管理的任务">设备管理的任务</h3>
<p>缓冲管理（匹配高低速设备）</p>
<p>设备分配（通过协调技术避免设备冲突）</p>
<p>设备处理</p>
<p>虚拟设备（提高并发度）</p>
<p>实现设备独立性</p>
<p>主要：缓冲管理、设备分配、设备处理，通过接口技术为用户提供一致的系统调用。</p>
<h3 id="io控制方式">IO控制方式</h3>
<p>程序直接控制：</p>
<ul>
<li>用户进程在等待键盘输入命令时，不断检测状态寄存器的完成位是否为1。</li>
<li>需要部件：设备状态寄存器、设备控制寄存器、设备数据缓冲区、地址译码器、地址总线和数据总线</li>
</ul>
<p>中断：</p>
<ul>
<li>CPU在配置I/O设备后，继续自己的工作，直到I/O设备准备好后，向CPU发送中断请求，再由CPU接管，提供服务。</li>
<li>需要部件：中断控制器、设备控制器、地址总线和数据总线</li>
</ul>
<p>DMA：</p>
<ul>
<li>控制器从CPU完全接管对总线的控制，数据交换不经过CPU，而直接在内存和I/O设备之间进行。</li>
<li>需要部件：DMA控制器、地址总线和数据总线</li>
</ul>
<p>通道：</p>
<ul>
<li>系统引入一个不同于CPU的特殊功能处理单元，它有自己的指令和程序，可以实现对外围设备的统一管理和外围设备与内存之间的数据传送。</li>
<li>需要部件：通道控制器、设备控制器、通道程序代码、地址总线和数据总线</li>
</ul>
<h3 id="适用于设备分配的算法">适用于设备分配的算法</h3>
<p>先来先服务</p>
<p>高优先级优先</p>
<h3 id="设备无关软件层功能">设备无关软件层功能</h3>
<p>设备驱动程序的同一接口</p>
<p>设备命名</p>
<p>设备保护</p>
<p>提供一个与设备无关的逻辑块</p>
<p>缓冲</p>
<p>存储设备的块分配</p>
<p>独占设备的分配和释放</p>
<p>出错处理</p>
<h2 id="死锁">死锁</h2>
<h3 id="预防死锁">预防死锁</h3>
<p>可以向输出缓冲区写数据</p>
<p>一次分配所有资源</p>
<p>有序分配资源</p>
<p>剥夺其他进程的资源</p>
<h3 id="避免死锁">避免死锁</h3>
<p>银行家算法</p>
<h3 id="产生死锁的原因">产生死锁的原因</h3>
<p>竞争资源引起进程死锁</p>
<ul>
<li>申请不同类型资源：P1拥有设备A，请求设备B；P2拥有设备B，请求设备A</li>
<li>申请相同类型资源：P1申请一页内存，P2申请一页内存；P1释放一页内存，P2释放一页内存</li>
<li>使用临时性资源：P1等待接收P2发来的信件Q后向P2发送信件R；P2 等待接收P1发来的信件R后向P1发送信件Q</li>
</ul>
<p>进程推进顺序不当引起死锁</p>
<ul>
<li>同步互斥机制使用不当：P1和P2先进行同步信号量P操作，再进行互斥信号量P操作</li>
</ul>
<h3 id="形成死锁的必要条件">形成死锁的必要条件</h3>
<p>资源<strong>互斥</strong>使用：没有采用SPOOLing技术的系统中，进程P1和P2同时申请使用同一台打印机</p>
<p><strong>请求和保持</strong>：进程P1拥有打印机并申请扫描仪</p>
<p>已分配资源<strong>不可剥夺</strong>：进程P1额外申请内存不成功，则持有原有的内存进入阻塞状态</p>
<p>资源请求形成<strong>循环等待</strong>：进程P1等待P2完成视频解压缩的信号，P2正等待P1发来的解压数据</p>
<h3 id="破坏形成死锁的必要条件">破坏形成死锁的必要条件</h3>
<p>互斥：采用SPOOLing技术、建设立交桥</p>
<p>请求和保持：采用给进程一次性分配其所需资源的方法、使用红绿灯</p>
<p>不可剥夺：若进程处于非运行状态时允许其他进程使用该进程经占用的资源、设置黄色网格缓冲区</p>
<p>循环等待：采用资源的按序分配方法、某一方向道路实行单向行驶</p>
<h3 id="解除死锁的方法">解除死锁的方法</h3>
<p>定时为进程设置还原点，若运行受阻则退回还原点</p>
<p>剥夺某些进程所占有的资源</p>
<p>撤消某些进程</p>
<p>重新启动系统</p>
<h3 id="哲学家进餐问题">哲学家进餐问题</h3>
<p>预防死锁：</p>
<ul>
<li>仅当某哲学家左右两边的筷子都可用时，允许他取筷子</li>
<li>最多允许4个哲学家可以同时申请进餐，取得筷子</li>
<li>奇数号的哲学家先取左边的筷子，偶数的则先取右边的筷子</li>
<li>给其中某一个哲学家增配1只筷子</li>
<li>为每位哲学家的左右两只筷子各设置一个信号量，哲学家同时对两个信号量执行P、V操作</li>
</ul>
<p>解除死锁：</p>
<ul>
<li>某一位哲学家主动放下右手的筷子</li>
<li>某哲学家暴力夺取邻近哲学家的筷子</li>
</ul>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-06-30T16:00:00.000Z" itemprop="datePublished">2022/07/01</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-信息安全"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">信息安全</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="des">DES</h2>
<p>Data Encryption Standard 数据加密标准</p>
<h2 id="pki">PKI</h2>
<p>Public Key Infrastructure 公钥基础设施</p>
<h2 id="ca">CA</h2>
<p>认证机构</p>
<h2 id="dos">DoS</h2>
<p>Denial of Service 拒绝服务攻击</p>
<h2 id="nat">NAT</h2>
<p>Network Address Translation 网络地址翻译</p>
<h2 id="dmz">DMZ</h2>
<p>Demilitarized Zone 隔离区/非军事区</p>
<h2 id="vpn">VPN</h2>
<p>Virtual Private Network 虚拟私有网络</p>
<h2 id="ids">IDS</h2>
<p>Intrusion Detection System 入侵检测系统</p>
<h2 id="drm">DRM</h2>
<p>Digital Rights Management 数字版权管理</p>
<h2 id="iaaspaassaas">IaaS、PaaS、SaaS</h2>
<p>基础设施级服务</p>
<p>平台级服务</p>
<p>软件级服务</p>
<h2 id="pdca">PDCA</h2>
<p>Plan、Do、Check、Act</p>
<h2 id="协议">协议</h2>
<ul>
<li>网络层协议：
<ul>
<li>TCP</li>
<li>UDP</li>
<li>ICMP</li>
<li>IGMP</li>
</ul></li>
<li>隧道协议：
<ul>
<li>PPTP：点对点隧道协议</li>
<li>L2TP：第二层隧道协议</li>
<li>IPSec：第三层隧道协议</li>
<li>SSL：安全套接层</li>
</ul></li>
</ul>
<h1 id="一信息安全概述">一、信息安全概述</h1>
<h2 id="信息安全-p2">1. 信息安全 P2</h2>
<blockquote>
<p>有哪几个方面</p>
</blockquote>
<ol type="1">
<li>完整性</li>
</ol>
<p>完整性是指未经授权不能修改数据的内容，保证数据的一致性。在网络传输和存储过程中，系统必须保证数据不被篡改、破坏和丢失。因此，网络系统有必要采用某种安全机制确认数据在此过程中没有被修改。</p>
<ol start="2" type="1">
<li>保密性</li>
</ol>
<p>保密性是指由于网络系统无法确认是否有未经投权的用户截取数据或非法使用数据，这就要求使用某种手段对数据进行保密处理。数据保密可分为网络传输保密和数据存储保密。对机密敏感的数据使用加密技术，将明文转化为密文，只有经过授权的合法用户才能利用密钥将密文还原成明文。反之，未经授权的用户无法获得所需信息。这就是数据的保密性。</p>
<ol start="3" type="1">
<li>可用性</li>
</ol>
<p>可用性是指信息可被授权者访问并按需求使用的特性，即保证合法用户对信息和资源的使用不会被不合理地拒绝。对可用性的攻击就是阻断信息的合理使用，例如，破坏系统的正常运行就属于这种类型的攻击。</p>
<ol start="4" type="1">
<li>不可否认性</li>
</ol>
<p>不可否认性是指建立有效的责任机制，防止网络系统中合法用户否认其行为，这一点在电子商务中是极其重要的。抗否认包含两个方面：</p>
<ul>
<li>数据来源的抗否认，为数据的接收者B提供数据的来源证据，使发送者A不能否认其发送过这些数据或不能否认发送数据的内容。</li>
<li>数据接收的抗否认，为数据的发送者A提供数据的交付证据，使接收者B不能否认其接收过这些数据或不能否认接收数据的内容。</li>
</ul>
<ol start="5" type="1">
<li>可控性</li>
</ol>
<p>可控性是指对信息的传播及内容具有控制能力的特性。授权机构可以随时控制信息的机密性，能够对信息实施安全监控。</p>
<h2 id="网络脆弱性-p5">2. 网络脆弱性 P5</h2>
<blockquote>
<p>有哪几个方面</p>
</blockquote>
<ol type="1">
<li>开放的网络环境</li>
</ol>
<p>互联网是一个无中心的、地位对等的自由网络，你和每个人都能互相连接，可怕之处在于每个人都能和你互相连接。</p>
<ol start="2" type="1">
<li>协议本身的缺陷</li>
</ol>
<p>网络传输离不开TCP/IP通信协议栈，每一层都有不同的漏洞，针对协议漏洞的攻击非常多。</p>
<ol start="3" type="1">
<li>操作系统的漏洞</li>
</ol>
<p>Windows、Linux、UNIX等多种类型网络操作系统都不可避免地存在诸多安全隐患，如非法存取、远程控制缓冲区溢出以及系统后门等称为操作系统漏洞。</p>
<h2 id="信息安全技术-p7-10">3. 信息安全技术 P7-10</h2>
<blockquote>
<p>有哪些技术</p>
</blockquote>
<p>信息安全技术涉及信息传输的安全、信息存储的安全以及对网络传输信息内容的审计三个方面。</p>
<p>为了保障数据传输的安全，需要采用<strong>数据传输加密技术</strong>、<strong>数据完整性鉴别技术</strong>。</p>
<p>为了保障信息存储的安全，需要进行<strong>数据备份</strong>、<strong>灾难恢复</strong>和<strong>保证终端安全</strong>。</p>
<p>信息内容审计则是实时地对进出内部网络的信息进行内部审计，以保证防止或追查可能的泄密行为。</p>
<ul>
<li>信息保密技术
<ul>
<li>信息加密技术</li>
<li>信息隐藏技术</li>
</ul></li>
<li>信息认证技术
<ul>
<li>数字签名</li>
<li>数据完整性保护：数据单元的完整性、数据单元序列的完整性</li>
<li>数据签名机制</li>
<li>鉴别交换机制：口令鉴别、数据加密鉴别、实物属性鉴别</li>
<li>身份认证</li>
</ul></li>
<li>访问控制技术
<ul>
<li>访问控制：主体、客体、访问策略</li>
<li>审计</li>
</ul></li>
<li>信息安全监测
<ul>
<li>入侵检测技术：入侵检测系统（IDS）</li>
</ul></li>
<li>信息内容安全</li>
</ul>
<h1 id="二物理安全">二、物理安全</h1>
<h2 id="物理安全-p14">4. 物理安全 P14</h2>
<blockquote>
<p>有哪几个方面</p>
</blockquote>
<p>物理安全主要包括以下几个方面：机房环境安全、通信线路安全、设备安全、电源安全。</p>
<p>物理安全包括实体安全和环境安全，它们是研究如何保护网络与信息系统物理设备，主要涉及网络与信息系统的机密性、可用性、完整性等属性。物理安全技术则用来解决两个方面问题，一方面是针对信息系统实体的保护；另一方面针对可能造成信息泄漏的物理问题进行防范。因此物理安全技术应该包括防盗、防火、防静电、防雷击、防信息泄漏、物理隔离等安全技术。另外，基于物理环境的容灾技术和物理隔离技术也属于物理安全技术范畴。</p>
<h1 id="三密码学基础与应用">三、密码学基础与应用</h1>
<h2 id="密码学基本概念-p29">5. 密码学基本概念 P29</h2>
<blockquote>
<p>明文密文、加密解密</p>
</blockquote>
<ul>
<li>明文消息（Plaintext）：未加密的原消息，简称明文。</li>
<li>密文消息（Ciphertext）：加密后的消息，简称密文。</li>
<li>加密（Encryption）：明文到密文的变换过程。</li>
<li>解密（Decryption）：密文到明文的恢复过程。</li>
<li>加密算法（Encryption Algorithm）：对明文进行加密时所采用的一组规则或变换。</li>
<li>解密算法（Decryption Algorithm）：对密文进行解密时所采用的一组规则或变换。</li>
<li>密码算法强度（Algorithm Strength）：对给定密码算法的攻击难度。</li>
<li>密钥（Key）：加解密过程中只有发送者和接收者知道的关键信息，分为加密密钥（Encryption Key）和解密密钥（ Decryption Key）。</li>
<li>密码分析（Cryptanalysis）：虽然不知道系统所用的密钥，但通过分析可能从截获的密文中推断出原来的明文，这一过程称为密码分析。</li>
<li>一个密码系统（或称为密码体制，Cryptosystem）由加密算法、解密算法、明文空间（全体明文的集合）、密文空间（全体密文的集合）和密钥空间（全体密钥的集合）组成。</li>
<li>密码学（Cryptology）是研究如何实现秘密通信的科学，包含密码编码学和密码分析学：
<ul>
<li>密码编码学（Cryptography）是研究对信息进行编码以实现信息隐蔽。</li>
<li>密码分析学（Cryptanalytics）是研究通过密文获取对应的明文信息。</li>
</ul></li>
</ul>
<h2 id="密码技术的基本应用-p30">*6. 密码技术的基本应用 P30</h2>
<blockquote>
<p>有哪些密码技术</p>
<p>数字签名</p>
<p>关注一下</p>
</blockquote>
<p>密码技术不仅用于对网上传送数据的加解密，也用于认证（认证信息的加解密）、数字签名、完整性以及SSL（安全套接字）、SET（安全电子交易）、S/MIME（安全电子邮件）等安全通信标准和IPSec安全协议中，因此密码技术是网络安全的基础。</p>
<p>其基本的应用如下：</p>
<ul>
<li><p>用加密来保护信息</p>
<p>利用密码变换将明文变换成只有合法者才能恢复的密文，这是密码的最基本的功能。利用密码技术对信息进行加密是最常用的安全交易手段。</p></li>
<li><p>采用密码技术对发送信息进行验证</p>
<p>为防止传输和存储的消息被有意或无意地篡改，采用密码技术对消息进行运算生成消息验证码（MAC），附在消息之后发出或与信息一起存储，对信息进行认证。它在票据防伪中具有重要应用（如税务的金税系统和银行的支付密码器）。</p></li>
<li><p>数字签名</p>
<p>在信息时代，电子信息的收发使过去所依赖的个人特征都被数字代替，数字签名的作用有两点：一是接收方可以鉴别发送方的真实身份，且发送方事后不能否认发送过该报文这一事实；二是发送方或非法发送者不能伪造、篡改报文。数字签名并非用手书签名的图形标志，而是采用双重加密的方法来防伪、防赖。根据采用的加密技术不同，数字签名有不同的种类，如私用密钥的数字签名、公开密钥的数字签名、只需签名的数字签名、数字摘要的数字签名等。</p></li>
<li><p>身份识别</p>
<p>当用户登录计算机系统或建立最初的传输连接时，用户需要证明他的身份，典型的方法是采用口令机制来确认用户的真实身份。此外，采用数字签名也能够进行身份鉴别，数字证书用电子手段来证实一个用户的身份和对网络资源的访问权限是网络正常运行所必需的。在电子商务系统中，所有参与活动的实体都需要用数字证书来表明自己的身份。</p></li>
</ul>
<h2 id="密码学的体制-p30">*7. 密码学的体制 P30</h2>
<blockquote>
<p>对称、非对称</p>
<p>关注一下</p>
</blockquote>
<p>按照明文加密方式的不同，可分为：</p>
<ul>
<li>流密码（Stream Cipher）：将明文消息按字符逐位地进行加密。</li>
<li>分组密码（Block Cipher）：将明文消息分组（每组含有多个字符）逐组地进行加密。</li>
</ul>
<p>按密钥使用的数量不同，可分为：</p>
<ul>
<li>对称密码体系（又称为单钥密码，Symmetric）：加密密钥和解密密钥相同，彼此之间很容易相互确定。
<ul>
<li>对称密码安全性高、速度快，适用于数据量较大的保密通信，缺点是随着网络规模扩大，密钥管理成为一个难点。</li>
</ul></li>
<li>非对称密码体系（又称为公钥密码，Asymmetric）：加密密钥（又称为公钥，Public Key） 和解密密钥（又称为私钥，Private Key）不同，从一个密钥很难推出另一个密钥，可将加密能力和解密能力分开，不需要通过专门的安全通道来传送密钥。大多数公钥密码属于分组密码。
<ul>
<li>公钥密码常用于数字签名、密钥分发等，缺点是算法比较复杂，加密解密速度慢，优点是简化了密钥管理的问题。</li>
</ul></li>
</ul>
<p>网络中的加密普遍采用对称密码和公钥密码相结合的混合密码体制，即加解密采用对称密码，密钥传送采用公钥密码，这样既解决了密钥管理的难题，又解决了加解密速度慢的问题。</p>
<h2 id="数据加密标准des-p33-38">8. 数据加密标准DES P33-38</h2>
<blockquote>
<p>DES、PGP看一看</p>
</blockquote>
<p>数据加密标准（Data Encryption Standard，DES）：明文分组长度为64b，密钥长度也为64b，其中每8b有一位奇偶校验位，因此有效密钥长度为56b，加密后产生64b的密文分组，其安全性依赖于密钥的保密程度。</p>
<p>加密分为三个阶段：</p>
<ul>
<li>首先是一个初始置换IP，用于重排64b的明文分组。</li>
<li>然后进行相同功能的16轮变换，第16轮变换的输出分左右两半，并被交换次序。</li>
<li>最后经过一个逆置换 <span class="math inline">\(IP^{-1}\)</span>，产生最终的64b密文。</li>
</ul>
<p>解密和加密使用同一算法，但子密钥使用的顺序相反。</p>
<p>著名的电子邮件安全软件PGP（Pretty Good Privacy）就采用了IDEA算法进行数据加密。</p>
<h2 id="rsa公钥密码体制-p39">9. RSA公钥密码体制 P39</h2>
<p>RSA密码体制是世界上应用最为广泛的公钥密码体制。RSA体制的安全性基于大整数分解的困难性，即已知两个大素数p和q，求 n = pq 是容易的，而由 n 求 p 和 q 则是困难的。</p>
<p>RSA算法包括密钥生成算法和加解密算法两部分。</p>
<p>密钥生成算法如下：</p>
<ol type="1">
<li>选择不同的大素数 p 和 q，计算 n = p · q，φ(n) = (p - 1)(q - 1)。
<ul>
<li>p、q、φ(n) 需要保密，由于 p、q 是大素数，故通过 n 分解得到十分困难。</li>
</ul></li>
<li>选择 e，满足 1 &lt; e &lt; p(n)，且 gcd (φ(n), e) = 1 即 e 不是 φ(n) 的因子， (n, e) 作为公钥公开。</li>
<li>通过计算 ed ≡ 1 mod φ(n)，且 e ≠ d，即 <span class="math inline">\(d = e^{-1}\; mod\; φ(n)\)</span>， (n, d) 作为私钥保密。</li>
</ol>
<figure>
<img src="../images/密钥生成算法.png" alt="密钥生成算法" /><figcaption aria-hidden="true">密钥生成算法</figcaption>
</figure>
<p>RSA加解密算法如下：</p>
<ul>
<li>RSA加密运算 <span class="math inline">\(c ≡ m^e(mod\; n)\)</span>，RSA解密运算 <span class="math inline">\(m ≡ c^d(mod\; n)\)</span>。加密时首先应对明文比特串分组，使得每个分组对应的十进制数小于 n，即分组长度小于 n。</li>
</ul>
<figure>
<img src="../images/RSA加解密算法.png" alt="RSA加解密算法" /><figcaption aria-hidden="true">RSA加解密算法</figcaption>
</figure>
<p>基于安全考虑，目前RSA密码体制使用的大素数至少要在512b以上。由于要进行大数的计算，RSA运算速度较慢，其软件实现大概要比DES慢100倍。</p>
<h2 id="公钥基础设施pki-p44">10. 公钥基础设施PKI P44</h2>
<blockquote>
<p>PKI、CA看一看</p>
</blockquote>
<p>公钥基础设施（Public Key Infrastructure，PKI），是基于公钥理论和技术解决数字证书问题的一整套方案。PKI的构建和实施主要围绕<strong>认证机构（CA）</strong>、<strong>证书和证书库</strong>、<strong>密钥备份及恢复系统</strong>、<strong>证书作废处理系统</strong>、<strong>证书历史档案系统</strong>和<strong>多PKI间的互操作性</strong>来进行。</p>
<p>认证机构（CA）是PKI的核心，负责发放、更新、撤销和验证证书。大型公钥基础设施往往包含多个CA，当一个CA相信其他的公钥证书时，也就信任该CA签发的所有证书。多数PKI中的CA是按照层次结构组织在一起的。在一个PKI中，只有一个根CA，通过这种方式用户总可以通过根CA找到一条连接任意一个CA的信任路径。不同的PKI体系之间存在互操作性问题。交叉认证的目的就是在多个PKI域之间实现互操作。交叉认证实现的方法有多种：</p>
<ul>
<li>桥接CA，即用一个第三方CA作为桥，将多个CA连接起来，成为一个可信任的统一体。</li>
<li>多个CA的根CA（RCA）互相签发根证书，这样当不同PKI域中的终端用户沿着不同的认证链检验认证到根时，就能达到互相信任的目的。</li>
</ul>
<h1 id="四网络攻击与安全防范">四、网络攻击与安全防范</h1>
<h2 id="网络攻击技术-p71">11. 网络攻击技术 P71</h2>
<ul>
<li>密码攻击技术</li>
<li>缓冲区溢出技术</li>
<li>DoS攻击技术</li>
<li>IP欺骗技术</li>
<li>网络嗅探技术</li>
</ul>
<h2 id="网络攻击阶段自动化-p71">*12. 网络攻击阶段自动化 P71</h2>
<blockquote>
<p>有哪几个阶段</p>
<p>考试重点</p>
</blockquote>
<p>自动化攻击一般涉及四个阶段：</p>
<ul>
<li><p>扫描阶段</p>
<p>攻击者采用各种新出现的扫描技术（隐藏扫描、安全扫描、智能扫描、指纹识别等）来推动扫描工具的发展，使得攻击者能够利用更先进的扫描模式来改善扫描效果，提高扫描速度。最近一个新的发展趋势是把漏洞数据同扫描代码分离出来并标准化，使得攻击者能自行对扫描工具进行更新。</p></li>
<li><p>渗透控制阶段</p>
<p>传统的植入方式，如邮件附件植入、文件捆绑植入，已经不再有效，因为现在人们普遍都安装了杀毒软件和防火墙。随之出现的先进的隐藏远程植入方式，如基于数字水印远程植人方式、基于动态链接库（DLL）和远程线程插入的植人技术，能够成功地躲避防病毒软件的检测将受控端程序植入到目的计算机中。</p></li>
<li><p>传播攻击阶段</p>
<p>以前需要依靠人工启动工具发起的攻击，现在发展到由攻击工具本身主动发起新的攻击。</p></li>
<li><p>攻击工具协调管理阶段</p>
<p>随着分布式攻击工具的出现，攻击者可以很容易地控制和协调分布在Internet上的大量已经部署的攻击工具。目前，分布式攻击工具能够更有效地发动拒绝服务攻击，扫描潜在的受害者，危害存在安全隐患的系统。</p></li>
</ul>
<h2 id="黑客攻击方式-p98">13. 黑客攻击方式 P98</h2>
<blockquote>
<p>看一下</p>
</blockquote>
<ul>
<li><p>口令破解攻击</p>
<p>密码破解不一定涉及复杂的工具。它可能与找一张写有密码的贴纸一样简单，而这张纸就贴在显示器上或者藏在键盘底下。另一种蛮力技术称为垃圾搜寻（dumpster diving）它基本上就是一个攻击者把垃圾文件搜寻一遍以找出可能含有密码的废弃文档。攻击者也使用一些更高级的复杂技术。</p>
<ul>
<li><p>字典技术</p>
<p>到目前为止，一个简单的字典攻击是闯人机器的最快方法。字典文件（一个充满字典文字的文本文件）被装入破解应用程序（如L0phtCrack），它是根据由应用程序定位的用户账户运行的。因为大多数密码通常是简单的，所以运行字典攻击通常足以实现目的了。</p></li>
<li><p>混合攻击</p>
<p>另一个众所周知的攻击形式是混合攻击。混合攻击将数字和符号添加到文件名中以成功破解密码。许多人只通过在当前密码后加一个数字来更改密码。其模式通常采用这一形式：第一个月的密码是cat；第二个月的密码是cat1；第三个月的密码是cat2依次类推。</p></li>
<li><p>暴力攻击</p>
<p>暴力攻击是最全面的攻击形式，虽然它通常需要很长的时间。工作时间取决于密码的复杂程度。</p></li>
<li><p>系统账户破解工具LC5</p></li>
<li><p>Word文件密码破解工具Word Password Recovery Master</p></li>
</ul></li>
<li><p>缓冲区溢出攻击</p>
<p>缓冲区溢出是一种非常普遍又非常危险的漏洞，在各种操作系统、应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统死机、重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权（“肉机"），进而进行各种非法操作。据统计，通过缓冲区溢出进行的攻击已占所有系统攻击总数据的80%以上。</p>
<p>在计算机内部，如果一个容量有限的内存空间里存储过量数据，这时数据会溢出存储空间。缓冲区攻击主要是通过往程序的缓冲区写超出其长度的数据，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其他指令，以达到攻击的目的。最常见的手段是通过制造缓冲区溢出使程序运行一个用户shell，再通过shell执行其他命令。如果该程序属于root且有suid权限的话，攻击者就获得了一个有root权限的shell，就可以对系统进行任意操作了。</p></li>
<li><p>欺骗攻击</p>
<ul>
<li><p>源IP地址欺骗攻击</p>
<p>许多应用程序认为如果数据包能够使其自身沿着路由到达目的地，而且应答包也可以回到源地，那么源IP地址一定是有效的，而这正是使源IP地址欺骗攻击成为可能的前提。</p></li>
<li><p>源路由欺骗攻击</p>
<p>在通常情况下，信息包从起点到终点走过的路径是由位于此两点间的路由器决定的，数据包本身只知道去往何处，但不知道该如何去。源路由可使信息包的发送者将此数据包要经过的路径写在数据包里，使数据包循着一个对方不可预料的路径到达目的主机。</p></li>
<li><p>ARP欺骗</p></li>
</ul></li>
<li><p>DoS/DDoS攻击</p>
<ul>
<li>拒绝服务攻击（Denial of Service，DoS）行动使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷直至瘫痪而停止正常的网络服务。拒绝服务攻击建立在IP地址欺骗攻击的基础上。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。带宽攻击指以极大的通信量冲击网络.使得所有可用网络资源都被消耗殆尽，最后导致合法用户请求无法通过。连通性攻击指用大量的连接请求冲击计算机，使得所有可用的操作系统资源都被占用，最终计算机无法再处理合法用户的请求。按照人侵方式可以分为：
<ul>
<li>资源消耗型DoS攻击：资源消耗型拒绝服务是指人侵者试图消耗目标的合法资源，例如网络带宽、内存、硬盘空间和CPU利用率，从而得到拒绝服务的目的。</li>
<li>配置修改型DoS攻击：计算机配置不当可能造成系统运行不正常甚至根本不能运行。入侵者通过修改或者破坏系统的配置信息来阻止其他合法用户使用计算机和网络提供的服务，主要有改变路由信息、修改Windows注册表、修改Linux的各种配置文件。</li>
<li>物理破坏型DoS攻击：物理破坏型拒绝服务主要针对物理设备的安全，入侵者可以通过破坏或改变网络部件以实现拒绝服务。</li>
<li>服务利用型DoS攻击：利用入侵目标的自身资源实现入侵意图，由于被入侵系统具有漏洞和通信协议的弱点，这给入侵者提供了机会。入侵者利用TCP/IP及目标责任系统自身应用软件中的一些漏洞和弱点得到拒绝服务的目的。</li>
</ul></li>
<li>分布式拒绝服务攻击（Distributed DoS，DDoS）是在传统的DoS攻击基础之上产生的一类攻击方式，DDoS针对计算机与网络高处理能力，利用更大规模的傀儡机（肉鸡）攻击目标主机，使得攻击者傀儡机可以分布在更大的范围、更远的地方或其他的城市，是目前黑客经常采用而难以防范的攻击手段。</li>
</ul></li>
<li><p>SQL注入攻击</p>
<p>SQL注入是利用网站代码漏洞来获取网站或应用程序后台的SQL数据库的访问权限，进而可以取得数据库所有的数据信息。拿到数据库管理员登录用户名和密码后，黑客可以自由修改数据库中的内容甚至删除该数据库。SQL注人可以用来检验一个网站或应用的安全性。</p></li>
<li><p>网络蠕虫攻击</p>
<p>蠕虫病毒和一般的计算机病毒有着很大的区别。对于蠕虫，现在还没有一个成套的理论体系。一般认为蠕虫病毒是一种通过网络传播的恶性病毒，它除具有病毒的一些共性一传播性、隐藏性、破坏性等，同时具有自己的一些特征，如不利用文件寄生（有的只存在于内存中），对网络造成拒绝服务，以及与黑客技术相结合等。根据使用者情况将蠕虫病毒分为两类：</p>
<ul>
<li>面向企业用户和局域网，利用系统漏洞，主动进行攻击，可以对整个互联网造成瘫痪性的后果。以“红色代码”、“尼姆达”以及最新的“SQL蠕虫王”为代表。此类具有很大的主动攻击性，而且爆发也有一定的突然性，但相对来说，查杀并不是很难。</li>
<li>针对个人用户，通过网络（主要是电子邮件、恶意网页形式）迅速传播的蠕虫病毒，以爱虫病毒、求职信病毒为代表。此类传播方式比较复杂和多样，少数利用了微软的应用程序的漏洞，更多的是利用社会工程学对用户进行欺骗和诱使，这样的病毒造成的损失是非常大的，同时也是很难根除的。</li>
</ul></li>
<li><p>木马攻击</p>
<p>木马一般是客户端/服务端（Client/Server，C/S）模式，客户端/服务端之间采用TCP/UDP的通信方式，比喻埋伏在别人的计算机里，偷取对方机密信息的程序。如果要给别人计算机上植人木马，则受害者一方运行的是服务器端程序，而自己使用的是客户端来控制受害者机器。木马是一种基于远程控制的黑客工具，具有隐藏性和非授权性的特点：</p>
<ul>
<li>隐藏性是指服务端即使发现感染了木马，由于不确定其具体位置，往往只能望“马”兴叹。</li>
<li>非授权性是指一旦客户端与服务端连接后，客户端将享有服务端的大部分操作权限，包括修改文件，修改注册表，控制鼠标、键盘等，这些权力不是服务端赋予的，而是通过木马程序窃取的。</li>
</ul>
<p>一旦木马程序被植入到毫不知情的用户的计算机中，以“里应外合”的工作方式，服务程序通过打开特定的端口并进行监听，这些端口好像“后门”一样，所以也有人把特洛伊木马叫做后门工作。攻击者所掌握的客户端程序向该端口发出请求（Connect Request），木马便与其连接起来。攻击者可以使用控制器进人计算机，通过客户端程序命令达到控制服务器端的目的。</p></li>
</ul>
<h2 id="网络安全策略-p117">14. 网络安全策略 P117</h2>
<blockquote>
<p>有哪些策略</p>
</blockquote>
<ul>
<li><p>物理安全策略</p>
<p>物理安全策略的目的是保护计算机系统、网络服务器、打印机等硬件实体和通信链路免受自然灾害、人为破坏和搭线攻击，包括安全地区的确定、物理安全边界物理安全控制、设备安全、防电磁辐射等。</p>
<p>物理接口控制是指安全地区应该通过合适的人口控制进行保护，从而保证只有合法员工可以访问这些地区。设备安全是为了防止资产的丢失、破坏，防止商业活动中断，建立完备的安全管理制度，防止非法进人计算机控制室和各种偷窃、破坏活动的发生。抑制和防止电磁泄漏（即TEMPEST技术）是物理安全策略的一个主要问题。目前主要防护措施有两类：一类是对传导发射的防护，主要采取对电源线和信号线加装性能良好的滤波器，减小传输阻抗和导线间的交叉耦合。另一类是对辐射的防护，这类防护措施又可分为以下两种：一是采用各种电磁屏蔽措施，如对设备的金属屏蔽和对各种接插件的屏蔽，同时对机房的下水管、暖气管和金属门窗进行屏蔽和隔离；二是对干扰的防护措施，即在计算机系统工作的同时，利用干扰装置产生一种与计算机系统辐射相关的伪噪声向空间辐射来掩盖计算机系统的工作频率和信息特征。</p></li>
<li><p>访问控制策略</p>
<p>访问控制是网络安全防范和保护的主要策略，它的主要任务是保证网络资源不被非法使用和非常访问。它也是维护网络系统安全、保护网络资源的重要手段。各种安全策略必须相互配合才能真正起到保护作用，但访问控制可以说是保证网络安全最重要的核心策略之一。访问控制包括用户访问管理以防止未经授权的访问；网络访问控制，保护网络服务；操作系统访问控制，防止未经授权的计算机访问；应用系统访问控制，防止信息系统中信息的未经授权的访问；监控对系统的访问和使用，探测未经授权的行为。</p></li>
<li><p>信息加密策略</p>
<p>信息安全策略是要保护信息的机密性、真实性和完整性，因此应对敏感或机密数据加密。信息加密过程是由形形色色的加密算法来具体实施的，它以很小的代价提供很大的安全保护。在多数情况下，信息加密是保证信息机密性的唯一方法。信息加密的算法是公开的，其安全性取决于密钥的安全性，应建立并遵守用于对信息进行保护的密码控制的使用策略，密钥管理基于一套标准、过程和方法，用于支持密码技术的使用。信息加密的目的是保护网内的数据、文件、口令和控制信息，保护网上传输的数据。网络加密常用的方法有链路加密、端点加密和节点加密三种。链路加密的目的是保护网络节点之间的链路信息安全：端点加密的目的是对源端用户到目的端用户的数据提供保护；节点加密的目的是对源节点到目的节点之间的传输链路提供保护。</p></li>
<li><p>网络安全管理策略</p>
<p>网络的安全管理策略包括：确定安全管理等级和安全管理范围；制定有关网络操作使用规程和人员出入机房管理制度；制定网络系统的维护制度和应急措施等。加强网络的安全管理，制定有关规章制度，对于确保网络的安全、可靠地运行，将起到十分有效的作用。</p></li>
</ul>
<h1 id="五网络安全技术">五、网络安全技术</h1>
<h2 id="防火墙概念-p125">15. 防火墙概念 P125</h2>
<blockquote>
<p>定义、有哪几种控制技术</p>
</blockquote>
<p>防火墙是位于两个或多个网络之间，实施网间访问控制策略的一组组件。</p>
<p>设立防火墙的目的是保护内部网络不受来自外部网络的攻击，从而创建一个相对安全的内网环境。在网络系统中，防火墙是一个由软件系统和硬件设备组合而成在内部网和外部网之间、专用网与公共网之间构造的保护屏障，使Internet与Intranet之间建立一个安全网关（Security Gateway），从而保护内部网免受非法用户人侵。</p>
<p>防火墙主要由服务访问规则、验证工具、包过滤和应用网关四部分组成。</p>
<p>理想的防火墙应该满足以下条件：</p>
<ul>
<li>内部和外部之间的所有网络数据流必须经过防火墙。</li>
<li>只有符合安全策略的数据流才能通过防火墙。</li>
<li>防火墙自身应具有非常强的抗攻击免疫力。</li>
</ul>
<p>防火墙一般采用四种控制技术来达到保护内部网络的目的：</p>
<ul>
<li>服务控制，控制可以访问的Internet服务类型，包括向内和向外。</li>
<li>方向控制，控制一项特殊服务所要求的方向。</li>
<li>用户控制，控制访问服务的人员。</li>
<li>行为控制，控制服务的使用方式，如E-mail过滤等。</li>
</ul>
<h2 id="简16.-防火墙主要技术-p127-p133">*简16. 防火墙主要技术 P127-P133</h2>
<blockquote>
<p>有哪些技术</p>
<p>有哪些协议</p>
</blockquote>
<h3 id="包过滤技术">包过滤技术</h3>
<p>包过滤（Packet Filtering）技术是防火墙在网络层根据IP数据包中的包头信息有选择地实施允许通过或阻断。包过滤防火墙对流经该设备的IP数据包地址信息、协议类型、路由信息、流向等首部信息，按照事先设定的过滤规则来决定是否允许该数据包通过。</p>
<p>判断依据：</p>
<ul>
<li>源、目的IP地址和源、目的端口。</li>
<li>数据包协议类型，如TCP、UDP、ICMP 、IGMP等。</li>
<li>IP路由选项。</li>
<li>TCP标志位选项，如SYN、ACK、FIN、RST等。</li>
<li>数据包流向或流经的网络接口，如in或out等，以允许合平规则的数据包通过防火墙进入内部或外部网络，而将不合平规则的数据包丢弃。</li>
</ul>
<p>包过滤防火墙工作原理：</p>
<figure>
<img src="../images/包过滤防火墙工作原理.png" alt="包过滤防火墙工作原理" /><figcaption aria-hidden="true">包过滤防火墙工作原理</figcaption>
</figure>
<p>包过滤防火墙数据流示意图：</p>
<figure>
<img src="../images/包过滤防火墙数据流示意图.png" alt="包过滤防火墙数据流示意图" /><figcaption aria-hidden="true">包过滤防火墙数据流示意图</figcaption>
</figure>
<h3 id="代理技术">代理技术</h3>
<p>代理技术又称为应用网关技术。应用代理防火墙运行在两个网络之间，它对于客户来说像是一台真的服务器，而对于服务器来说它又是一台客户机。当代理服务器接收到客户的请求后，会检查用户请求是否符合相关安全策略的要求，如果符合的话，代理服务器会代表客户，去服务器那里取回所需信息再转发给客户。</p>
<p>应用代理防火墙作用在应用层，控制应用层的服务，在内部网络向外部网络申请服务时起到中间转接作用。内部网络只接受代理提出的服务请求，拒绝外部网络其他节点的直接请求。代理防火墙代替受保护网的主机向外部网发送服务请求，并将外部服务请求响应的结果返回给受保护网的主机。受保护网内部用户对外部网访问时，也需要通过代理防火墙、才能向外提供请求，这样外网只能看到防火墙，从而隐藏了受保护网内部地址，提高了安全性。</p>
<p>代理服务器接受内、外部网络的通信数据包，根据自己的安全策略进行过滤，不符合安全协议的信息被拒绝或丢弃。应用代理防火墙工作在TCP/IP的应用层，针对特定的网络应用服务协议进行过滤，使用代理软件来转发和过滤特定的应用层服务，只允许有代理的服务通过防火墙，并且能够对数据包进行分析并形成相关的报告。</p>
<p>应用代理防火墙工作原理：</p>
<figure>
<img src="../images/应用代理防火墙工作原理.png" alt="应用代理防火墙工作原理" /><figcaption aria-hidden="true">应用代理防火墙工作原理</figcaption>
</figure>
<p>应用代理防火墙数据流示意图：</p>
<figure>
<img src="../images/应用代理防火墙数据流示意图.png" alt="应用代理防火墙数据流示意图" /><figcaption aria-hidden="true">应用代理防火墙数据流示意图</figcaption>
</figure>
<h3 id="状态检测技术">状态检测技术</h3>
<p>状态检测防火墙既具备包过滤防火墙的速度和灵活性，也具有应用代理防火墙的安全优点，是对包过滤和应用代理功能的一种平衡。状态检测防火墙采用一种基于连接的状态检测机制，将属于同一连接的所有包作为一个整体数据流看待，构成连接状态表，通过规则表与状态表的共同配合，对表中的各个连接状态因素加以识别。动态连接状态表中的记录可以是以前的通信信息，也可以是其他相关应用程序的信息，因此与包过滤防火墙的静态过滤规则表相比，具有更好的灵活性和安全性。</p>
<p>状态检测技术是根据会话信息来决定单个数据包是否可以通过，不实际处理应用层协议。东软公司NetEye防火墙3.0首创“流过滤”技术，以包过滤的外部形态提供了应用级的保护能力，带给用户的最大好处在于对应用层保护能力大幅度提升，是在状态检测包过滤的架构上发展起来的新一代防火墙技术。流过滤技术核心是专门设计的TCP协议栈，该协议栈根据TCP的定义对出人防火墙的数据包进行了完全的重组，并根据应用层的安全规则对组合后的数据流进行检测。由于这个协议栈的存在,网络通信在防火墙内部由链路层上升到了应用层。数据包不再直接到达目的端，而是完全受防火墙中的应用协议模块的控制。这种应用协议模块的工作方式非常类似于代理防火墙针对不同协议的代理程序，代替服务器接受来自客户端的访问，再代替客户端去获取访问的结果，所不同的是，这种模块能够支持更多的协议种类和更大规模的并发访问。</p>
<p>状态监测防火墙工作原理：</p>
<figure>
<img src="../images/状态监测防火墙工作原理.png" alt="状态监测防火墙工作原理" /><figcaption aria-hidden="true">状态监测防火墙工作原理</figcaption>
</figure>
<p>状态监测防火墙数据流示意图：</p>
<figure>
<img src="../images/状态监测防火墙数据流示意图.png" alt="状态监测防火墙数据流示意图" /><figcaption aria-hidden="true">状态监测防火墙数据流示意图</figcaption>
</figure>
<h3 id="网络地址转换技术nat">网络地址转换技术NAT</h3>
<p>NAT（Network Address Translation，网络地址翻译）是用来缓解地址空间短缺的主要技术之一。</p>
<p>防火墙网络地址转换技术涉及公用地址和专用地址。公用地址又称为合法IP地址，是指由Internet网络信息中心(InterNIC)分配的IP地址，在Internet上通信必须有一个公用地址。为了解决IP地址短缺问题，InterNIC为公司专用网络提供了保留网络IP专用的方案。这些专用网络地址包括：子网掩码为255.0.0.0的10.0.0.0（一个A类地址），子网掩码为255.240.0.0的172. 160.0.0（一个B类地址），子网掩码为255. 255.0.0的192. 168. 0.0（一个C类地址）。专用地址不能直接与Internet 通信，使用专用地址的内部网络与Internet进行通信，专用地址必须转换成公用地址。</p>
<p>网络地址转换器（Network Address Translator，NAT）是完成地址转换的一个部件。NAT位于使用专用地址的Intranet和使用公用地址的Internet之间，其任务如下：</p>
<ul>
<li>把从Intranet传出数据包的端口号和专用IP地址换成自己的端口号和公用IP地址，然后将数据包发给外部网络的目的主机，同时记录一个跟踪信息在映像表中，并向客户机发送回答信息。</li>
<li>将从Internet传入数据包的目的端口号和公用IP地址转换为客户机的端口号和内部网络使用的专用IP地址并转发给客户机。</li>
</ul>
<p>根据NAT工作模式，可分为：</p>
<ul>
<li>静态NAT：指内部网络的私有IP地址转换为真实IP地址，IP地址映射是一对一的，是事先由管理员配置好的，某个私有IP地址只转换为某个真实IP地址。借助于静态NAT，可以实现具有内部私有IP地址的内网机器对外部网络（如Internet）的访问，地址翻译属于静态NAT。</li>
<li>动态NAT：指内部网络的私有IP地址转换为真实IP地址时，IP地址转换是随机的。实际上，首先为NAT系统的IP地址缓冲池配置一个或多个真实IP地址，当内部私有IP地址访问外网时，NAT系统随机从IP地址缓冲池取出一个真实的IP地址为这次访问进行地址翻译。如果同时需要进行的访问多于缓冲池中地址时，可以借助于端口号，实际上就是将一个内部IP地址映射成真实IP地址及端口号的映射关系表，确保完成地址翻译。</li>
</ul>
<p>NAT工作原理：</p>
<figure>
<img src="../images/NAT工作原理.png" alt="NAT工作原理" /><figcaption aria-hidden="true">NAT工作原理</figcaption>
</figure>
<h3 id="其他技术">其他技术</h3>
<p>个人防火墙（Private Firewall）是一种能够保护个人计算机系统安全的软件，它可以直接在用户的计算机上安装、运行，使用与状态/动态检测防火墙相同的方式，保护一台计算机免受攻击。通常，这些防火墙是安装在计算机网络接口的较低级别上，这使得它们可以监视传入/传出网卡的所有网络通信。现在网络上流传的很多个人防火墙软件都是应用程序级的。</p>
<p>因为传统的防火墙设置在网络边界，处于内、外网络之间，所以称为“边界防火墙”。随着人们对网络安全防护要求的提高，边界防火墙明显达不到要求，因为给网络带来安全威胁的不仅是外部网络，更多的是来自内部网络。但边界防火墙无法对内部网络实现有效保护，正是基于这个原因，产生了分布式防火墙(Distributed Firewall)技术。分布式防火墙技术可以很好地解决边界防火墙的不足问题，把防火墙的安全防护系统延伸到网络中的各台主机。分布式防火墙负责对网络边界、各子网和网络内部节点之间的安全防护。分布式防火墙是一个完整的系统，而不是单一的产品。根据需要完成的功能，分布式防火墙主要包括网络防火墙（Network Firewall）、主机防火墙（Host Firewall）和中心管理（Center Management）部分。</p>
<h2 id="防火墙的作用-p134">17. 防火墙的作用 P134</h2>
<ul>
<li><p>网络流量过滤</p>
<p>网络流量过滤是防火墙最主要的功能。通过在防火墙上进行安全规则配置，可以对流经防火墙的网络流量进行过滤。安全规则是依据安全策略精心设计的，防火墙严格执行安全检查，这样只要符合安全规则的网络流量才能通过，大大提高了局域网的安全性。</p></li>
<li><p>网络监控审计</p>
<p>如果所有的访问都经过防火墙，那么防火墙就能记录下这些访问并生成网络访问日志，同时也能提供网络使用情况的统计数据。当出现可疑的网络访问时，防火墙能及时地发出警报，并提供可以访问的详细信息。防火墙可以作为收集一个网络使用情况的绝佳点，将所收集的有关信息提供给其他安全模块，必要时根据需要阻断网络连接访问，与其他安全模块形成联动系统。</p></li>
<li><p>支持NAT部署</p>
<p>NAT（Network Address Translation，网络地址翻译）是用来缓解地址空间短缺的主要技术之一。由于防火墙处于内、外网的阻塞点上，是实施NAT部署的理想场所。</p></li>
<li><p>支持DMZ</p>
<p>DMZ（Demilitarized Zone），中文名称为“隔离区”，也称"非军事区”。它是设立在非安全系统与安全系统之间的缓冲区，这个缓冲区位于企业内部网络和外部网络之间的小网络区域内，可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器等。</p></li>
<li><p>支持VPN</p>
<p>通过VPN（Virtual Private Network，虚拟私有网络），企业可以将分布在各地的局域网有机地连成一个整体，不仅省去了租用专用通信线路的费用，而且为信息共享提供了安全技术保障。</p></li>
</ul>
<h2 id="防火墙的体系架构-p135">18. 防火墙的体系架构 P135</h2>
<blockquote>
<p>三种架构看一下</p>
</blockquote>
<p>常见术语：</p>
<ul>
<li>非军事区：为了配置和管理方便，通常将内部网中需要向外部提供服务的服务器设置在单独的网段，这个网段被称为非军事区（DMZ），也被称为周边网络。DMZ是周边网络，是指在内部网络、外部网络之间增加的一个网络，对外提供服务的各种服务器都可以放在这个网络里。DMZ隔离内外网络，并为内外网之间的通信起到缓冲作用。周边网络的存在，使得外部用户访问服务器时不需要进人内部网络，而内部网络用户对服务器维护工作导致的信息传递也不会泄露至外部网络；同时，周边网络与外部网络或内部网络之间都存在着数据包过滤，这样为外部用户的攻击设置了多重障碍，确保了内部网络的安全。</li>
<li>堡垒主机（Bastion Host）：得名于古代战争中用于防守的坚固堡垒，它位于内部网络的最外层，像堡垒一样对内部网络进行保护。堡垒主机是一种配置了安全防范揩施的网络上的计算机，为网络之间的通信提供了一个阻塞点。如果没有堡垒主机，网络之间将不能相互访问。堡垒主机是指可能直接面对外部用户攻击的主机系统，在防火墙体系结构中，堡垒主机要高度暴露，是网络上最容易遭受非法人侵的设备。所以防火墙设计者和管理人员需要致力于堡垒主机的安全，而且在运行期间对堡垒主机的安全要给予特别的注意。一般来说，堡垒主机上提供的服务越少越好，因为每增加一种服务就增加了被攻击的可能性。</li>
<li>双重宿主主机：指至少拥有两个以上网络接口且每个网络接口连接不同的网络的计算机系统，因此也称为多穴主机系统。一般来说，双重宿主主机是实现多个网络之间互连的关键设备，如网桥是在数据链路层实现互连的双重宿主主机，路由器是在网络层实现互连的双重宿主主机，应用层网关是在应用层实现互连。</li>
</ul>
<p>防火墙的经典体系结构主要有双宿主主机体系结构、被屏蔽主机体系结构和被屏蔽子网体系结构三种形式。</p>
<h3 id="双宿主主机">双宿主主机</h3>
<p>双宿主主机（Dual- Homed Host）位于内部网和Internet之间，一般来说，是用一台装有两块网卡的堡垒主机做防火墙。这两块网卡各自与受保护网和外部网相连，分别属于内外两个不同的网段。堡垒主机上运行着防火墙软件，可以转发应用程序，提供服务等，堡垒主机的系统软件可用于维护系统日志。双宿主主机这种体系结构非常简单，一般通过代理（Proxy）来实现，或者通过用户直接登录到该主机来提供服务。</p>
<p>双宿主主机体系的防火墙主体是带有内部网络和外部网络接口主机系统，双宿主主机具备成为内部网络和外部网络之间路由器的条件。但是，在内部网络与外部网络之间，数据包转发进程是被禁止运行的。为了达到防火墙的基本效果，在双宿主主机系统中，任何路由功能都是禁止的。双宿主主机采用应用代理防火墙技术，内部网络用户通，过客户端代理软件访问外部网络资源，或者直接登录双宿主主机成为一个用户，利用该主机直接访问外部资源。</p>
<p>双宿主主机体系结构：</p>
<figure>
<img src="../images/双宿主主机体系结构.png" alt="双宿主主机体系结构" /><figcaption aria-hidden="true">双宿主主机体系结构</figcaption>
</figure>
<p>双宿主主机体系结构的优点：</p>
<ul>
<li>网络结构比较简单，由于内、外网络之间没有直接的数据交互而较为安全。</li>
<li>内部用户账号可以有效控制外部资源。</li>
<li>由于应用代理机制的采用方便地形成应用层的数据与信息过滤。</li>
</ul>
<p>双宿主主机体系结构的缺点：</p>
<ul>
<li>用户需要登录到主机才能访问外部资源，主机资源消耗较大，用户访问外部资源较为复杂。</li>
<li>用户机制存在安全隐患，并且内部用户无法借助于该体系结构访问新的服务。</li>
<li>一旦外部用户人侵双宿主主机，则导致内部网络处于不安全状态。</li>
</ul>
<h3 id="被屏蔽主机">被屏蔽主机</h3>
<p>被屏蔽主机体系结构是指通过一个单独的路由器和内部网络上的堡垒主机共同构成防火墙，主要通过数据包过滤技术实现内、外网络的隔离和对内网的保护。在被屏蔽主机体系结构中，有两道屏障：一是屏蔽路由器，二是堡垒主机。屏蔽路由器位于网络最边缘，负责与外网实施连接，参与外网的路由计算。屏蔽路由器仅提供路由和数据包过滤功能，因此屏蔽路由器本身较为安全。由于屏蔽路由器的存在，堡垒主机不再是直接与外网互连的双宿主主机，增加了系统的安全性。</p>
<p>堡垒主机位于内部网络，是唯一可以连接到外部网络系统的主机，也是外部用户访问内部网络资源必须经过的主机设备。堡垒主机通过数据包过滤实现对内部网络的防护，并且仅仅允许通过特定的服务连接。堡垒主机可以提供代理功能，内部用户只能通过应用代理访问外部网络，堡垒主机成为外部用户唯一可以访问的内部主机。</p>
<p>被屏蔽主机体系结构：</p>
<figure>
<img src="../images/被屏蔽主机体系结构.png" alt="被屏蔽主机体系结构" /><figcaption aria-hidden="true">被屏蔽主机体系结构</figcaption>
</figure>
<p>被屏蔽主机体系结构的优点：</p>
<ul>
<li>具有更高的安全特性。由于屏蔽路由器在堡垒主机之外提供数据包过滤功能，使得堡垒主机要比双宿主主机相对安全，存在漏洞的可能性较小；同时，堡垒主机的数据包过滤功能限制外部用户只能访问特定主机上的特定服务，在提供服务的同时仍然保证了内部网络的安全。</li>
<li>内部网络用户访问外部网络方便、灵活。在屏蔽路由器和堡垒主机允许的情况下，用户直接访问外部网络。如果屏蔽路由器和堡垒主机不允许，内部用户通过堡垒主机代理服务访问外部资源。在实际应用中，两种方式综合运用，访问不同服务采用不同的方式。</li>
<li>由于堡垒主机和屏蔽路由器的同时存在，使得堡垒主机可以从部分安全事务中解脱出来，从而可以以更高的效率提供数据包过滤或代理服务。</li>
</ul>
<p>被屏蔽主机体系结构的缺点：</p>
<ul>
<li>在被屏蔽主机体系结构中，外部用户在被允许的情况下可以访问内部网络，这样就存在着一定的安全隐患。</li>
<li>与双宿主主机体系一样，一旦用户入侵堡垒主机，就会导致内部网络处于不安全状态。</li>
<li>路由器和堡垒主机的过滤规则配置较为复杂，较容易形成错误和漏洞。</li>
</ul>
<h3 id="被屏蔽子网">被屏蔽子网</h3>
<p>在双宿主主机体系结构和被屏蔽主机体系结构中，主机是最主要的安全缺陷，一旦主机被入侵，则整个内部网络都处于威胁之中,为解决这种安全隐患，出现了被屏蔽子网体系结构。被屏蔽子网体系结构将防火墙的概念扩充至一个由两台路由器包围起来的特殊网络，即周边网络，并且将堡垒主机都置于周边网络中。</p>
<p>被屏蔽子网体系结构防火墙比较复杂，主要包括四个部件：周边网络、外部路由器、内部路由器、堡垒主机。</p>
<p>被屏蔽子网体系结构：</p>
<figure>
<img src="../images/被屏蔽子网体系结构.png" alt="被屏蔽子网体系结构" /><figcaption aria-hidden="true">被屏蔽子网体系结构</figcaption>
</figure>
<p>被屏蔽子网体系结构的优点：</p>
<ul>
<li>外部路由器和内部路由器构成了双层防护体系，入侵者难以突破。</li>
<li>外部用户访问服务资源时无须进人内部网络，在保证服务的情况下提高了内部网络的安全性。</li>
<li>外部路由器和内部路由器过滤规则复制，避免了由于某台路由器失效产生的安全隐患。</li>
<li>堡垒主机由外部路由器的过滤规则和本机安全机制共同防护，用户只能访问它提供的服务。</li>
<li>即使入侵者通过堡垒主机的服务缺陷控制了堡垒主机，由于内部路由器将内部网络和周边网络隔离，入侵者无法通过监听周边网络获取内部网络信息。</li>
</ul>
<p>被屏蔽子网体系结构的缺点：</p>
<ul>
<li>构建被屏蔽子网体系结构的成本较高。</li>
<li>被屏蔽子网体系结构的配置较为复杂，容易出现配置错误导致的安全隐患。</li>
</ul>
<h2 id="简19.-入侵检测系统ids-p134">*简19. 入侵检测系统IDS P134</h2>
<blockquote>
<p>IDS定义、基本原理</p>
</blockquote>
<p>入侵检测系统（Intrusion Detection System，IDS）是监测计算机网络和系统以发现违反安全策略事件的过程。入侵检测作为一种积极主动的安全防护手段，在保护计算机网络和信息安全方面发挥着重要的作用。</p>
<p>入侵检测系统工作在计算机网络系统的关键节点上，通过实施收集和分析计算机网络或系统中的信息，来检查是否出现违反安全策略的行为和遭到袭击的迹象，进而达到防治攻击、预防攻击的目的。</p>
<p>入侵检测系统通过对网络中的数据包或主机的日志等信息进行提取、分析，发现入侵和攻击行为，并对入侵或攻击做出响应。入侵检测系统在识别人侵和攻击时具有一定的智能，这主要体现在入侵特征的提取和汇总、响应的合并与融合、在检测到入侵后能够主动采取响应措施等方面，所以说入侵检测系统是一种主动防御技术。</p>
<p>入侵检测系统分为四个基本组件：</p>
<ul>
<li>事件产生器（Event Generators）</li>
<li>事件分析器（Event Analyzers）</li>
<li>响应单元（Response Units）</li>
<li>事件数据库（Event Databases）</li>
</ul>
<p>通用入侵检测框架（Common Intrusion Detection Framework，CIDF）体现了入侵检测系统必须具有的体系结构，具有通用性：</p>
<ul>
<li>数据获取</li>
<li>数据分析</li>
<li>行为响应</li>
<li>数据管理</li>
</ul>
<p>入侵检测系统的基本原理：</p>
<p>入侵检测系统是静态安全防御技术的合理补充，帮助系统对付网络攻击，扩展了系统管理员的安全管理能力（包括安全审计、监视、进攻识别和响应），提高了信息安全基础结构的完整性。它从计算机网络系统中的若干关键点收集信息，并分析这些信息，查看网络中是否有违反安全策略的行为和遭到袭击的迹象。</p>
<p>攻击检测系统的工作流程可分为信息收集、信息分析和动作响应三个阶段，这三个阶段对应的CIDF功能单元分别是事件产生器、事件分析器和响应单元：</p>
<ul>
<li>信息收集阶段：主要工作是收集被保护网络和系统的特征信息,攻击检测系统的数据源主要来自主机、网络和其他安全产品。基于主机的数据源主要有系统的配置信息、系统运行状态信息、系统记账信息、系统日志、系统安全性审计信息和应用程序的日志；基于网络的数据源主要有SNMP信息和网络通信数据包；其他攻击检测系统的报警信息、其他网络设备和安全产品的信息也是重要的数据源之一。</li>
<li>信息分析阶段：主要工作是利用一种或多种攻击检测技术对收集到的特征信息进行有效的组织、整理、分析和提取，从而发现存在的攻击事件。这种行为的鉴别可以实时进行，也可以事后分析,在很多情况下，事后的进一步分析是为了寻找行为的责任人。</li>
<li>动作响应阶段：主要工作是对信息分析的结果做出相应的响应。被动响应是系统仅仅简单地记录和报告所检测出的问题，主动响应则是系统要为阻塞或影响进程而采取反击行动。理想的情况下，系统的这一部分应该具有丰富的响应功能特性，并且这些响应特性在针对安全管理小组中的每一位成员进行裁剪后，能够为他们提供服务。</li>
</ul>
<h2 id="入侵检测系统的分类-p146">20. 入侵检测系统的分类 P146</h2>
<blockquote>
<p>按数据来源划分</p>
</blockquote>
<p>IDS通过对入侵行为的过程与特征进行研究，使安全系统对入侵事件和入侵过程作出实时响应。从不同角度出发，IDS的分类也不同。</p>
<ul>
<li><p>按实现技术划分：</p>
<ul>
<li>异常发现技术：将所有与正常行为的轨迹不同的系统行为都视为可疑的入侵企图，例如通过流量统计分析发现异常的网络流量。
<ul>
<li>局限：并非所有的人侵都表现为异常，而且系统的轨迹也难于计算和更新。</li>
</ul></li>
<li>模式发现技术：所有的入侵手段及其行为轨迹都可以用模式或特征加以描述，与正常行为模式不相匹配的行为均视为可疑的入侵行为。
<ul>
<li>优点：误报少。</li>
<li>局限：只能发现已知的入侵，对未知的入侵无能为力。</li>
</ul></li>
</ul></li>
<li><p>按数据来源划分：</p>
<ul>
<li>基于主机的IDS（Host IDS，HIDS）</li>
<li>基于网络的IDS（Network IDS， NIDS）</li>
<li>分布式IDS（ Distributed IDS，DIDS）</li>
</ul></li>
</ul>
<h2 id="vpn的主要类型-p150">21. VPN的主要类型 P150</h2>
<blockquote>
<p>VPN名词解释、有哪几类</p>
</blockquote>
<p>针对不同的用户需求，VPN有三种类型：</p>
<ul>
<li>远程访问虛拟网（Access VPN）：也称为虚拟专用拨号网络（VPDN），是一种用户到LAN的连接，通常用于员工从远程位置连接的专用网络。企业服务提供商（ESP）为公司提供大型远程访问VPN； ESP建立一个网络访问服务器（NAS），向远程用户提供桌面客户端软件；远程用户拨打免费号码连接NAS，使用VPN客户端软件访问公司网络。Access VPN通过第三方服务商在公司专用网络和远程用户之间实现安全加密连接。</li>
<li>企业内部虚拟网（Intranet VPN）：基于Intranet，如果公司有一个或多个远程位置需要加入一个专用网络，可以建立一个Intranet VPN，将LAN连接到另一个LAN，称为企业内部虚拟网（Intranet VPN）。</li>
<li>企业扩展虚拟网（Extranet VPN）：基于Extranet，如果公司同其他公司（如供应商、客户等）关系紧密，他们可以建立一个Extranet VPN，将LAN连接到另一个LAN，所有公司同时在一个共享环境中工作，称为企业扩展虚拟网（Extranet VPN）。</li>
</ul>
<p>三种类型VPN分别与远程访问网络、企业内部Internet和企业网与企业网构成的Extranet相对应。</p>
<h2 id="简22.-vpn的基本原理-p152">*简22. VPN的基本原理 P152</h2>
<p>VPN技术非常复杂，实现VPN的主要技术及相关协议已经成熟，以L2TP、IPSec和SSL协议应用最广。VPN使用三方面技术保证通信的安全性：身份验证技术、隧道协议、加密技术。</p>
<ul>
<li><p>身份验证技术</p>
<p>VPN在不安全的Internet中通信，通信内容涉及企业的机密数据，因此其安全性非常重要。身份验证技术是实现安全通信的前提。</p>
<p>VPN的一般验证流程：</p>
<ul>
<li>客户机（Client）向 VPN服务器（Authenticating Device）发出请求（Challenge），VPN服务器响应（Response）请求并向客户机发出身份（User Name，Password）质询。</li>
<li>客户机将加密的响应信息发送到VPN服务器，VPN服务器根据用户数据库（Data Base）检查是否该响应。</li>
<li>如果账户（ID）有效，VPN服务器将检查该用户是否具有远程访问权限。</li>
<li>如果该用户拥有远程访问的权限，VPN服务器接受此连接。</li>
<li>在身份验证过程中产生的客户机和服务器公有密钥将用来对数据进行加密。在VPN中，用户身份认证技术是在正式隧道连接开始前进行用户身份确认，以便系统进一步实施相应的资源访问控制和用户授权。VPN中常用的身份认证技术主要有安全口令、PPP认证协议和密钥管理技术三种。</li>
</ul></li>
<li><p>隧道协议</p>
<p>隧道协议（Tunneling Protocol）是VPN的基本技术，类似于点对点连接技术（Point to Point Protocol，PPP），它在公网建立一条数据通道（隧道），让数据包通过这条隧道传输。隧道是由隧道协议形成的，主要有第二层隧道协议PPTP（Point- to-Point Tunneling Protocol）和L2TP（Level 2 Tunneling Protocol）、 第三层隧道协议IPSec（IP Security）和安全套接层SSL（ Secure Sockets Layer）协议等。</p>
<p>隧道技术是一种通过使用互联网基础设施在网络之间传递数据的方式。使用隧道传递的数据可以是不同协议的数据帧或包，隧道协议将这些数据帧或包重新封装在新的包头中发送，新的包头提供了路由信息，从而使封装的数据能够通过互联网传递。被封装的数据包在隧道的两个端点之间通过公共互联网络进行路由，所经过的逻辑路径称为隧道，一旦到达网络终点数据将被解包并转发到最终目的地。隧道技术包括数据封装、传输和解包在内的全过程。</p></li>
<li><p>加密技术</p>
<p>在VPN实现中，双方大量通信流量的加密使用对称加密算法，在管理、分发对称加密的密钥上采用非对称加密技术。加密基本思想：在协议栈的任意层对数据或报文头进行加密，从而有效保护传输的信息。VPN是通过软件实现的技术，因而VPN加密载体是多方面的，包括路由器、防火墙、专用VPN硬件。VPN加密技术发展趋势是实现端到端的安全，真正确保完全的加密。</p></li>
</ul>
<h1 id="六信息系统安全">六、信息系统安全</h1>
<h2 id="访问控制的概念-p167">23. 访问控制的概念 P167</h2>
<blockquote>
<p>原理</p>
</blockquote>
<p>访问控制（Access Control）技术是用来管理用户对系统资源的访问。访问控制是国际标准ISO 7498-2中的五项安全服务之一，对提高信息系统的安全性起到至关重要的作用。</p>
<p>访问控制是针对越权使用资源的防御性措施之一。其基本目标是防止对任何资源（如计算资源、通信资源或信息资源）进行未授权的访问，从而使资源使用始终处于控制范围内。最常见的是通过对主机操作系统的设置或对路由器的设置来实现相应的主机访问控制或网络访问控制。</p>
<p>访问控制对实现信息机密性、完整性起直接的作用，还可以通过对以下信息的有效控制来实现信息和信息系统可用性：</p>
<ul>
<li>谁可以颁发影响网络可用性的网络管理指令。</li>
<li>谁能够滥用资源以达到占用资源的目的。</li>
<li>谁能够获得可以用于拒绝服务攻击的信息。</li>
</ul>
<p>为了能够更精确地描述访问控制，需要对访问控制的基本组成元素进行定义说明：</p>
<ul>
<li><p>主体（Subject）是指提出访问请求的实体，是动作的发起者，但不一定是动作的执行者。主体可以是用户或其他代理用户行为的实体（如进程、作业和程序等）。</p></li>
<li><p>客体（Object）是指可以接受主体访问的被动实体。客体的内涵很广泛，凡是可以被操作的信息、资源、对象都可以认为是客体。</p></li>
<li><p>访问控制策略（Access Control Policy）是指主体对客体的操作行为和约束条件的关联集合。简单地讲，访问控制策略是主体对客体的访问规则集合，这个规则集合可以直接决定。主体是否可以对客体实施特定的操作。访问控制策略体现了一种授权行为，也就是客体对主体的权限允许。访问控制策略往往表现为一系列的访问规则，这些规则定义了主体对客体的作用行为和客体对主体的条件约束。访问控制机制是访问控制策略的软硬件低层实现。</p></li>
</ul>
<h2 id="简24.-访问控制策略制定的原则-p168">*简24. 访问控制策略制定的原则 P168</h2>
<ul>
<li>最小权限原则：分配给系统的每一个程序和每一个用户的权限应该是它们完成工作所必须享有的权限的最小集合。</li>
<li>最小泄露原则：主体执行任务时所需知道的信息应该最小化。</li>
</ul>
<h2 id="操作系统安全机制-p174">25. 操作系统安全机制 P174</h2>
<blockquote>
<p>有哪些</p>
</blockquote>
<p>操作系统不安全的主要原因是操作系统结构体制的缺陷。对操作系统构成的威胁主要有计算机病毒、特洛伊木马、隐秘通道和天窗等。操作系统所具有的安全机制包括<strong>身份认证</strong>、<strong>访问控制</strong>、<strong>权限管理</strong>、<strong>内存保护</strong>、<strong>文件保护</strong>、<strong>安全审计</strong>等。</p>
<ul>
<li><p>身份认证：证明某人或某个对象身份，是保证系统安全的重要措施。身份认证需要用一个标识来表示用户的身份。将用户标识和用户联系的过程称为认证。操作系统的许多保护措施大都基于认证系统的合法用户，身份认证是操作系统中相当重要的一一个方面，也是用户获取权限的关键。</p></li>
<li><p>访问控制：是计算机安全领域一项传统的技术，其基本任务就是防止非法用户进入系统及合法用户对系统资源的非法使用。自主访问控制根据用户的身份及允许访问权限决：定其访问操作。强制访问控制是用户与文件都有一个固定的安全属性，系统用该安全属性来决定一个用户是否可以访问某个文件。基于角色的访问控制解决了具有大量用户、数据客体和访问权限的系统中授权管理问题。</p></li>
<li><p>最小特权：指在完成某种操作时赋子每个主体（用户或进程）必不可少的特权。最小特权原则一方面给予主体必不可少的特权，保证了所有的主体能在所赋予的特权之下完成所需要完成的任务或操作；另一方面，它只给予主体必不可少的特权，从而限制了每个主体所能进行的操作，确保由于可能的事故、错误、网络部件的篡改等原因造成的损失最小。</p></li>
<li><p>可信通路（Trust Path）机制 ：终端人员能借以直接同可信计算基（Trusted Computing Base，TCB）通信的一种机制。可信通路机制只能由有关终端人员或可信计算基启动，并且不能被不可信软件模仿。可信通路机制主要应用在用户登录或注册时，能够保证用户确实是和安全核心通信，防止不可信进程（如特洛伊木马等）模拟系统的登录过程而窃取口令。</p></li>
<li><p>隐蔽通道：指系统中利用那些本来不是用于通信的系统资源绕过强制访问控制进行非法通信的一种机制。系统内充满着隐蔽通道。对于系统中的每一个信息比特，如果它能由一个进程修改而由另一个进程读取（直接或间接），那它就是一个潜在的隐蔽通道。</p></li>
<li><p>安全审计：为系统进行事故原因的查询、定位，事故发生前的预测、报警以及事故发生之后的实时处理提供详细、可靠的依据和支持，以便有违反系统安全规则的事件发生后能够有效地追查事件发生的地点和过程。操作系统必须能够生成、维护及保护审计过程，防止其被非法修改、访问和毁坏，特别是要保护审计数据，严格限制未经授权的用户访问。</p></li>
</ul>
<h2 id="操作系统攻击技术-p177">26. 操作系统攻击技术 P177</h2>
<blockquote>
<p>有哪些</p>
</blockquote>
<ul>
<li><p>针对认证的攻击：</p>
<p>操作系统通过认证手段鉴别并控制计算机用户对系统的登录和访问，但由于操作系统提供了多种认证登录手段，利用系统在认证机制方面的缺陷或者不健全之处，可以实施对操作系统的攻击。包括：利用字典攻击或者暴力破解等手段，获取操作系统的账号、口令；利用Windows的IPC$功能，实现空连接并传输恶意代码；利用远程终端服务即3389端口，开启远程桌面控制等。</p></li>
<li><p>基于漏洞的攻击：</p>
<p>系统漏洞是攻击者对操作系统进行攻击时经常利用的手段。系统存在漏洞的情况下，通过攻击脚本，可以使攻击者远程获得对操作系统的控制。Windows操作系统的漏洞由微软公司每月定期以安全公告的形式对外公布，对系统威胁最大的漏洞包括远程溢出漏洞、本地提权类漏洞、用户交互类漏洞等。</p></li>
<li><p>直接攻击：</p>
<p>直接攻击是攻击者在对方防护很严密的情况下，通常采用的一种攻击方法。例如，当操作系统的补丁及时打上，并配备防火墙、防病毒、网络监控等基本防护手段时，通过上面的攻击手段就难以奏效。此时，攻击者采用电子邮件，以及QQ、MSN等即时消息软件，发送带有恶意代码的信息，通过诱骗对方点击，安装恶意代码。这种攻击手段，可直接穿过防火墙等防范手段对系统进行攻击。</p></li>
<li><p>被动攻击：</p>
<p>被动攻击是在没有明确的攻击目标，并且对方防范措施比较严密情况下的一种攻击手段。主要是通过建立或者攻陷一个对外提供服务的应用服务器，篡改网页内容，设置恶意代码，诱骗普通用户点击的情况下，对普通用户进行的攻击。由于普通用户不知网页被篡改后含有恶意代码，自己点击后被动地安装上恶意软件，从而被实施了对系统的有效渗透。</p></li>
<li><p>攻击成功后恶意软件的驻留：</p>
<p>攻击一旦成功后，恶意软件的一个主要功能是对操作系统的远程控制，并通过信息回传、开启远程连接进行远程操作等手段造成目标计算机的信息泄漏。恶意软件一旦人侵成功，将采用多种手段在目标计算机进行驻留，例如通过写人注册表实现开机自动启动，采用rootkit技术进行进程、端口、文件隐藏等，目的就是实现自己在操作系统中不被发现，以更长久地对目标计算机进行控制。</p></li>
</ul>
<h2 id="数据库完整性-p186">27. 数据库完整性 P186</h2>
<blockquote>
<p>有哪些</p>
</blockquote>
<ul>
<li>实体完整性，指表和它模仿的实体一致。</li>
<li>域完整性，指某一项的值是合理的。</li>
<li>参照完整性，指在一个数据库的多个表中保持一</li>
<li>用户定义完整性，由用户自定义。</li>
<li>分布式完整性。</li>
</ul>
<h2 id="数据库攻击技术-p187">28. 数据库攻击技术 P187</h2>
<blockquote>
<p>有哪些</p>
</blockquote>
<p>针对数据库的攻击有多种形式，攻击的最终目标是控制数据库服务器或者得到对数据库的访问权限。主要的数据库攻击手段包括：</p>
<ul>
<li><p>弱口令攻击</p>
<p>获取目标数据库服务器的管理员口令有多种方法和工具，例如针对SQL服务器的SQLScan字典口令攻击，SQLDict字典口令攻击、SQL Server Sniffer嗅探口令攻击等工具。获取了SQL数据库服务器的口令后，即可利用SQL远程连接并进人SQL数据库内获得敏感信息。</p></li>
<li><p>SQL注入攻击</p>
<p>SQL注人攻击的具体过程：首先是由攻击者通过向Web服务器提交特殊参数，向后台数据库注人精心构造的SQL语句，达到获取数据库里的表的内容或者挂网页木马，进一步利用网页木马再挂上木马。攻击者通过提交特殊参数和精心构造的SQL语句后，根据返回的页面判断执行结果、获取敏感信息。因为SQL注人是从正常的WWW端口访问，而且表面看起来与一般的Web页面访问没有区别，所以目前通用的防火墙都不会对SQL注入发出警报，如果管理员没查看IIS日志的习惯，可能被人侵很长时间也不被察觉。SQL注人的手法相当灵活，在注人时会遇到意外情况。在实际攻击过程中，攻击者根据具体情况进行分析，构造巧妙的SQL语句，从而达到渗透的目的，而渗透的程度和网站的Web应用程序的安全性和安全配置有很大关系。</p></li>
<li><p>利用数据库漏洞进行攻击</p>
<p>利用数据库本身的漏洞实施攻击，获取对数据库的控制权和对数据的访问权，或者利用漏洞实施权限的提升。不同版本数据库的漏洞不一样。例如，Oracle 9.2.0.1.0存在认证过程的缓冲区溢出漏洞，攻击者通过提供一个非常长的用户名，会使认证出现滥出，允许攻击者获得对数据库的控制，这使得没有正确的用户名和密码也可获得对数据库的控制。利用Oracle的left outer joins漏洞可以实现权限的提升。当攻击者利用left outer joins实现查询功能时，数据库不做权限检查，使攻击者获得他们一般不能访问的表的权限。</p></li>
</ul>
<h2 id="数据库的安全防范-p188">29. 数据库的安全防范 P188</h2>
<blockquote>
<p>有哪些</p>
</blockquote>
<p>为了有效防止针对数据库的攻击，要从前台的Web页面和后台的数据库服务器设置等多个层次进行统一考虑。</p>
<ul>
<li><p>编写安全的Web页面</p>
<p>SQL注人漏洞是因为Web程序员所编写的Web应用程序没有严格地过滤从客户端提交至服务器的参数而引起的。所以，要防范SQL注人攻击，首先要从编写安全的Web应用程序开始做起。对于客户端提交过来的参数，都要进行严格的过滤，检查当中是否存在着特殊字符，要注意的特殊字符有：单引号、双引号、当前使用的数据库服务器所支持的注释符号、SQL语句中所使用的关键字。除了严格检验参数，还要注意不向客户端返回程序发生异常的错误信息，这是因为SQL注入很大程度上是依赖程序的异常信息获取服务器的信息的，所以不能为攻击者留下任何线索。</p></li>
<li><p>设置安全的数据库服务器</p>
<ul>
<li>SQL Sever：
<ul>
<li>安装：将数据库默认自动或者手动安装使用Windows认证，这将把暴力攻击SQL Server本地认证机制的攻击者拒之门外。为数据库分配一个强壮的SA账户密码。</li>
<li>设置：使用服务器网络程序(Server Network Utility)可禁用所有的netlib，这将使对数据库的远程访问无效，同时也将使SQL Server不再响应SQLPing等对数据库的扫描和探测行为。激活数据库的日志功能可以在攻击者进行暴力破解时能够有效鉴别。此外，禁止SQL Server Enterprise Manager自动为服务账号分配权限，禁用Ad Hoc查询，设置操作系统访问控制列表,清除危险的扩展存储过程等措施将阻止一些攻击者对数据库的非法操作。</li>
<li>维护：采取及时更新服务包和漏洞补丁，分析异常的网络通信数据包，创建SQL Server警报等方法，可以为管理员提供针对数据库的更加有效的防范措施。</li>
</ul></li>
<li>Oracle：
<ul>
<li>设置监听器密码，运行监听器控制程序连接相关的监听器时，可通过密码保护监听器的安全。</li>
<li>删除PL/SQL外部存储功能，堵住攻击者对其的非法使用。</li>
<li>确保所有数据库用户的默认密码已经更改为安全的新密码。</li>
<li>为保证数据库实例的安全，及时更新最新补丁。</li>
<li>如果Oracle数据库的前端是一个Web服务器，则Web前端将是外部攻击者的第一站，需要保证Web前端的安全。</li>
</ul></li>
<li>MySQL：
<ul>
<li>消除授权表的通配符。</li>
<li>使用安全密码。</li>
<li>检查配置文件的许可。</li>
<li>对客户端服务器传输进行加密。</li>
<li>禁用远程访问功能和积极监控MySQL的访问日志。</li>
</ul></li>
</ul></li>
</ul>
<h2 id="软件系统攻击技术-p190">30. 软件系统攻击技术 P190</h2>
<p>常见的利用软件缺陷对应用软件系统发起攻击的技术包括缓冲区溢出攻击、堆溢出攻击、栈溢出攻击、格式化串漏洞利用等，在上述漏洞利用成功后，往往借助于shellcode跳转或者执行攻击者的恶意程序。</p>
<ul>
<li><p>缓冲区溢出利用：</p>
<p>如果应用软件存在缓冲区溢出漏洞，可利用此漏洞实施对软件系统的攻击。缓冲区是内存中存放数据的地方。在程序试图将数据放到机器内存中的某一个位置的时候，如果没有足够的空间就会发生缓冲区溢出。攻击者写一个超过缓冲区长度的字符串，程序读取该段字符串，并将其植入到缓冲区，由于该字符串长度超出常规的长度，这时可能会出现两个结果：一个结果是过长的字符串覆盖了相邻的存储单元，导致程序出错，严重的可导致系统崩溃；另一个结果就是利用这种漏洞可以执行任意指令，从而达到攻击者的某种目的。程序运行的时候，将数据类型等保存在内存的缓冲区中。为了不占用太多的内存，一个由动态分配变量的程序在程序运行时才决定给它们分配多少内存空间。如果在动态分配缓冲区中放入超长的数据，就会发生溢出。这时候程序就会因为异常而返回，如果攻击者用自己攻击代码的地址覆盖返回地址，这个时候，通过eip改变返回地址，可以让程序转向攻击者的程序段，如果在攻击者编写的shellcode里面集成了文件的上传、下载等功能，获取到root权限，那么就相当于完全控制了被攻击方，也就达到了攻击者的目的。</p></li>
<li><p>栈溢出利用：</p>
<p>程序每调用一个函数，就会在堆栈里申请一定的空间，我们把这个空间称为丽数栈，而随着丽数调用层数的增加，函数栈一块块地从高端内存向低端内存地址方向延伸。反之，随着进程中函数调用层数的减少，即各函数调用的返回，函数栈会一块块地被遗弃而向内存的高址方向回缩。各函数的栈大小随着函数的性质的不同而不等,由函数的局部变量的数目决定。进程对内存的动态申请是发生在Heap（堆）里的。也就是说，随着系统动态分配给进程的内存数量的增加，Heap依赖于不同CPU的实现有可能向高址或低址延伸。但一般来说是向内存的高地址方向增长的。当发生函数调用时，先将函数的参数压入栈中，然后将函数的返回地址压人栈中，这里的返回地址通常是Call的下一条指令的地址。例如定义buffer时程序可分配24个字节的空间，在strcpy执行时向buffer里复制字符串时并未检查长度，向buffer里复制的字符串如果超过24个字节，就会产生溢出。如果向buffer里复制的字符串的长度足够长，把返回地址覆盖后程序就会出错。一般会报段错误或者非法指令，如果返回地址无法访问，则产生段错误，如果不可执行则视为非法指令。</p></li>
<li><p>堆溢出利用：</p>
<p>堆内存由分配的很多的大块内存区组成，每一块都含有描述内存块大小和其他一些细节信息的头部数据。如果堆缓冲区遭受了溢出,攻击者能重写相应堆的下一块存储区，包括其头部。如果重写堆内存区中下一个堆的头部信息，则在内存中可以写进任意数据。然而，不同目标软件各自特点不同，堆溢出攻击实施较为困难。</p></li>
<li><p>格式化串漏洞利用：</p>
<p>所谓格式化串，就是在 * printf()系列函数中按照一定的格式对数据进行输出，可以输出到标准输出，即printf()，也可以输出到文件句柄、字符串等，对应的函数有fprintf、sprintf、snprintf、vprintf、vfprintf、vsprintf、vsnprintf等。能被黑客利用的地方也就出在这一系列的 * printf()函数中。在正常情况下这些函数只是把数据输出，不会造成什么问题，但是 * printf()系列函数有三条特殊的性质，这些特殊性质如果被黑客结合起来利用，就会形成漏洞。可以被黑客利用的*printf()系列函数的三个特性：</p>
<ul>
<li>参数个数不固定造成访问越界数据。</li>
<li>利用%n格式符写人跳转地址。</li>
<li>利用附加格式符控制跳转地址的值。</li>
</ul></li>
<li><p>shellcode 技术：</p>
<p>缓冲区溢出成功后，攻击者如希望控制目标计算机，必须用shellcode实现各种功能。shellcode是一堆机器指令集，基于x86平台的汇编指令实现，用于溢出后改变系统的正常流程，转而执行shellcode代码从而完成对目标计算机的控制。</p></li>
</ul>
<h2 id="数据备份的方式-p193">31. 数据备份的方式 P193</h2>
<blockquote>
<p>选择什么样的备份方式</p>
</blockquote>
<p>按备份的数据量划分：</p>
<ul>
<li>完全备份，备份系统中的所有数据，特点是备份所需的时间最长，但恢复时间最短，操作最方便，也最可靠。</li>
<li>增量备份，只备份上次备份以后有变化的数据，特点是备份时间较短，占用空间较少，但恢复时间较长。</li>
<li>差分备份，只备份上次完全备份以后有变化的数据，特点是备份时间较长，占用空间较多，但恢复时间较快。</li>
<li>按需备份，根据临时需要有选择地进行数据备份。</li>
</ul>
<p>决定采用何种备份方式，还取决于以下两个重要因素：</p>
<ul>
<li>备份窗口，完成一次给定备份所需的时间，这个备份窗口由需要备份数据的总量和处理数据的网络架构的速度来决定。</li>
<li>恢复窗口，恢复整个系统所需的时间，恢复窗口的长短取决于网络的负载和磁带库的性能及速度。</li>
</ul>
<p>在实际应用中，必须根据备份窗口和恢复窗口的大小，以及整个数据量，决定采用何种备份方式。一般来说，差分备份避免了完全备份和增量备份的缺陷，又具有它们的优点。差分备份无须每天都做系统完全备份，并且灾难恢复很方便，只需要上一全备份磁带和灾难发生前一天磁带就可以完全恢复数据，因此采用完全备份结合差分备份的方式较为适宜。</p>
<h2 id="数据备份的状态-p193">32. 数据备份的状态 P193</h2>
<blockquote>
<p>冷备份、热备份</p>
</blockquote>
<p>按备份状态来划分：</p>
<ul>
<li>物理备份是指将实际物理数据库文件从一处复制到另一处的备份，冷备份、热备份都属于物理备份。
<ul>
<li>冷备份，也称脱机（Offline）备份，是指以正常方式关闭数据库，并对数据库的所有文件进行备份。其缺点是需要一定的时间来完成，在备份期间，最终用户无法访问数据库，而且这种方法不易做到实时的备份。</li>
<li>热备份，也称联机（Online）备份，是指在数据库打开和用户对数据库进行操作的情况下进行的备份；也指通过使用数据库系统的复制服务器，连接正在运行的主数据库服务器和热备份服务器，当主数据库的数据修改时，变化的数据通过复制服务器可以传递到备份数据库服务器中，保证两个服务器中的数据一致。这种热备份方式实际上是一种实时备份，两个数据库分别运行在不同的机器上，并且每个数据库都写到不同的数据设备中。</li>
</ul></li>
<li>逻辑备份就是将某个数据库的记录读出并将其写人到一个文件中，这是经常使用的一种备份方式。MySQL和Oracle等都提供Export/Import工具来用于数据库的逻辑备份。</li>
</ul>
<h1 id="七信息内容安全">七、信息内容安全</h1>
<h2 id="版权保护-p204">33. 版权保护 P204</h2>
<blockquote>
<p>DRM名词解释看一下</p>
</blockquote>
<p>版权（又称“著作权”）保护是内容保护的重要部分，其最终目的不是如何防止使用，而是如何控制使用，版权保护的实质是一种控制版权作品使用的机制。</p>
<p>数字版权管理（Digital Rights Management，DRM）技术就是以一定安全算法实现对数字内容的保护，包括电子书、视频、音频、图片等数字内容。DRM技术的目的是从技术上防止数字内容的非法复制，用户必须在得到授权后才能使用数字内容。</p>
<p>DRM涉及的主要技术包括：</p>
<ul>
<li>数字标识技术。</li>
<li>安全和加密技术。</li>
<li>安全存储技术。</li>
</ul>
<p>DRM技术方法主要有两类：</p>
<ul>
<li>数字水印技术。</li>
<li>以数据加密和防复制为核心的DRM技术。</li>
</ul>
<h1 id="八云计算与云安全">八、云计算与云安全</h1>
<h2 id="虚拟化技术-p219">34. 虚拟化技术 P219</h2>
<blockquote>
<p>虚机和物理机的区别</p>
</blockquote>
<p>虚拟化的目的在于集中IT管理任务，简化运维流程与降低成本，同时改善企业计算资源有效利用率和可用性，使得企业更能够快速响应商务需求以及提升竞争力。简单地说，虚拟化就是改善传统的一台物理服务器上运行一个应用程序的模式，让物理服务器硬件及网络资源能够被充分利用的配置，使得一台物理服务器上能够运行多个互相独立的虚拟机，并执行多个应用服务程序。云计算模式以较少的硬件资源实现更多更有效率的企业服务，节省总拥有成本。虚拟化可实现于私有云、混合云与共有云计算平台上，取决于企业服务形态与需求。虚拟机是一个由软件实现，完全隔离的客操作系统（Guest OS），运行于原本的主操作系统（Host OS）中，并有独立的计算环境。虚拟机就像物理机一样，包含自己的CPU、内存（RAM）、外存（DISK）和网卡（NIC）等。虚拟机完全是由软件构成的，就是由一个或多个文件所组成，完全没有硬件组件。因此，虚拟机提供了企业IT环境更多的弹性与好处，尤其是更快的服务维护及部署和更简单的备份管理。</p>
<h2 id="云计算服务层次-p221">35. 云计算服务层次 P221</h2>
<blockquote>
<p>三个层次的定义、区别</p>
</blockquote>
<p>云计算服务是指将大量用网络连接的计算资源统一管理和调度，构成一个计算资源池向用户按需服务。用户通过网络以按需、易扩展的方式获得所需资源和服务。云计算包括三个层次服务：基础设施即服务（IaaS）平台即服务（PaaS）和软件即服务（SaaS）。所谓层次，是分层体系架构意义上的“层次”：</p>
<ul>
<li>IaaS（ Infrastructure as a Service）基础设施级服务，消费者通过Internet可以从完善的计算机基础设施获得服务。IaaS是把数据中心、基础设施等硬件资源通过Web分配给用户的商业模式。</li>
<li>PaaS（ Platform as a Service）平台级服务，是指将软件研发的平台作为一种服务，以SaaS的模式提交给用户。因此PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度。PaaS 服务使得软件开发人员可以在不购买服务器等设备环境的情况下开发新的应用程序。</li>
<li>SaaS（ Software as a Service）软件级服务，是一种通过Internet提供软件的模式，用户无须购买软件，而是向提供商租用基于Web的软件，来管理企业经营活动。SaaS模式大大降低了软件的使用成本和客户的管理维护成本，由于软件是托管在服务商的服务器上，可靠性也更高。</li>
</ul>
<h1 id="九信息安全管理">九、信息安全管理</h1>
<h2 id="信息安全管理-p230">36. 信息安全管理 P230</h2>
<blockquote>
<p>“三分技术，七分管理”、PDCA</p>
<p>别选错“四分技术，六分管理”</p>
</blockquote>
<p>当今社会已经进人到信息化社会，其信息安全是建立在信息社会的基础设施及信息服务系统之间的互联、互通、互操作意义上的安全需求上，安全需求可以分为安全技术需求和安全管理需求两个方面。管理在信息安全中的重要性高于安全技术层面，“三分技术，七分管理”的理念在业界中已经得到共识。信息安全管理体系（ Information Security Management System， ISMS）是从管理学惯用的过程模型PDCA（Plan、Do、Check、Act）发展演化而来。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-06-30T16:00:00.000Z" itemprop="datePublished">2022/07/01</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%BD%91%E7%BB%9C/" rel="tag">计算机 - 网络</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-医学影像学"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E5%AD%A6/">医学影像学（含试题）</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="医学影像学">医学影像学</h1>
<h2 id="多层螺旋ct">1. 多层螺旋CT</h2>
<p>多层螺旋CT(mulislie spiral CT， MSCT)在功能上进一步完善，具有很多优点：</p>
<p>①扫描速度快，大多数检查可在患者一次屏气时间内完成，可有效减少呼吸运动伪影，方便危重患者及婴幼儿患者的检查，并可一次注射对比剂后完成器官的多期扫描，有利于病灶的检出和定性。</p>
<p>②容积数据可避免小病灶的遗漏。</p>
<p>③可进行高质量的</p>
<p>任意层面的多平面重建(multiple planarre construction， MPR)</p>
<p>最大强度投影(maximum intensity projection， MIP)</p>
<p>表面遮盖显示(shaded surface display， SSD)</p>
<p>容积显示技术(volume rendering technique， VRT)</p>
<p>CT血管造影(CT angiography， CTA)</p>
<p>CT灌注成像(CT perfusion imaging， CTPI)</p>
<p>CT仿真内镜成像( CT virtual endoscopy， CTVE)</p>
<p>等后处理，丰富并拓展了CT的应用范围，诊断准确性也有很大提高。</p>
<pre><code>3.螺旋 CT 扫描与传统 CT 扫描相比最重要的优势是
A.扫描速度快
B.二维或三维成像效果好 
C.重建速度快
D.积扫描
E.单层或多层连续扫描
A</code></pre>
<h2 id="ct图像特点">2. CT图像特点</h2>
<p>CT图像是数字化模拟灰度图像，灰度反映的是相应体素(Voxel)的X线吸收系数</p>
<table>
<thead>
<tr class="header">
<th>密度</th>
<th>颜色</th>
<th>组织</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>低密度</td>
<td>呈黑色影像</td>
<td>含气的肺组织</td>
</tr>
<tr class="even">
<td>中等密度</td>
<td>呈灰色影像</td>
<td>肌肉、脏器等软组织</td>
</tr>
<tr class="odd">
<td>高密度</td>
<td>呈白色影像</td>
<td>骨组织</td>
</tr>
</tbody>
</table>
<p>CT图像具有较高的密度分辨力，但空间分辨力（像素越小越高）不及常规X线图像</p>
<p>CT图像的密度能够进行量化评估，CT值(-1000 ~ +1000HU， 对应吸收系数空气为0，水为1，骨皮质为2)</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>提高</th>
<th>降低</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>窗位</td>
<td>图像变黑</td>
<td>图像变白</td>
</tr>
<tr class="even">
<td>窗宽</td>
<td>对比度下降</td>
<td>对比度上升</td>
</tr>
</tbody>
</table>
<p>CT图像为断层图像，克服了普通X线检查各组织结构影像重叠的缺点，但不利于器官结构和病灶的整体显示，需要连续观察多帧图像。</p>
<p>在一个扫描层面的厚度方向内同时含有两种或两种以上密度不同且走行与层面平行的组织时，其所显示的密度并非代表任何一种组织，所测得的CT值为它们的平均值。这种现象称之为部分容积效应或部分容积现象(partial volume phenomenon)，其可影响微小病变的显示和诊断。为了克服这一不利因素，可采用更薄的准直更小的重建层厚和特殊算法进行图像重建，如高分辨力CT(high resolution CT， HRCT)检查，以利微小结构和病变的显示。</p>
<pre><code>6.下列关于窗位的概念，正确的是
A.窗位相当于显示灰阶的中心
B.窗位规定所显示 CT 值的范围
C.不同机器的窗位值不同
D.窗位与所显示的组织 CT 值无关
E.通常窗位选择以水的 CT 值为标准
A

7.下列关于 CT 值的概念，哪一项是正确的
A.CT 值反映了物质的密度
B.CT 值反映了物质内的成分
C.CT 值是物质密度的绝对值
D.不同机器产生的 CT 值不同
E.根据 CT 值可以对病变作出定性诊断
A</code></pre>
<h2 id="mri成像的主要优势">3. MRI成像的主要优势</h2>
<p>多参数成像（T1值、T2值、质子密度等）</p>
<p>多序列成像</p>
<p>多方位成像</p>
<p>软组织分辨能力高</p>
<p>直接进行水成像（对于含有液体的管道系统）</p>
<p>直接进行血管成像</p>
<p>显示组织磁敏感差异性</p>
<p>显示水分子扩散运动</p>
<p>显示组织血流灌注状态</p>
<p>脑功能定位</p>
<p>显示和量化脑区间功能连接</p>
<h2 id="背4.-mri检查的安全性">(背)4. MRI检查的安全性</h2>
<p>MRI设备产生强磁场，需特别注意患者检查的安全性。</p>
<p>MRI检查的禁忌证包括：</p>
<p>安装有心脏起搏器</p>
<p>体内有金属性(铁磁性)内植物，例如手术夹、支架、假体、假关节等</p>
<p>怀孕三个月以内</p>
<p>幽闭恐惧症</p>
<p>患者、家属和医护人员进人MRI检查室时，严禁携带任何铁磁性物体，例如金属发夹、硬币、别针、金属性医疗器械等，否则不但影响图像质量，且有可能导致严重的人身伤害。</p>
<p>此外，MRI增强检查所用的含钆对比剂，有可能引起肾源性系统性纤维化(nephrogenic systemic fibrosis， NSF)，故肾功能严重受损者禁用此类对比剂。</p>
<h1 id="第二章-中枢神经系统">第二章 中枢神经系统</h1>
<h2 id="脑膜瘤的起源">5. 脑膜瘤的起源</h2>
<p>脑膜瘤起源于蛛网膜粒帽细胞，多居于脑外，与硬脑膜粘连。</p>
<pre><code>9．下列哪一项是脑膜瘤典型 CT 表现：
A．钙化、囊变坏死
B．骨质破坏
C．明显瘤周水
D．多为等密度，明显均匀增强
E．占位效应明显
D

27．下列关于脑膜瘤的描述，不正确的是：
A．女性多见
B．与硬脑膜粘连紧
C．多有包膜
D．均为实性肿块
E．多呈较高密度
D

56.发生脑膜瘤概率最小的部位是
A.矢状窦旁
B.脑凸面
C.蝶骨嵴
D.嗅沟
E.脑室内
E</code></pre>
<h2 id="硬膜外血肿与硬膜下血肿的鉴别">6. 硬膜外血肿与硬膜下血肿的鉴别</h2>
<p>硬膜外血肿(epidural hematoma)：多由脑膜血管损伤所致，脑膜中动脉常见；血液聚集硬膜外间隙，由于硬膜与颅骨内板附着紧密，故血肿较局限，呈梭形。</p>
<p>硬膜下血肿(subdural hematoma)：多由桥静脉或静脉窦损伤出血所致，血液聚集于硬膜下腔，沿脑表面广泛分布。</p>
<pre><code>13．急性硬膜外出血典型 CT 表现是
A．颅骨内板下方双凸形低密度区
B．颅骨内板下方双凸形高密度区
C．颅骨内板下方新月形高密度区
D．颅骨内板下方新月形低密度区
E．颅骨内板下方双凹形高密度区
B

14．急性硬膜下出血典型 CT 表现是
A．颅骨内板下方双凸形低密度区
B．颅骨内板下方双凸形高密度区
C．颅骨内板下方新月形高密度区
D．颅骨内板下方新月形低密度区
E．颅骨内板下方双凹形低密度区
C

48.患者男，26 岁。头颅外伤 4 小时。CT 轴位平扫示右颞骨骨折，头皮血肿，右颞部校形不均匀高密度，中线结构左移，最可能诊断为：
A. 右颞部急性硬膜外血肿
B．右颞部急性硬膜下血肿
C．右颞叶急性脑血肿
D．右颞叶脑挫裂伤伴硬膜下血肿
E．右颞部亚急性硬膜外血肿
A

60.关于急性硬膜外血肿的 CT 检查，哪种说法不正确
A.颅板下见梭形或半圆形高密度影
B.颅板下见新月形高密度影
C.多位于骨折附近
D.血肿多较局限
E.多由脑膜血管损伤所致
B

61.关于急性硬膜下血肿的 CT 检查，哪种说法不正确
A.颅板下见新月形高密度影
B.多由桥静脉或静脉窦损伤出血所致
C.大多伴发颅骨骨折
D.血肿多沿脑表面广泛分布
E.常伴有脑挫裂伤，脑水肿及占位征象
C</code></pre>
<h2 id="背7.-脑出血ct表现">(背)7. 脑出血CT表现</h2>
<p>平扫：</p>
<p>①急性期：血肿呈边界清楚的肾形、类圆形或不规则形均匀高密度影；周围水肿带宽窄不一，局部脑室受压移位(图2-15)；破入脑室可见脑室内高密度积血</p>
<figure>
<img src="../images/2-15.png" alt="2-15" /><figcaption aria-hidden="true">2-15</figcaption>
</figure>
<p>②亚急性期：始于出血后2~7天，可见血肿缩小并密度减低，血肿周边变模糊；水肿带增宽；小血肿可完全吸收</p>
<p>③慢性期，为出血2个月以后，较大血肿吸收后常遗留大小不等的裂隙状囊腔；伴有不同程度的脑萎缩。</p>
<p>增强扫描：</p>
<p>血肿早期多不强化，亚急性期由于血肿周围炎症反应及新生毛细血管而出现环状强化。</p>
<h1 id="第四章-呼吸系统">第四章 呼吸系统</h1>
<h2 id="空洞和空腔">8. 空洞和空腔</h2>
<p>空洞(cavity)为肺内病变组织发生坏死并经引流支气管排出后所形成。空洞壁可为坏死组织、肉芽组织、纤维组织或肿瘤组织，多见于<strong>肺结核肺癌</strong>和<strong>真菌病</strong>等。根据洞壁的厚度可分为厚壁空洞与薄壁空洞，前者的洞壁厚度≥3mm，后者的洞壁厚度&lt;3mm。</p>
<p>空腔(intrapulmonary air containing space)与空洞不同，是肺内生理腔隙的病理性扩大，如<strong>肺大疱</strong>、<strong>含气肺囊肿</strong>及<strong>肺气囊</strong>等都属于空腔。</p>
<pre><code>10．伴有液平面的空洞最常见于：
A 肺癌
B 肺脓肿
C 结核球
D 肺炎
E 结核空洞
B

29．青年患者，右肺下叶背段见一薄壁空洞，应首先考虑：
A 肺脓疡
B 肺结核
C 肺癌
D 先天性肺囊肿
E 肺包虫囊肿
B

31．右肺上叶后段薄壁空洞，直径 4cm，内有较小的液面，空洞周围肺内有渗出病变，右下肺及左肺中下野有多发斑片状渗出选择可能性较大的诊断：
A 肺结核病(干酷性肺炎) 
B 肺脓肿
C 血源性肺脓肿 
D 空洞型肺癌
E 肺霉菌病
A</code></pre>
<h2 id="常见的肺间质病变">9. 常见的肺间质病变</h2>
<p>慢性支气管炎</p>
<p>特发性肺纤维化</p>
<p>癌性淋巴管炎</p>
<p>尘肺</p>
<p>结缔组织病</p>
<h2 id="原发型肺结核">10. 原发型肺结核</h2>
<p>原发型肺结核包括原发综合征和胸内淋巴结结核，多见于儿童和青少年，少数可为成年人。</p>
<p>X线：原发综合征典型呈“哑铃”状表现，包括：</p>
<p>①原发浸润灶：邻近胸膜处的肺内原发病灶，多位于中上肺野，呈圆形、类圆形或局限性斑片影</p>
<p>②淋巴管炎：为自原发病灶向肺门走行的不规则条索状影</p>
<p>③肺门、纵隔淋巴结增大：表现为肺门影增大或纵隔淋巴结增大，并突向肺野(图4-32)。</p>
<figure>
<img src="../images/4-32.png" alt="4-32" /><figcaption aria-hidden="true">4-32</figcaption>
</figure>
<pre><code>28．原发性肺结核最典型 X 线征象是：
A 肺内浸润阴影
B 肺门淋巴结肿大
C 纵隔淋巴结肿大
D 哑铃征
E 胸腔积液
D</code></pre>
<h2 id="中晚期中央型肺癌">11. 中晚期中央型肺癌</h2>
<p>X线胸片和CT检查常有明确表现。</p>
<p>X线：胸片上主要表现为肺门区肿块，呈分叶状或边缘不规则形，常可伴有阻塞性肺炎或肺不张(图4-44a)。</p>
<p>CT：可清晰显示支气管腔内或壁内外肿块、管壁不规则和管腔呈“鼠尾状”狭窄或“锥形”“杯口状”截断(图4-44b)；阻塞性肺炎表现为受累支气管远侧肺组织实变，多为散在分布；发生肺不张时则表现肺叶或肺段的均匀性密度增高并伴有容积缩小。另外，增强CT可清楚显示中央型肺癌是否侵犯纵隔结构(或)是否伴有肺门、纵隔淋巴结转移，尤其对判断血管是否受侵或受压移位、管腔变窄或闭塞、管壁不规则等更为敏感。</p>
<figure>
<img src="../images/4-44.jpeg" alt="4-4" /><figcaption aria-hidden="true">4-4</figcaption>
</figure>
<pre><code>40．肺结核与肺癌在普通 X 线检查上，下列哪一征象是错误的：
A 都可以形成空洞
B 都可以形成球形
C 都可以出现钙化灶
D 都可以出现播散灶
E 都可以合并肺炎
C</code></pre>
<h1 id="第五章-循环系统">第五章 循环系统</h1>
<h2 id="心脏正常x线表现">12. 心脏正常X线表现</h2>
<p>正位X线胸片上左心缘由三段构成，上段凸出的为主动脉结，中段为肺动脉段，下段为左心室。右心缘由两段构成，上段为升主动脉和上腔静脉的复合投影，下段为右心房(图5-1)。心胸比率，为心脏横径与最大胸廓横径之比，该比值的正常成人上限是0.5(图5-2)。</p>
<figure>
<img src="../images/5-1.png" alt="5-1" /><figcaption aria-hidden="true">5-1</figcaption>
</figure>
<h2 id="背13.-心脏整体形态异常">(背)13. 心脏整体形态异常</h2>
<p>二尖瓣型：呈梨形，主动脉结较小，肺动脉段丰满或突出，左心缘下段圆钝，右心缘下段较膨隆，常见于<strong>二尖瓣病变</strong>、<strong>房间隔缺损</strong>等</p>
<p>主动脉瓣型：主动脉结增宽，肺动脉段内凹，左心缘下段向左下延长，常见于<strong>主动脉瓣病变</strong>，<strong>高血压性心脏病</strong>等</p>
<p>普大型：心脏向两侧均匀增大，较对称，常见于<strong>心脏衰竭</strong>、<strong>大量心包积液</strong>等</p>
<figure>
<img src="../images/5-13.png" alt="5-13" /><figcaption aria-hidden="true">5-13</figcaption>
</figure>
<h2 id="肺血异常">14. 肺血异常</h2>
<p>肺血增多：常见于左向右分流的先天性心脏病，如<strong>房或室间隔缺损</strong>、<strong>动脉导管未闭</strong>。X线胸片主要表现为，肺动脉主干和分支成比例地增粗，边缘清晰锐利，肺野透明度正常(图5-16a)。 肺血减少：由右心排血受阻引起，常见于<strong>三尖瓣狭窄</strong>、<strong>肺动脉狭窄</strong>等。X线胸片主要表现为，肺野透明度增加，肺门动脉变细，肺内血管稀疏、变细(图5-16b)。</p>
<figure>
<img src="../images/5-16.jpeg" alt="5-16" /><figcaption aria-hidden="true">5-16</figcaption>
</figure>
<pre><code>8．X 线表现为肺血少，左、右肺门不对称，左侧&gt;右侧，肺动脉段呈直立样突起，最可靠的诊断是：
A 肺心病
B 高血压性心脏病
C 肺动脉狭窄
D 主动脉缩窄
E 动脉导管未闭
C</code></pre>
<h2 id="心脏瓣膜病x线表现">15. 心脏瓣膜病X线表现</h2>
<p>①二尖瓣狭窄：表现为肺淤血，甚至肺水肿，心影呈二尖瓣型，肺动脉段突出，左心房及右心室增大</p>
<p>②二尖瓣关闭不全：可见左心房室增大，根据左心功能情况，出现肺部改变</p>
<p>③主动脉瓣狭窄：左心室不同程度增大，升主动脉中段局限性扩张</p>
<p>④主动脉瓣关闭不全：左心室增大，升主动脉、主动脉弓普遍扩张</p>
<p>⑤联合瓣膜病：心脏增大，受累较重瓣膜病变的表现更为突出</p>
<pre><code>11．诊断风湿性心脏病二尖瓣严重损害，最重要的 X 线征象是：
A. 肺循环高压
B. 左心房重度增大
C. 二尖瓣区钙化
D. 右心房重度增大
E. 重度间质性肺水肿
D

18. 下列关于二尖瓣型心脏的描述，哪个是错误的：
A. 肺动脉段凸出及心尖上翘
B. 主动脉结缩小
C. 形如梨形
D. 反映右心负荷或以其为主的心腔变化
E. 肺动脉段凹陷及心尖下移
E</code></pre>
<h1 id="第七章-消化系统与腹膜腔">第七章 消化系统与腹膜腔</h1>
<h2 id="食管癌">16. 食管癌</h2>
<p>食管癌(esophageal carcinoma)好发于40 ~70岁男性。大体分三型</p>
<p>①浸润型：管壁呈环状增厚、管腔狭窄</p>
<p>②增生型：肿瘤向腔内生长形成肿块</p>
<p>③溃疡型：肿块形成一局限性大溃疡，深达肌层</p>
<p>以上各型可混合出现。临床主要症状是进行性吞咽困难。</p>
<p>影像学表现：</p>
<p>X线：食管癌的X线造影表现可概括为以下几点：</p>
<p>①黏膜皱襞破坏，代之以肿瘤表面杂乱不规则的影像</p>
<p>②管腔狭窄，表现为局限性狭窄，管壁僵硬，钡剂通过受阻，其上方食管扩张(图7-5a)</p>
<p>③充盈缺损，肿瘤向腔内突出，造成形状不规则的充盈缺损(图7-5b)</p>
<p>④不规则的龛影(图7-5c)</p>
<p>⑤受累段食管局限性僵硬。</p>
<figure>
<img src="../images/7-5.png" alt="7-5" /><figcaption aria-hidden="true">7-5</figcaption>
</figure>
<p>以上表现常不同程度地同时存在。食管X线造影可明确肿瘤的位置及病变的范围，有利于临床选择适宜的治疗方案。</p>
<p>CT：食管癌的CT表现为食管局部管壁不规则增厚或呈肿块样；还可显示纵隔淋巴结有无增大及肺内有无转移灶。</p>
<p>诊断与鉴别诊断：</p>
<p>依据吞咽困难病史及X线造影的表现即可诊断。鉴别诊断主要包括：</p>
<p>①食管平滑肌瘤，表现为来自食管壁的、边缘光滑锐利的局限性肿块，表面黏膜大多光整</p>
<p>②食管静脉曲张(见食管静脉曲张鉴别诊断)</p>
<pre><code>13.早期食管癌的检出率在什么方法中检查中较高
A. X 线 
B. CT
C. MRI 
D. 超声
E. DSA
A

16.早期食管癌的描述，不正确的是
A．指局限于粘膜和粘膜下层的病变
B．不论病变范围多大，无周围及远处淋巴结转移
C．吞钡检查可见粘膜有中断和破坏
D．吞钡检查可见小的龛影和充盈缺损
E．双对比造影和食管吞钡连续摄影检查可以提高阳性检出率
B

113.食管钡餐造影时，哪种不属于早期食管癌的 X 线表现
A.食管腔狭窄，其上扩张
B.病变区粘膜增粗、迂曲、紊乱、毛糙、中断
C.紊乱毛糙的粘膜面上出现小龛影
D.出现 0.5-2.0cm 充盈缺损
E.食管壁有一段柔软度和舒张度减低
A

114.食管癌的主要临床症状
A.间断性吞咽困难
B.吞咽困难由重变轻
C.吞咽困难与情绪改变有关
D.无吞咽困难症状
E.进行性吞咽困难
E

115.对食管癌的病理分型，哪项是错误的
A.髓质型 
B.覃伞型
C.溃疡型 
D.缩窄型
E.扩张型
E

123.食管癌的好发部位依次是
A.食管上段、下段、中段
B.食管中段、上段、下段
C.食管下段、中段、上段
D.食管中段、下段、上段
E.食管上、中、下段发病率无明显差异
D</code></pre>
<h2 id="食管静脉曲张">17. 食管静脉曲张</h2>
<p>食管静脉曲张(esophageal varices)是门静脉高压的主要并发症，常见于肝硬化。正常情况下，食管下段的静脉网与门静脉系统的胃冠状静脉、胃短静脉之间存在着吻合，当门静脉压力增高时，来自消化器官及脾的静脉血液回流受阻，大量血液通过胃冠状静脉和胃短静脉进人食管黏膜下静脉和食管周围静脉丛，经奇静脉人上腔静脉，形成食管和胃底静脉曲张。临床上可有呕血和黑便，重者发生失血性休克或死亡。</p>
<p>影像学表现：</p>
<p>X线：X线造影检查：早期食管静脉曲张表现为食管下段黏膜皱襞稍宽或略为迂曲；随着疾病的发展，食管中下段的黏膜皱襞明显增宽、迂曲，呈蚯蚓状或串珠状充盈缺损，管壁边缘呈锯齿状(图7-6)，伴有食管管腔扩张，张力降低，钡剂排空延迟。</p>
<figure>
<img src="../images/7-6.png" alt="7-6" /><figcaption aria-hidden="true">7-6</figcaption>
</figure>
<p>CT和MRI：可同时显示下段食管周围血管增粗、增多、门静脉侧支血管迂曲扩张及肝硬化表现。</p>
<p>诊断与鉴别诊断：</p>
<p>X线造影检查时，发生静脉曲张的食管壁柔软并伸缩自如，是与食管癌的重要鉴别点。CT及MRI增强检查可直接显示增粗、增多的血管。</p>
<pre><code>10．食管静脉曲张的影像学检查方法中最常应用的简便有效的
方法是
A. 食管钡餐检查
B. 食管 CT 检查
C. 食管 MRI 检查
D. 血管造影检查
E. 超声检查
A

12．关于食管静脉曲张的描述，不正确的是
A. 是门静脉高压的主要并发症，常见于肝硬化患者
B. 轻度患者，病变主要局限于食管下段，粘膜皱襞稍增宽，管腔边缘稍不平整
C. 中度患者，病变累及食管中下段，粘膜皱襞增粗呈结节状或串珠状充盈缺损
D. 重度患者，可累及食管全长，粘膜皱襞增粗呈结节状或串珠状充盈缺损，排空延迟
E. 只有中度或重度患者才能在吞钡造影时发现
E

19．38 岁女性患者，钡餐示食管壁张力减低，蠕动减弱，钡剂排空延迟，并在食管下段见到串珠状充盈缺损影。首先考虑
A. 返流性食管炎
B. 食管下段平滑肌瘤
C. 食管下段静脉曲张
D. 食管癌
E. 食管裂孔疝
C</code></pre>
<pre><code>11．在食管癌与食管静脉曲张的鉴别诊断中，下列哪一项最有价值
A. 发生部位 
B. 呕血
C. 男性多 
D. 中老年多见
E. 食管钡餐透视观察食管的蠕动情况
E

28．下列哪些 X 线征象可作为食管静脉曲张与食管癌的鉴别要点
A. 充盈缺损
B. 管腔边缘凹凸不平
C. 钡剂通过缓慢
D. 管壁仍见扩张与收缩现象
E. 纵行粘膜皱襞消失
D</code></pre>
<h2 id="表18.-胃良性溃疡与恶性溃疡x线造影的鉴别诊断">(表)18. 胃良性溃疡与恶性溃疡X线造影的鉴别诊断</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 11%" />
<col style="width: 47%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>良性溃疡</th>
<th>恶性溃疡</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>龛影形状</td>
<td>圆形或椭圆形，边缘光滑整齐</td>
<td>不规则，扁平，有多个尖角</td>
</tr>
<tr class="even">
<td>龛影位置</td>
<td>突出于胃轮廓外</td>
<td>位于胃轮廓之内</td>
</tr>
<tr class="odd">
<td>龛影周围和口部</td>
<td><strong>黏膜水肿</strong>的表现，如<strong>黏膜线</strong>、<strong>项圈征</strong>、<strong>狭颈征</strong>、不规则的环堤、指压痕、裂隙征，黏膜皱等；黏膜皱襞<strong>向龛影集中、直达龛影口部</strong></td>
<td>不规则的环堤、指压痕、裂隙征，黏膜皱襞<strong>中断、破坏</strong></td>
</tr>
<tr class="even">
<td>附近胃壁</td>
<td>柔软，有蠕动</td>
<td>僵硬，峭直，蠕动消失</td>
</tr>
</tbody>
</table>
<pre><code>22．胃溃疡的征象中，下列叙述恰当的是
A．胃溃疡可以见到龛影，其形态可以多变，可呈乳头状、半圆形或锥形
B．根据龛影周围水肿带的不同可以有粘膜线、项圈征和狭颈征
C．溃疡周围粘膜可以呈放射状改变，为溃疡修复性改变
D．可以引起胃的变形，幽门梗阻可导致胃扩张和胃储留
E．以上叙述都正确
E

23．溃疡出现下列哪项征象提示溃疡可能发生恶变
A．溃疡龛影形态呈半圆形突出于胃腔之外
B．龛影周围发现项圈征和狭颈征
C．溃疡周围胃变形或胃储留
D．溃疡周围出现充盈缺损、粘膜破坏或环堤形成
E．以上都不正确
D

27．溃疡型胃癌的 X 线表现，下列那项不正确
A．溃疡大而浅，位于胃轮廓之内，称为腔内龛影。
B．龛影周围可见环堤和指压迹样改变。
C．溃疡周围出现项圈征或狭颈征。
D．溃疡周围胃粘膜中断、破坏。
E．病变部位胃壁僵硬、蠕动消失。
C

31．下述胃溃疡征象，哪项提示为恶性
A. 项圈征
B. 狭颈征
C. 粘膜纠集
D. 腔外龛影
E. 局部胃壁僵硬
E

35．下列为溃疡型胃癌的 X 线征象，错误的是
A. 放射状粘膜纠集，直抵龛影口部
B. 不规则状粘膜纠集，杵状增粗
C. 腔内龛影
D. 指压迹
E. 蠕动消失
A

36．下列为良性溃疡的Ｘ线表现，错误的是
A. 狭颈征
B. 项圈征
C. 肩胛征
D. 放射状粘膜纠集
E. 溃疡口部粘膜线
C

97．下列哪个Ｘ线征象，提示为恶性
A. 放射状粘膜纠集 
B. 腔外龛影
C. 环堤 
D. 项圈征
E. 狭颈征
B

120.胃良性溃疡最常见的发病部位是
A.胃小弯近贲门处
B.胃大弯
C.胃前壁
D.胃小弯及近幽门处
E.胃后壁
D</code></pre>
<h2 id="肝脏">19. 肝脏</h2>
<blockquote>
<p>病变：肿瘤（良性恶性）、炎症性</p>
<p>常见疾病影像表现（尤其是强化方式）</p>
</blockquote>
<p>肝脓肿：炎症</p>
<p>CT增强：脓肿壁呈环形明显强化，分隔也表现明显强化，而脓肿无强化。</p>
<p>肝海绵状血管瘤：良性肿瘤</p>
<p>多期增强CT扫描：呈“早出晚归”强化表现</p>
<p>肝细胞癌：恶性肿瘤</p>
<p>多期增强CT扫描：呈“快进快出”强化表现</p>
<p>肝转移瘤：恶性肿瘤</p>
<p>CT增强：表现与肿瘤血供有关，富血供转移瘤表现为一过性明溪县结节样强化，但更多见的是肿瘤边缘环状强化，而中样坏死区无强化，呈“牛眼征”表现；乏血供转移瘤则表现强化不明显或有延迟强化。</p>
<pre><code>130.以下可以出现环状强化且内壁光滑的是
A.肝癌
B.肝脓肿
C.肝囊肿
D.肝血管瘤
E.肝腺瘤
B

131.肝内血管一般在 T1WI 和 T2WI 均为
A.黑色流空信号
B.等信号
C.高信号
D.低信号
E.混杂信号
A

132.典型肝脓肿的 CT 表现不包括
A.平扫脓腔为圆形低密度区
B.增强扫描呈均质强化
C.平扫脓壁呈环形略低密度
D.增强扫描呈环形强化
E.病灶外周可见低密度水肿带
B

133.CT 发现下列哪种征象可确诊肝脓肿
A.圆形病灶内见气体和/或液平面
B.平扫呈环形略低密度灶
C.增强扫描环形强化
D.增强扫描病灶外周可见低密度水肿带
E.病变边界清晰
A

134.典型肝脓肿的强化特点不包括
A.环形强化
B.壁厚均匀
C.内壁光滑
D.脓壁不强化
E.壁厚薄不均
E

135.肝脓肿环形强化的病理基础是
A.肉芽组织
B.炎性坏死物
C.脓液
D.水肿带
E.受压的血管
A

136.肝脓肿与肝癌表现为环形强化时的鉴别点是
A.肝癌动脉期强化明显，肝脓肿静脉期强化明显
B.肝脓肿壁较薄
C.肝癌的壁较厚
D.肝脓肿壁为高度强化
E.肝癌的壁为中度强化
A

137.肝海绵状血管瘤 CT 强化特点是
A.快进快出
B.快进慢出
C.慢进慢出
D.慢进快出
E.无规律
B

138.关于肝海绵状血管瘤 CT 强化表现，错误的是
A.动脉期边缘结节样强化
B.动脉期部分瘤体可与腹主动脉强化程度一致
C.强化由边缘逐渐向中心扩展
D.实质期与正常肝实质密度相同
E.动脉期呈均匀强化
E

139.肝海绵状血管瘤 MR 典型表现是
A.T1WI 呈稍低信号
B.T2WI 呈高信号
C.灯泡征
D.信号均匀
E.明显强化
C

140.关于原发性肝癌 CT 表现，哪项是错误的
A.增强扫描静脉期明显强化
B.平扫多为低密度灶
C.增强扫描动脉期明显强化
D.局部肝轮廓可隆凸
E.可伴肝硬化、脾大
A

141.原发性肝癌一般强化特点是
A.快进慢出
B.快进快出
C.慢进慢出
D.慢进快出
E.无规律
B

142.提示肝癌门静脉癌栓的表现不包括下列哪项
A.门脉主干与分支管径不成比例
B.门静脉分支大于主干
C.门静脉增宽且密度不均
D.门静脉主干变细
E.门静脉腔内充盈缺损
D

143.以下哪项不是门静脉瘤栓的 CT 表现
A.平扫时瘤栓的密度与门静脉无大差异
B.门静脉扩大或不规则
C.平扫时门静脉显示高密度
D.增强扫描瘤栓呈低密度充盈缺损
E.可向两端延伸，侵入肝内和/或肠系膜上静脉
C

144.小肝血管瘤与小肝癌的 CT 鉴别点主要是
A.平扫时血管瘤多呈等密度
B.增强后动脉期小肝癌整个病灶强化
C.小肝癌的增强高峰持续时间短
D.血管瘤没有假包膜
E.小肝癌有假包膜
C

145.关于原发性肝癌 MR 表现，哪项是错误的
A.T1WI 呈稍低信号，T2WI 呈稍高信号
B.出现混杂信号提示肿块内有出血、坏死
C.可有门静脉流空信号消失
D.可伴腹水
E.增强扫描病灶边界更模糊
E

146.关于牛眼征的 CT 表现，说法错误的是
A.中心为低密度
B.边缘环形强化
C.增强扫描最外缘呈低密度
D.平扫肿块呈圆形，边缘清楚，状若牛眼
E.良性肿瘤一般无此表现
C

147.关于肝转移瘤的 CT 表现，哪项是错误的
A.肝内大小不一的结节
B.一般无出血或钙化
C.多数血供不丰富
D.少数动脉期明显强化
E.多数静脉期明显均质强化
E

148.关于肝转移癌的 MR 表现，哪项是错误的
A.一般 T1WI 呈稍低信号
B.T2WI 呈稍高信号
C.病灶中心可呈长 T1 长 T2 信号
D.常见灯泡征
E.牛眼征是肝转移癌特征性表现之一
D

149.关于肝包虫囊肿病，哪项是错误的
A.由细粒状棘球蚴病所致
B.是棘球绦虫的幼虫所致的一种寄生虫病
C.是肝棘球蚴病两种类型中最常见的一种
D.一般有牧区生活史
E.一般有进食米猪肉史
E

150.X 线平片可提示肝包虫病的征象是
A.肝区弧形或环形钙化
B.肝区点样钙化
C.肝区气体影
D.肝区肿块
E.肝区液平
A

151.以下哪项不是肝包虫囊肿的 MR 表现
A.大小不一、单发或多发病灶
B.囊性病变
C.一般 TIWI 呈均匀低信号，T2WI 呈均匀高信号
D.囊腔周围有晕环
E.多囊者其内可见间隔
D

152. 肝包虫最特征的 CT 表现是
A.巨大单一或多发囊肿，有浅分叶轮廓
B.母囊内出现子囊，数目不一
C.囊壁呈弧形或蛋壳样钙化
D.囊壁可见头节
E.增强后囊壁强化，显示更清楚
B

153.以下哪项不是肝包虫囊肿的 CT 表现
A.囊肿单或多发，可有浅分叶轮廓
B.囊内密度均匀，增强后明显强化
C.囊壁可呈弧形或蛋壳样钙化
D.母囊内出血子囊，数目不清
E.囊肿可分离，悬浮于囊液中
B

154.关于肝硬化的 CT 表现，哪项是错误的
A.肝门、肝裂增宽
B.门静脉主干直径一般大于 1cm 时考虑增宽
C.脾门血管迂曲增粗
D.增强扫描可见门静脉海绵样变
E.肝轮廓呈结节样凹凸不平
B</code></pre>
<h2 id="急腹症检查技术">20. 急腹症检查技术</h2>
<blockquote>
<p>检查技术：什么样的急腹症用什么样的检查技术（肠梗阻、气腹、穿孔等）</p>
</blockquote>
<p>急腹症常用的影像检查技术包括X线检查、CT检查和超声检查，而MRI检查的应用相对较少。了解急腹症的影像检查方法、应用范围和限度，有助于临床合理选用。</p>
<p>急腹症影像检查的目的在于明确疾病的有无，病变的部位范围、性质及并发症等，以便为疾病诊断、治疗计划制订和疗效评估提供依据。</p>
<p>(一)X线检查</p>
<p>X线检查适合在胃肠减压放置肛管、灌肠及给予解痉、止痛类药物之前进行，以了解腹盆腔原有的病理生理状态。</p>
<p>1.透视及X线平片</p>
<p>可作为急腹症的影像首选方法。</p>
<p>(1)透视：较少应用，但可观察膈肌运动和胃肠蠕动，对于<strong>胃肠道穿孔</strong>和<strong>肠梗阻</strong>诊断有一定价值。</p>
<p>(2)X线平片：是常用的方法，摄影位置首选为站立正、侧位，必要时采用仰卧前后位、仰卧水平侧位、侧卧水平正位或倒立侧位等。</p>
<p>①站立正、侧位，能清楚显示腹腔内游离积气和腹腔及肠管内的气液面，对<strong>胃肠道穿孔</strong>和<strong>肠梗阻</strong>的诊断有较高价值</p>
<p>②仰卧前后位和仰侧卧水平侧位和正位，主要用于不能站立的患者，同样能显示腹腔内游离气体及肠管内气液面，并可对腹部的其他改变进行评估，包括肠内积气、积气肠管的分布位置、软组织块影、腹腔积液及腹壁情况等</p>
<p>③倒立侧位，用于检查<strong>先天性直肠肛门闭锁</strong>。</p>
<p>2.造影检查</p>
<p>①钡剂或空气灌肠检查，主要用于<strong>回盲部肠套叠</strong>、<strong>乙状结肠扭转</strong>、<strong>结肠癌所致梗阻</strong>及<strong>先天性肠旋转不良</strong>等；对肠套叠和乙状结肠扭转，部分病例还可通过加压空气灌肠进行复位</p>
<p>②上消化道造影检查，口服稀释后的含碘对比剂，可用于<strong>先天性幽门肥厚</strong>、<strong>胃肠道穿孔</strong>及<strong>十二指肠梗阻</strong>等检查</p>
<p>③DSA检查，对<strong>急性消化道大出血</strong>者，需行选择性或超选择性DSA检查，在明确出血部位的同时，可滴注加压素或栓塞止血。</p>
<p>(二)超声检查</p>
<p>对于<strong>胆囊炎</strong>、<strong>胆石症</strong>、<strong>急性胰腺炎</strong>、<strong>肠梗阻</strong>和<strong>腹部急性外伤</strong>，超声检查均有一定价值，也可作为这些疾病的初查方法。然而在急腹症时，由于患者尚未饮食控制，肠道内气体干扰有时非常严重，将会影响对胆囊疾病、特别是胰腺疾病的显示，因此应补充CT检查。对于急腹症患者的检查不应局限于疼痛部位，应注意检查其他常见的容易发生急腹症的部位(如阑尾、盆腔)以及一般不进行常规检查的部位(如肠道等)。</p>
<p>(三)CT检查 目前在急腹症影像学检查中，CT已是腹部X线和超声检查的重要补充手段，并已逐步成为主要影像检查技术。腹部平片检查对<strong>急性阑尾炎</strong>、<strong>脏器损伤</strong>等疾病的诊断价值有限，应首选CT检查； 一些常见疾病如<strong>肠梗阻</strong>、胃肠道穿孔等所致<strong>急性腹膜炎</strong>，由于CT检查能提供更多的诊断信息，亦可作为首选检查方法。</p>
<p>1.平扫检查</p>
<p>为急腹症CT检查的常规方法，可发现大多数急腹症导致的异常表现。检查时需注意：</p>
<p>①扫描范围，般应上自横膈，下达盆腔，以全面了解整个腹盆腔的异常表现；同时重点检查病变可能累及的解剖部位，如考虑为<strong>急性阑尾炎</strong></p>
<p>②窗技术应用，应使用恰当的窗技术，能将腹内气体与脂肪区分开</p>
<p>③多平面重组(MPR)，有利于全面观察腹部各解剖结构及其异常</p>
<p>2.增强检查</p>
<p>主要用于检查<strong>与血管有关的急腹症</strong>、<strong>腹内脏器损伤</strong>、<strong>脏器炎症</strong>及<strong>腹腔脓肿</strong>，用于了解肠梗阻时是否伴有血供障碍。除了常规静脉团注对比剂后增强扫描外，有时需行多期增强检查，以观察不同时相病变的密度变化，例如判断肠梗阻时有无供血障碍。</p>
<pre><code>98．腹部平片对下述哪种急腹症诊断价值不高
A. 消化道穿孔 
B. 输尿管结石
C. 肾结石 
D. 小肠低位机械性肠梗阻
E. 急性阑尾炎
E</code></pre>
<h1 id="第八章-泌尿生殖系统与腹膜后间隙">第八章 泌尿生殖系统与腹膜后间隙</h1>
<h2 id="泌尿系统检查技术">21. 泌尿系统检查技术</h2>
<p>(一)X线检查</p>
<p>对于泌尿生殖系统，肾上腺及腹膜后间脱疾病，X线平片的应用非常有限，仅作为<strong>泌尿系统结石</strong>的初查方法；X线造影检查则有其应用价值，能够反映泌尿系统疾病所致的肾盂、肾盐、输尿管和膀胱壁及其内腔改变，以及女性生殖系统疾病引起的子宫输卵卵管壁及其内腔改变，但均难以明确壁外和(或)实质器官(肾、子宫)内常；DSA检查应用较少，是诊断血管性疾病如肾动脉狭窄的金标准，但主要用于介入治疗。</p>
<p>1.腹部平片</p>
<p>泌尿系统腹部平片检查常规摄取仰卧前后位片，临床上常称之为KUB (kidney-ureter-bladder) ，仅用于检查是否存在<strong>阳性结石</strong>，如<strong>肾、输尿管、膀胱结石</strong>。</p>
<p>2.尿路造影</p>
<p>主要用于观察肾盏、肾盂、输尿管和膀胱的内壁和内腔，分排泄性和逆行性造影。</p>
<p>(1)排泄性尿路造影(excretory urography) ：又称静脉性肾盂造影(intravenous pyelography ，IVP)。含碘水溶性对比剂于静脉注人后，由肾小球滤过而排入肾盏和肾盂内，不但能显示肾盏、肾盂、输尿管及膀胱内壁和内腔形态，且可大致了解双肾的排泄功能。含碘对比剂具有肾毒性作用，故对肾功能受损者应慎用或禁用该检查。</p>
<p>(2)逆行肾盂造影(retrograde pyelography) ：是在膀胱镜下将导管插入输尿管内并注入含碘对比剂，使肾盏、肾盂和输尿管显影的检查方法，属于有创性检查，适用于有排泄尿路造影禁忌证或其他成像技术显示不佳者。</p>
<p>(3)逆行膀胱造影：可发现<strong>膀胱输尿管反流</strong>和<strong>膀胱瘘</strong>。</p>
<p>3.选择性肾动脉造影(selective renal arteriography)</p>
<p>属于有创性检查 ，主要用于检查<strong>肾血管病变</strong>；还可进行<strong>肾血管病变</strong>及<strong>肾肿瘤</strong>的介入治疗。</p>
<p>(二)超声检查</p>
<p>超声通常作为泌尿生殖系统：肾上腺和腹膜后间院疾病的首选影像检查技术，可以检出和诊断<strong>结石</strong>、<strong>肿瘤</strong>等大多数肾、输尿管及膀胱病变。超声检查另一重要应用是基于其高度安全性，已成为目前女性尤为育龄期者生殖系统疾病和妊娠监测的主要影像检查技术。同时，泌尿、生殖系统超声检查也是健康体检的重要项目。然而，超声检查对于较小病变的检出以及疾病的定性诊断等还有一定限度，有时还受到肠内气体的干扰而影响检查效果。</p>
<p>泌尿系统常规超声检查包括二维灰阶超声和多普勒超声，前者可评估器官结构大小、形态和回声改变，后者则能反映血流状态变化。</p>
<p>(三) CT检查</p>
<p>CT检查密度分辨力高且空间分辨力也相对较高，因而有利于检出较小的病灶，并可清楚显示病灶范围及其毗邻结构关系，解剖关系明确为其突出优点，是泌尿系统、肾上腺和腹膜后间隙疾病的主要影像检查技术，能够敏感地检出病变并常能显示其特征而可作出准确诊断。然而，CT检查男性生殖系统疾病有较大的限度，尤其难以发现较早期病变；而对女性生殖系统疾病，由于较高的辐射剂量致其应用受到较大限制，除非老年女性，否则不主张应用CT检查。</p>
<p>1.平扫检查</p>
<p>为CT常规检查方法，对于<strong>泌尿系统结石</strong>、<strong>单纯性肾囊肿</strong>和<strong>多囊肾</strong>等疾病，CT平扫检查即可明确诊断。</p>
<p>2.增强检查</p>
<p><strong>大多数泌尿系统疾病，包括先天性发育异常、炎症、肿瘤、外伤乃至肾血管病变</strong>均需在平扫基础上行增强检查，以进一步明确病变范围和性质。增强检查时，应注意含碘对比剂的禁忌证。通常采用多期增强检查方法，即于静脉内快速注入非离子型含碘对比剂，并于不同延迟时间点进行扫描，可分别获得肾皮质期、实质期和排泄期图像。多期增强检查时，既可评估膀胱病变的强化表现，也可在延迟期膀胱腔内对比剂的衬托下，进一步观察病变的形态。</p>
<p>应用新出现的能谱CT扫描，能够对增强扫描数据进行后处理，获得虚拟平扫CT图像，可取代CT平扫检查，如此缩短了患者的检查时间，降低了辐射剂量。</p>
<p>3.CT 血管成像(CT angiography， CTA)</p>
<p>在静脉内快速注射含碘对比剂后的肾动脉期采集图像，并对容积数据进行三维重组，可获得犹如X线肾动脉造影效果的图像，称之为CT血管成像(CTA)。目前CTA多用于诊断<strong>肾血管病变</strong>。</p>
<p>4.CT尿路成像(CT urography， CTU)</p>
<p>与CTA类似，在肾脏排泄期采集图像，并对肾盂肾盏、输尿管、膀胱容积数据进行三维重组，可得到类似IVP检查效果的图像，称之为CT尿路成像。目前，CTU正逐步替代IVP检查，但其辐射剂量偏高。</p>
<p>(四) MRI检查</p>
<p>在泌尿系统、肾上腺和腹膜后间隙疾病的影像检查中，MRI通常作为超声和(或)CT检查后的补充方法，其组织分辨力高和多参数、多序列和多方位成像的优势，能进一步显示病变的特征，常有利于疾病的诊断与鉴别诊断。对于男、女生殖系统疾病，MRI检查由于其独特的优势，已逐步成为主要影像检查技术。但MRI检查具有一定的禁忌证，选用时需注意；此外，也易产生不同形式的伪影而干扰检查效果。</p>
<p>1.平扫检查</p>
<p>为常规应用方法，包括轴位T1 WI和T2 WI成像，必要时辅以冠状和(或)矢状位检查。脂肪抑制序列有利于含脂肪病变的诊断。扩散加权成像对疾病的诊断和鉴别诊断有一定价值。</p>
<p>2.增强检查</p>
<p>静脉内注人顺磁性对比剂Gd-DTPA，应用快速T1 WI成像序列可获得肾、输尿管和膀胱不同期相的增强图像，检查效果类似CT多期增强检查。适应证同CT增强检查，可用于因碘对比剂禁忌证不能行CT增强检查者，但严重肾功能不全患者体内滞留的钆具有导致肾源性系统性纤维化的危险，同样禁行MRI增强检查。</p>
<p>3.肾动脉MR血管成像(MRA)</p>
<p>对于肾动脉，可应用Gd-DTPA的增强MRA(CE-MRA)检查，通常作为肾动脉及其较大分支病变的筛查方法，诊断准确性尚不及肾动脉CTA检查。</p>
<p>4.磁共振尿路造影(MRU)</p>
<p>MRU利用水成像原理，使含尿液的肾盂肾盏、输尿管和膀胱呈高信号，周围结构皆为极低信号，犹如IVP所见，主要用于检查尿路梗阻尤其适用于IVP检查显影不佳和不能行IVP和CTU检查者。</p>
<pre><code>101．发现尿路阳性结石最常用的方法是
A. Ｂ超检查
B. 腹部平片检查
C. 腹部 CT 检查
D. 静脉尿路造影检查
E．逆行尿路造影检查
B

103．诊断肾上腺疾病的最佳方法是
A. 腹膜后充气造影检查
B. 腹部平片检查
C. 腹部薄层 CT 检查
D. 肾上腺血管造影检查
E．静脉肾盂造影检查
C

104．腹部平片，对下列哪种病变价值最低
A. 尿路结石 
B. 肾结核
C. 肾萎缩 
D. 膀胱肿瘤
E. 了解节育环位置
D

105．尿路平片不能显示
A. 尿路结石 
B. 腰大肌轮廓
C. 肾功能 
D. 肾轮廓
E. 腹腔、盆腔异常钙化
C</code></pre>
<h2 id="背22.-膀胱癌的影像学表现">(背)22. 膀胱癌的影像学表现</h2>
<p>X线：尿路造影检查，肿瘤通常单发，也可多发。乳头状癌表现为自膀胱壁突向腔内的结节状或菜花状充盈缺损，表面多凹凸不平(图8-11a)；少数膀胱癌尤为非乳头状癌时充盈缺损可不明显，仅显示局部膀胱壁僵硬。</p>
<p>超声：显示膀胱壁不规整，并有宽基底或带蒂的结节状、菜花状中等回声团块突人腔内(图8-11b)。</p>
<p>CT和MRI：由于肿瘤的密度和信号强度既不同于膀胱腔内尿液，也不同于膀胱周围脂肪组织，因而可清楚显示。表现为自膀胱壁突向腔内的结节状分叶或菜花状肿块，肿瘤侵犯肌层显示局部膀胱壁增厚；增强检查早期肿块有明显强化，延时扫描腔内充盈对比剂而表现为充盈缺损(图8-11c、d)。</p>
<p>这些影像检查技术还能发现膀胱癌对周围组织和邻近器官的侵犯，以及盆腔淋巴结转移等。</p>
<figure>
<img src="../images/8-11.png" alt="8-11" /><figcaption aria-hidden="true">8-11</figcaption>
</figure>
<h1 id="第九章-骨骼与肌肉系统">第九章 骨骼与肌肉系统</h1>
<h2 id="背23.-骨骼的基本病变">(背)23. 骨骼的基本病变</h2>
<p>骨质软化(osteomalacia)是指单位体积内骨组织有机成分正常，而钙盐含量减少。组织学上显示骨样组织钙化不足，常见骨小梁中央部分钙化，而周围环绕一层未钙化的骨样组织。</p>
<p>骨质破坏(bone destruction)是局部骨质消失而形成骨缺损，并被病理组织填充。可由病变组织产生的酶消化或由其引起的破骨细胞活动增强所致。骨松质和骨皮质均可发生破坏。</p>
<p>骨质破坏影像表现：</p>
<p>①X线平片：表现为骨质局限性密度减低，骨小梁稀疏消失，正常骨结构消失；在早期，骨松质破坏表现为斑片状骨小梁缺损，骨皮质破坏发生于哈氏管而致其扩大，呈筛孔状密度减低影，当骨皮质表层破坏时则呈虫蚀状改变；骨质破坏严重时，往往有骨松质和骨皮质的大片缺失(图9-10)。</p>
<p>②CT检查：骨松质的破坏表现为斑片状缺损区，骨皮质破坏表现为皮质内筛孔样破坏和其内外表面的不规则虫蚀样改变、骨皮质变薄，甚至斑块状的骨松质和骨皮质缺损(图9-11a)。</p>
<p>③MRI检查：骨质破坏表现为低信号的骨质被不同信号强度的病理组织所取代，骨松质破坏常表现为高信号的骨髓被较低信号或混杂信号影所取代(图9-11b)，骨皮质破坏的形态改变与CT所见相同。</p>
<p>骨质破坏见于炎症、肉芽肿及肿瘤。</p>
<figure>
<img src="../images/9-10%209-11.png" alt="9-10 9-11" /><figcaption aria-hidden="true">9-10 9-11</figcaption>
</figure>
<h2 id="关节强直">24. 关节强直</h2>
<p>关节强直(ankylosisofjoint)可分为骨性与纤维性两种。</p>
<p>骨性强直是关节明显破坏后，关节骨端由骨组织所连接。</p>
<p>纤维性强直关节骨端间为纤维组织连接。</p>
<p>①X线平片：骨性强直表现为关节间隙明显变窄或消失，并有骨小梁通过关节连接两侧骨端(图9-19)；纤维性强直也是关节破坏的后果，虽然关节活动消失，但X线上仍可见狭窄的关节间隙，且无骨小梁贯穿</p>
<figure>
<img src="../images/9-19.png" alt="9-19" /><figcaption aria-hidden="true">9-19</figcaption>
</figure>
<p>②CT检查：关节强直的各种X线表现在CT上均可清楚显示</p>
<p>③MRI检查：关节骨性强直时，可见关节软骨完全破坏，关节间隙消失，骨髓信号贯穿于关节骨端之间；纤维性强直时，关节间隙仍可存在，但关节骨端有破坏，骨端间可有高、低混杂异常信号影。</p>
<p>关节骨性强直多见于<strong>急性化脓性关节炎愈合后</strong>；关节纤维性强直常见于<strong>关节结核</strong>。</p>
<pre><code>19．化脓性关节炎不包括: 
A 关节囊肿胀
B 关节间隙狭窄
C 骨质疏松
D 关节面边缘少许骨质破坏
E 关节骨性强直
C</code></pre>
<h2 id="表25.-良恶性骨肿瘤的影像学鉴别诊断">(表)25. 良恶性骨肿瘤的影像学鉴别诊断</h2>
<table>
<thead>
<tr class="header">
<th></th>
<th>良性</th>
<th>恶性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>生长速度</td>
<td>缓慢</td>
<td>迅速</td>
</tr>
<tr class="even">
<td>生长方式</td>
<td>膨胀性</td>
<td>浸润性</td>
</tr>
<tr class="odd">
<td>骨质破坏边缘</td>
<td>清楚，常有周围硬化带</td>
<td>不清楚</td>
</tr>
<tr class="even">
<td>骨皮质改变</td>
<td>变薄、膨胀，但多完整</td>
<td>虫蚀状破坏，缺损、中断</td>
</tr>
<tr class="odd">
<td>骨膜反应</td>
<td>少有</td>
<td>常见，破坏并产生Codman三角</td>
</tr>
<tr class="even">
<td>肿瘤骨</td>
<td>无</td>
<td>常见，针状、放射状等</td>
</tr>
<tr class="odd">
<td>软组织肿块</td>
<td>少有，边界清楚</td>
<td>常见，边界不清</td>
</tr>
<tr class="even">
<td>远隔器官转移</td>
<td>无</td>
<td>常见</td>
</tr>
</tbody>
</table>
<pre><code>28．关于良性骨肿瘤的Ｘ线表现，哪项错误: 
A 生长缓慢，病程长
B 病变边缘骨硬化
C 骨膨隆
D 病变边缘清楚
E 皮质断裂
E

29．下列表现反映骨肿瘤恶性程度较高的征象是：
A 病变的大小
B 病变的部位
C Codman 三角
D 关节是否受累
E 是否合并病理性骨折
C

30．骨软骨瘤的Ｘ线表现，下列哪项错误: 
A 是最常见的良性骨肿瘤
B 好发于长骨干骺端
C 男性多于女性
D 可侵蚀附近骨，形成破坏
E 10 岁到 20 岁发病率高
D

36．转移性骨肿瘤的 X 线表现，下列那项错误: 
A 骨质破坏可单发或多发
B 一般无骨膜增生，软组织肿块
C 常伴病理性骨折
D 脊柱，骨盆，肋骨多见
E 椎体破坏，椎间隙变窄
E</code></pre>
<h2 id="关节结核x线平片表现">26. 关节结核X线平片表现</h2>
<p>x线平片：表现与关节结核的类型有关。</p>
<p>(1)骨型关节结核：X线表现较为明显，即在骨骺干骺端结核征象的基础上，又有关节周围软组织肿胀关节间除不对称性狭窄或关节骨质破坏等，诊断不难。</p>
<p>(2)滑膜型关节结核：较常见，大多累及一个较大关节，以髋关节和膝关节常见。</p>
<p>①早期，X线表现为关节囊和关节周围软组织肿胀，密度增高，关节间隙正常或增宽和骨质疏松，这些变化系因滑膜肿胀、增厚，形成肉芽组织和关节积液所致；可持续几个月到一年以上；因X线表现无特点，诊断较难。</p>
<p>②随病变进展，滑膜肉芽组织逐渐侵犯软骨和关节面，首先累及承重轻、非接触面的边缘部分，造成关节边缘部虫蚀状骨质破坏，对应关节面常对称受累；而承重区关节软骨破坏出现较晚，因此关节间腺变窄出现也发生较晚，与化脓性关节炎不同(图9-49a)。</p>
<p>③病变进一步 发展，关节软骨破坏范围扩大，则出现关节间院变窄，此时可发生半脱位：关节周围软组织常因干酪性液化物积聚而形成冷脓肿，有时穿破皮肤，形成窦道；如继发化脓性感染，则可引起骨质增生硬化，从而改变结核以骨质破坏为主的X线特点。</p>
<p>④病变愈合则骨质破坏停止发展，关节面骨质边缘变得锐利：骨质疏松也逐渐消失：严重病例，愈合后产生关节强直，多为纤维性强直。</p>
<pre><code>26．关节结核的关节面破坏首先发生在
A 骨骺
B 干骺端
C 骨骺板
D 关节非承重面，关节囊附着处
E 关节承重部位，穿过关节呈对称性
D</code></pre>
<h1 id="第十二章-介入放射学总论">第十二章 介入放射学总论</h1>
<h2 id="介入放射学-p340">27. 介入放射学 P340</h2>
<blockquote>
<p>看ppt，选择题为主，点比较多不需要背下来，书上内容比较死板，考得比较活</p>
<p>知识点：</p>
<p>常用的手术</p>
<p>常用的穿刺部位的血管</p>
<p>血管造影，腹腔干的解剖造影</p>
<p>对原发性肝细胞肝癌的供血动脉进行造影会有什么样的影像学表现</p>
<p>血管内支架置入术</p>
</blockquote>
<p>血管介入基本技术：</p>
<p>经皮血管造影术</p>
<p>经皮血管成形术</p>
<p>经皮血管内支架置入术</p>
<p>经导管血管栓塞及封堵术</p>
<p>经导管动脉药物灌注术</p>
<p>经导管溶栓术</p>
<p>血管入路：</p>
<p>动脉入路：股动脉、肱动脉、桡动脉</p>
<p>静脉入路：股静脉、颈静脉</p>
<p>门静脉</p>
<pre><code>1.下列哪项不是介入治疗常用器械？
A.穿刺针
B.导管
C.压力泵
D.球囊导管
E.弹簧圈
C

2.明胶海绵是什么样的栓塞剂
A.短期栓塞剂
B.长期塞剂
C.中期塞剂
D.液体塞剂
E.不可吸收栓塞剂
C

3.关于 Seldinger 技术的描述，哪项是正确的？
A.经皮穿刺进针—导入导丝—退出穿刺针—导入导管—退出导丝
B.经皮穿刺进针—导入导管—导入导丝—退出穿刺针—退出导丝
C.经皮穿刺进针—导入导丝—导入导管—退出穿刺针—退出导丝
D.经皮穿刺进针—导入导丝—导入导管—退出导丝—退出穿刺针
E.经皮穿刺进针—导入导管—退出穿刺针—导入导丝—退出导丝
A

4.原发性肝细胞肝癌介入治疗时常用是下列哪种栓塞剂？
A.明胶海绵
B. 碘化油
C. 无水酒精
D. NBCA
E. 聚乙烯醇颗粒
A

5.下列各种类型的子宫肌瘤中，哪一种情况不适宜做子宫动脉栓塞术。
A.子宫肌瘤合并阴道大出血者
B.粘膜下子宫肌瘤合并月经量过多者
C.浆膜下子宫肌瘤合并痛经者
D.子宫壁间肌瘤合并不孕年轻患者
E.症状性子宫肌瘤，经过药物治疗 1-2 个月疗效不佳者
C</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-06-30T16:00:00.000Z" itemprop="datePublished">2022/07/01</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>,<a class="article-category-link" href="/categories/%E8%AF%95%E9%A2%98/">试题</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8C%BB%E5%AD%A6/" rel="tag">医学</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-信息安全试题"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E8%AF%95%E9%A2%98/">信息安全试题</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="单项选择题">单项选择题</h1>
<p>密码学的目的是（ C ）。 A. 研究数据加密 B. 研究数据解密 ==C. 研究数据保密== D. 研究漏洞扫描</p>
<p>数据机密性安全服务的基础是（ D ）。 A. 数据完整性机制 B. 数字签名机制 C. 访问控制机制 ==D. 加密机制==</p>
<p>数字签名要预先使用单向Hash函数进行处理的原因是（ C ）。 A. 多一道加密工序使密文更难破译 B. 提高密文的计算速度 ==C. 缩小签名密文的长度，加快数字签名和验证签名的运算速度== D. 保证密文能正确还原成明文</p>
<p>基于通信双方共同拥有的但是不为别人知道的秘密，利用计算机强大的计算能力，以该秘密作为加密和解密的密钥的认证是（ C ）。 A. 公钥认证 B. 零知识认证 ==C. 共享密钥认证== D. 口令认证</p>
<p>PKI管理对象不包括（ A ）。 ==A. ID和口令== B. 证书 C. 密钥 D. 证书撤消列表</p>
<p>包过滤型防火墙原理上是基于（ C ）进行分析的技术。 A. 物理层 B. 数据链路层 ==C. 网络层== D. 应用层</p>
<p>计算机病毒是计算机系统中一类隐藏在（ C ）上蓄意破坏的捣乱程序。 A. 内存 B. 软盘 ==C. 存储介质== D. 云盘</p>
<p>“公开密钥密码体制”的含义是（ C ）。 A. 将所有密钥公开 B. 将私有密钥公开，公开密钥保密 ==C. 将公开密钥公开，私有密钥保密== D. 两个密钥相同</p>
<p>PKI的主要组成不包括（B）。 A. 证书授权CA ==B. SSL== C. 注册授权RA D. 证书存储库CR</p>
<p>下列选项中能够用在网络层的协议是（ D ）。 A. SSL B. PGP C. PPTP ==D. IPSec==</p>
<p>IPSec协议中负责对IP数据报加密的部分是（A）。 ==A. 封装安全负载（ESP）== B. 鉴别包头（AH） C. Internet密钥交换（IKE） D. 以上都不是</p>
<p>防火墙用于将Internet和内部网络隔离，（ B ）。 A. 是防止Internet火灾的硬件设施 ==B. 是网络安全和信息安全的软件和硬件设施== C. 是保护线路不受破坏的软件和硬件设施 D. 是起抗电磁干扰作用的硬件设施</p>
<p>A方有一对密钥（KA公开，KA秘密），B方有一对密钥（KB公开，KB秘密），A方向B方发送数字签名，对信息M加密为：M’= KB公开（KA秘密（M））。B方收到密文的解密方案是（C）。 A. KB公开（KA秘密（M’）） B. KA公开（KA公开（M’）） ==C. KA公开（KB秘密（M’））== D. KB秘密（KA秘密（M’））</p>
<p>从安全属性对各种网络攻击进行分类，阻断攻击是针对（B）的攻击。 A. 机密性 ==B. 可用性== C. 完整性 D. 真实性</p>
<p>攻击者用传输数据来冲击网络接口，使服务器过于繁忙以至于不能应答请求的攻击方式是（A）。 ==A. 拒绝服务攻击== B. 地址欺骗攻击 C. 会话劫持 D. 信号包探测程序攻击</p>
<p>CA属于PKI安全体系结构中定义的（D）。 A. 认证交换机制 B. 通信业务填充机制 C. 路由控制机制 ==D. 公证机制==</p>
<p>访问控制是指确定（ A ）以及实施访问权限的过程。 ==A. 用户权限== B. 可给予哪些主体访问权利 C. 可被用户访问的资源 D. 系统是否遭受入侵</p>
<p>PKI支持的服务不包括（D）。 A. 非对称密钥技术及证书管理 B. CRL列表服务 C. 对称密钥的产生和分发 ==D. 访问控制服务==</p>
<p>目前，VPN使用了（A）技术保证了通信的安全性。 ==A. 隧道协议、身份认证和数据加密== B. 身份认证、数据加密 C. 隧道协议、身份认证 D. 隧道协议、数据加密</p>
<p>IPSec VPN不太适合用于（C）。 A. 已知范围的IP地址的网络 B. 固定范围的IP地址的网络 ==C. 动态分配IP地址的网络== D. TCP/IP协议的网络</p>
<p>假设使用一种加密算法，它的加密方法很简单：将每一个字母加5，即a加密成f。这种算法的密钥就是5，那么它属于（A）。 ==A. 对称加密技术== B. 分组密码技术 C. 公钥加密技术 D. 单向散列函数密码技术</p>
<p>用于实现身份鉴别的安全机制是（A）。 ==A. 加密机制和数字签名机制== B. 加密机制和访问控制机制 C. 数字签名机制和路由控制机制 D. 访问控制机制和路由控制机制</p>
<p>身份鉴别是安全服务中的重要一环，以下关于身份鉴别的叙述不正确的是（B）。 A. 身份鉴别是授权控制的基础 ==B. 身份鉴别一般不用提供双向的认证== C. 目前一般采用基于对称密钥加密或公开密钥加密的方法 D. 数字签名机制是实现身份鉴别的重要机制</p>
<p>PKI能够执行的功能是（ A ）和（ C ）。 ==A. 鉴别计算机消息的始发者== B. 确认计算机的物理位置 ==C. 保守消息的机密== D. 确认用户具有的安全性特权</p>
<p>信息安全的基本属性是（ D ）。 A. 机密性 B. 可用性 C. 完整性 ==D. 上面3项都是，不可否认性、可控性==</p>
<p>ISO安全体系结构中的对象认证服务，使用（ B ）完成。 A. 加密机制 ==B. 数字签名机制== C. 访问控制机制 D. 数据完整性机制</p>
<p>机密性服务提供信息的保密，机密性服务包括（D）。 A. 文件机密性 B. 信息传输机密性 C. 通信流的机密性 ==D. 以上3项都是==</p>
<p>关于DES算法，除了（C ）以外，下列描述DES算法子密钥产生过程是正确的。 A.首先将 DES 算法所接受的输入密钥 K（64 位），去除奇偶校验位，得到56位密钥（即经过PC-1置换，得到56位密钥） B.在计算第i轮迭代所需的子密钥时，首先进行循环左移，循环左移的位数取决于i的值，这些经过循环移位的值作为下一次循环左移的输入 ==C.在计算第i轮迭代所需的子密钥时，首先进行循环左移，每轮循环左移的位数都相同，这些经过循环移位的值作为下一次循环左移的输入== D.然后将每轮循环移位后的值经PC-2置换，所得到的置换结果即为第i轮所需的子密钥Ki</p>
<p>根据所依据的数学难题，除了（ A ）以外，公钥密码体制可以分为以下几类。 ==A.模幂运算问题== B.大整数因子分解问题 C.离散对数问题 D.椭圆曲线离散对数问题</p>
<p>完整的数字签名过程（包括从发送方发送消息到接收方安全的接收到消息）包括（C ）和验证过程。 A.加密 B.解密 ==C.签名== D.保密传输</p>
<p>密码学在信息安全中的应用是多样的，以下（ A）不属于密码学的具体应用。 ==A. 生成各种网络协议== B. 消息认证，确保信息完整性 C. 加密技术，保护传输信息 D. 进行身份认证</p>
<p>某公司的工作时间是上午 8 点半至 12 点，下午 1 点至 5 点半，每次系统备份需要一个半小时，下列适合作为系统数据备份的时间是（D）。 A. 上午 8 点 B. 中午 12 点 C. 下午 3 点 ==D. 凌晨 1 点== 容灾的目的和实质是( C )。 A. 数据备份 B. 心理安慰 ==C. 保持信息系统的业务持续性== D. 系统的有益补充</p>
<p>基于网络的入侵检测系统的信息源是（ D ）。 A. 系统的审计日志 B. 事件分析器 C. 应用程序的事务日志文件 ==D. 网络中的数据包==</p>
<p>误用入侵检测技术的核心问题是（ C ）的建立以及后期的维护和更新。 A. 异常模型 B. 规则集处理引擎 ==C. 网络攻击特征库== D. 审计日志</p>
<p>使用漏洞库匹配的扫描方法，能发现( B )。 A. 未知的漏洞 ==B. 已知的漏洞== C. 自行设计的软件中的漏洞 D. 所有的漏洞</p>
<p>防火墙提供的接入模式不包括( D ) A. 网关模式 B. 透明模式 C. 混合模式 ==D. 旁路接入模式==</p>
<p>信息安全管理领域权威的标准是（ B ）。 A. ISO15408 ==B. ISO17799/ISO27001== C. ISO9001 D. ISO14001</p>
<p>根据风险管理的看法，资产( )价值，( )脆弱性，被安全威胁所( )，( )风险。（B） A. 存在 利用 导致 具有 ==B. 具有 存在 利用 导致== C. 导致 存在 具有 利用 D. 利用 导致 存在 具有</p>
<p>社会工程学常被黑客用于（A） ==A. 口令获取== B. ARP C. TCP D. DDOS</p>
<p>一个完整的密码体制，不包括以下（ C ）要素。 A. 明文空间 B. 密文空间 ==C. 数字签名== D. 密钥空间</p>
<p>自然灾害引起的安全问题，称为（ A ） 。 ==A. 物理安全== B. 法律安全 C. 人事安全 D. 技术安全</p>
<p>采用具有一定安全性质的硬件或软件，保护信息系统的安全，属于 （ D ） 。 A. 物理安全 B. 人事安全 C. 法律安全 ==D. 技术安全==</p>
<p>在自主访问控制中，客体拥有者具有全部的控制权，称为（ A ）。 ==A. 集中型管理模式== B. 分散型管理模式 C. 受限的分散型管理模式 D. 受限的集中型管理模式</p>
<p>主体所能访问的客体的表，称为（ A ）。 ==A. 授权表== B. 能力表 C. 稀疏矩阵 D. 访问控制矩阵</p>
<p>未经许可，但成功获得了对系统某项资源的访问权，并更改该项资源，称为（ B ）。 A. 窃取 ==B. 篡改== C. 伪造 D. 拒绝服务</p>
<p>未经许可，在系统中产生虚假数据，称为（ C ）。 A. 窃取 B. 篡改 ==C. 伪造== D. 拒绝服务</p>
<p>未经许可直接或间接获得了对系统资源的访问权，从中窃取有用数据，称为（ A ）。 ==A. 窃取== B. 篡改 C. 伪造 D. 拒绝服务</p>
<p>防止信息非授权的泄露，称为（ A ）。 ==A. 机密性== B. 完整性 C. 可用性 D. 可控性</p>
<p>保持信息不被篡改的特性，称为（ B ）。 A. 机密性 ==B. 完整性== C. 可用性 D. 可控性</p>
<p>授权用户能正常使用资源的性质称为（ C ）。 A. 保密性 B. 完整性 ==C. 可用性== D. 可控性</p>
<p>在授权范围内控制信息的流向称为（ D ）。 A. 保密性 B. 完整性 C. 可用性 ==D. 可控性==</p>
<p>不能否认自己的行为，称为（ A ）。 ==A. 抗抵赖性== B. 完整性 C. 可用性 D. 可控性</p>
<p>数据信号的抗干扰能力称为（ B ）。 A. 机密性 ==B. 可靠性== C. 可用性 D. 可控性</p>
<p>防止非法用户进入系统的技术称为（ A ）。 ==A. 身份鉴别== B. 权限管理 C. 信息流控制 D. 数据加密</p>
<p>保证所有的访问都是经过授权的，称为（ B ）。 A. 数字签名 ==B. 访问控制== C. 信息流控制 D. 数据加密</p>
<p>阻止传输过程中，数据被窃取的最好方法是（ D ）。 A. 身份鉴别 B. 访问控制 C. 信息流控制 ==D. 数据加密==</p>
<p>监视、记录、控制用户活动的机制称为（ B ）。 A. 身份鉴别 ==B. 审计== C. 管理 D. 加密</p>
<p>下列选项中（ B ）是信息安全五个基本属性之一。 A.可信性性 ==B.可用性== C.可审计性 D.可靠性</p>
<p>2017年6月1日起我国第一部基础性信息安全法律（ A ）正式施行。 ==A. 网络安全法== B. 安全基础保护法 C. 计算机病毒防治管理办法 D. 个人信息保护法</p>
<p>可信计算用于解决（ D ）。 A. 设备安全 B. 数据安全 C. 内容安全 ==D. 行为安全==</p>
<p>0Day漏洞是指（ C ）。 A. 只在当天存在. 第二天就失效的漏洞 B. 已被公开且发布了补丁的漏洞 ==C. 补丁发布前已被掌握或公开的漏洞== D. 生命周期为一天的漏洞</p>
<p>用户身份鉴别是通过（ A ）完成的。 ==A. 口令验证== B. 审计策略 C. 存取控制 D. 查询功能</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-06-30T16:00:00.000Z" itemprop="datePublished">2022/07/01</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E8%AF%95%E9%A2%98/">试题</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%BD%91%E7%BB%9C/" rel="tag">计算机 - 网络</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-数据库四级"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9B%E7%BA%A7/">数据库四级</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="数据库">数据库</h1>
<h3 id="模型">模型</h3>
<p>概念数据模型：实体联系模型(E-R模型)、扩充的实体联系模型(EER模型)、面向对象模型、谓词模型</p>
<h3 id="关系代数">关系代数</h3>
<figure>
<img src="../images/关系代数.png" alt="关系代数" /><figcaption aria-hidden="true">关系代数</figcaption>
</figure>
<p>交换律：选择、自然连接、集合的并交</p>
<p>分配率：投影的并、选择的并交差</p>
<p>结合率：集合的并交、自然连接</p>
<p>关系代数的操作可分为三类：</p>
<p>基于传统集合论的操作：这类操作讲关系看成是元组的集合,其操作是从关系的“水平”向，即行的角度来进行的，有并、交、差、笛卡尔积。</p>
<p>专门的关系操作：这列操作又可分为一元操作和二元操作。一元操作有选择和投影；二元操作有连接和除。连接操作又包括θ连接、等值连接和自然连接。</p>
<p>扩充的关系操作：这类操作主要有广义投影、赋值、外连接、半连接、聚集、外部并等。并、差、笛卡尔积、投影和选择这五种操作称为基本的操作。</p>
<h3 id="参照完整性">参照完整性</h3>
<p>参照关系=从关系：外码所在的关系</p>
<p>被参照关系=主关系：以外码作为主码的关系</p>
<p>外码并不一定要与相应的主码同名。</p>
<p>参照完整性规则：</p>
<p>若属性（或属性值）F是关系R的外码，它与关系S的主码Ks相对应(关系R和S不一定是不同的关系)，则对于R中每个元组在F上的值必须满足：</p>
<ul>
<li>或者取空值(F的每个属性值均为空值)</li>
<li>或者等于S中某个元组的主码值</li>
</ul>
<h3 id="armstrong公理系统">Armstrong公理系统</h3>
<p>设 F 是属性组 U 上的一组函数依赖，于是有如下推理规则：</p>
<ul>
<li>自反律：若 Y ⊆ X ⊆ U，则 X → Y 为 F 所逻辑蕴含</li>
<li>增广律：若 X → Y 为 F 所逻辑蕴含，且 Z ⊆ U，则 XZ → YZ 为 F 所逻辑蕴含</li>
<li>传递律：若 X → Y 及 Y → Z 为 F 所逻辑蕴含，则 X → Z 为 F 所逻辑蕴含</li>
</ul>
<p>根据Armstrong公理系统的三条推理规则，可以得到如下推理规则：</p>
<ul>
<li>合并规则：由 X → Y， X → Z，有 X → YZ</li>
<li>伪传递规则：由 X → Y，WY → Z，有 XW → Z</li>
<li>分解规则：由 X → Y，Z ⊆ Y，有 X → Z</li>
</ul>
<h3 id="模式分解">模式分解</h3>
<p>分解具有无损连接性和分解保持函数依赖是两个相互独立的标准。</p>
<p>具有无损连接性的分解不定保持函数依赖，保持函数依赖的分解不一定具有无损连接性。</p>
<p>关系模式的个分解可能是具有无损连接性，可能是保持函数依赖的，也可能是既具有无损连接性又保持函数依赖的。</p>
<h4 id="无损连接">无损连接</h4>
<p>达到BCNF，并进一步达到4NF</p>
<p>若对于 R 的任何一个可能取值 r，都有 r 在 R1，R2，...，Rn 上的投影的自然连接等于 r</p>
<h4 id="函数依赖">函数依赖</h4>
<p>达到3NF，但不一定达到BCNF</p>
<p>F 所逻辑蕴含的函数依赖一定也由分解得到的各个关系模式中的函数依赖所逻辑蕴含</p>
<ul>
<li>若 X → Y，Y ⊆ X，则称 X → Y 为平凡的函数依赖</li>
<li>若 X → Y，Y ⊄ X，则称 X → Y 为非平凡的函数依赖</li>
</ul>
<h4 id="多值依赖">多值依赖</h4>
<p>性质：</p>
<ul>
<li>若 X →→ Y，则 X →→ Z，其中 Z = U - X - Y，即多值依赖具有对称性
<ul>
<li>推论：若 Z = ∅，则 X →→ Y</li>
</ul></li>
<li>若 X → Y，则 X →→ Y，即函数依赖可以看做多值依赖的特殊情况</li>
<li>若 XY ⊆ W ⊆ U，那么当 X →→ Y 在 R(U) 上成立时，X →→ Y 也在 R(W) 上成立</li>
<li>若 X →→ Y 在 R(U) 上成立，且 Y’ ⊆ Y，<strong>不能</strong>断言 X →→Y‘ 在 R(U) 上成立</li>
<li>若 X → Y 在 R(U) 上成立，且 Y’ ⊆ Y，那么肯定 X → Y' 在 R(U) 上成立。</li>
</ul>
<h3 id="事务的acid性质">事务的ACID性质</h3>
<p>原子性(Atomicity)</p>
<p>一致性(Consistency)</p>
<p>隔离性(Isolation)</p>
<p>持久性(Durability)</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-06-30T16:00:00.000Z" itemprop="datePublished">2022/07/01</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">计算机 - 数据库</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-流行病"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E6%B5%81%E8%A1%8C%E7%97%85/">流行病</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="概述">概述</h2>
<p><strong>流行病学：研究特定人群中与健康相关的状态和事件的分布及决定因素，以及应用这些研究结果控制健康问题。</strong></p>
<h3 id="流行病学定义的基本内涵">流行病学定义的基本内涵</h3>
<ul>
<li>流行病学研究的<strong>对象</strong>是<strong>人群</strong>，是研究所关注的<strong>具有某种特征的人群</strong>，而<strong>不是某一个个体</strong>。</li>
<li>流行病学研究的内容不仅包括<strong>疾病</strong>，还包括<strong>伤害</strong>、<strong>健康状态</strong>及其他相关的卫生事件。</li>
<li>流行病学研究的<strong>起点</strong>是<strong>疾病和健康状态的分布</strong>，研究的<strong>重点</strong>是<strong>疾病和健康状态的影响因素</strong>。</li>
<li>流行病学研究的<strong>最终目的</strong>是<strong>为预防、控制和消灭疾病</strong>以及<strong>促进健康提供科学的决策依据</strong>。</li>
</ul>
<h3 id="流行病学科的形成">流行病学科的形成</h3>
<ul>
<li>英国海军外科医生詹姆士.林德(James Lind)1747年在“Salisburg”号海船上将12 名患坏血病的海员分组(每组2人)进行添加不同食物的对比治疗试验，结果发现，食物中添加橘子和柠檬的两名海员几乎完全康复，提示橘子和柠檬等新鲜水果(后被证明是维生素C)可以治疗坏血病，开创了流行病学临床试验的先河。</li>
<li>1796年英国医生琴纳(Jenner)发明了接种牛痘以预防天花，从而使天花这一烈性传染病得到了有效控制，为传染病的预防和控制开创了主动免疫的先河。1802 年，Madrid的《西班牙疾病流行史》一书中首次出现了epidemiologia一词。1850 年国际上首次在伦敦成立了流行病学学会，标志着流行病学学科的形成。</li>
<li>1854年英国著名内科医生约翰·斯诺(John Snow)针对伦敦霍乱的流行，创造性地使用了病例分布的标点地图法，对伦敦宽街霍乱流行及不同供水区居民霍乱死亡率进行了描述和分析，首次提出了“霍乱介水传播”的观点，并通过干预成功地控制了霍乱的进一步流行，成为流行病学现场调查、分析与控制的经典实例。在2003年3月《医院医师杂志》(Hospital Doctor Magazine)所做的一次调查中John Snow的选票高居榜首，被选为史上“最伟大的医生”。</li>
</ul>
<h3 id="流行病学研究方法分类">流行病学研究方法分类</h3>
<figure>
<img src="../images/流行病学研究方法分类.png" alt="流行病学研究方法分类" /><figcaption aria-hidden="true">流行病学研究方法分类</figcaption>
</figure>
<h3 id="流行病研究的重要观点">流行病研究的重要观点</h3>
<ul>
<li>群体的观点</li>
<li>比较的观点</li>
<li>概率论的观点</li>
<li>社会医学的观点</li>
<li>多病因论的观点</li>
</ul>
<h3 id="流行病学的应用">流行病学的应用</h3>
<ul>
<li>描述疾病或健康状态的分布及其特点</li>
<li>探讨疾病病因与影响流行的因素</li>
<li>疾病诊断、治疗与防制措施的效果评价</li>
<li>揭示疾病完整的自然史</li>
<li>疾病防治和健康促进</li>
<li>卫生决策和评价</li>
</ul>
<h2 id="疾病的分布">疾病的分布</h2>
<h3 id="研究疾病分布常用的测量指标">研究疾病分布常用的测量指标</h3>
<h4 id="率">率</h4>
<p><strong>率(rate)是表示在一定的条件下，某现象实际发生的例数与可能发生该现象总例数之比，用以说明单位时间内某现象发生的频率或强度。</strong></p>
<p>一般用百分率、千分率、万分率或10万分率表示。 <span class="math display">\[
率=\frac{某现象实际发生的例数}{可能发生该现象的总例数}\times k,k= 100\%、1000\textperthousand\cdots
\]</span></p>
<h4 id="比">比</h4>
<p><strong>比(ratio)也称相对比，是表示两个数相除所得的值，说明两者的相对水平，常用倍数或百分数表示。</strong></p>
<p>甲、乙两个指标可以性质相同，如某两地区的传染病例数之比；也可以性质不同，如某医院医护人员数与病床数之比。 <span class="math display">\[
相对比=\frac{甲指标}{乙指标}(或\times100\%)
\]</span></p>
<h4 id="构成比">构成比</h4>
<p><strong>构成比(proportion)表示事物内部各个组成部分所占总体的比重，常以百分数表示。</strong></p>
<p>在实际应用中应防止以比代替率，因为构成比是反映事物中各组成部分的比重或分布的，并不能反映事物某一部分 发生的频率或强度。因此，如果把构成比当作率使用，将会得出错误的结论。 <span class="math display">\[
构成比=\frac{某事物内部某一部分的数量(个体数)}{同一事物内部的整体数量(个体数之和)}\times100\%
\]</span></p>
<h4 id="发病率">发病率</h4>
<p><strong>发病率(incidence rate)是指一定时期内 ，特定人群中某病新病例出现的频率。</strong> <span class="math display">\[
发病率=\frac{一定时期内某人群中发生某病的新病例数}{同期暴露人口数}\times k,k=100\%、1000\textperthousand、10000/万或100000/10万
\]</span> 计算发病率时可根据研究的病种及研究问题特点来选择时间单位，一般多<strong>以年为时间单位</strong>。</p>
<p>发病率的分子为<strong>新发病例数</strong>，而新病例的确定则依据发病的时间。</p>
<ul>
<li>对<strong>发病时间不易确定</strong>的一些疾病，如恶性肿瘤、高血压糖尿病和精神病等疾病，一般以<strong>初次诊断</strong>时间作为发病时间。</li>
<li>新病例是指观察期间内发生某病的病人，有时一个人在观察期间内可能会<strong>多次发生同种疾病</strong>。例如，一个人在一年内可患几次腹泻或几次感冒，可<strong>分别计算为几个新病例</strong>。</li>
</ul>
<p>发病率的分母是指所规定的暴露人口，即指在观察期间内，观察人群中所有可能患该病的人。</p>
<ul>
<li>对观察人群中不可能患该病的人，如研究传染病的发病率时，<strong>已获得特异性免疫</strong>的人群则<strong>不应包括在</strong>分母中。</li>
<li>但是，由于在实际工作中准确的暴露人口数往往不易获得，因此一般用<strong>年平均人口数</strong>(以某年7月1日零时人口数，或年初年末人口数之和除以2作为年平均人口数)作为分母。</li>
</ul>
<p>发病率是由发病报告或队列研究获得的疾病频率，是衡量疾病发生情况的<strong>动态指标</strong>。</p>
<p>某病的发病率还可以按年龄、性别、职业及地区等不同特征分别计算，称为<strong>发病专率</strong>。</p>
<p>发病率是一个重要的常用指标，对于<strong>描述死亡率极低或非致死性的疾病</strong>尤为重要。常用来描述疾病的分布，探讨发病因素，提出病因假设和评价防治措施的效果等。</p>
<p>发病率的准确性受很多因素的影响，如报告制度是否健全以及诊断疾病的水平高低等。在比较不同地区人群的发病率时，考虑到<strong>年龄和性别构成</strong>的不同，应对发病率进行<strong>标准化</strong>。率的标准化计算方法有直接法和间接法两种。</p>
<h4 id="罹患率">罹患率</h4>
<p><strong>罹患率(attack rate)与发病率一样是测量新发病例频率的指标。</strong> <span class="math display">\[
罹患率=\frac{观察期间某病新病例数}{同期暴露人口数}\times k,k=100\%、1000\textperthousand、10000/万或100000/10万
\]</span> 罹患率一般多用于衡量小范围、短时间的发病频率，是<strong>以月、周、日或一个流行期为时间单位</strong>。</p>
<p>罹患率的优点是可以根据暴露程度精确地测量发病率，多用于描述食物中毒、职业中毒及传染病的暴发流行。</p>
<h4 id="患病率">患病率</h4>
<p><strong>患病率(prevalence rate)亦称现患率或流行率。是指在特定时间内，一定人群中某病新旧病例数所占的比例。</strong> <span class="math display">\[
患病率=\frac{特定时间内某人群中某病新旧病例数}{同期观察人口数}\times k,k=100\%、1000\textperthousand、10000/万或100000/10万
\]</span></p>
<p>患病率的分子为特定时间内所调查人群中某病<strong>新旧病例的总和</strong>。</p>
<p>患病率是由横断面调查获得的疾病频率，是衡量疾病的存在或流行情况的<strong>静态指标</strong>。</p>
<p>患病率、发病率和病程三者之间存在关系：<strong>患病率=发病率×病程</strong>，因而可以根据患病率和发病率计算出平均病程，满足条件是在相当长的时间内发病率和病程都相当稳定。</p>
<p>常见的影响患病率的因素：</p>
<table>
<thead>
<tr class="header">
<th>患病率升高</th>
<th>患病率降低</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>病程延长</td>
<td>病程缩短</td>
</tr>
<tr class="even">
<td>病人寿命的延长</td>
<td>病死率增高</td>
</tr>
<tr class="odd">
<td>新病例增加(发病率上升)</td>
<td>新病例减少(发病率下降)</td>
</tr>
<tr class="even">
<td>病例迁入</td>
<td>病例迁出</td>
</tr>
<tr class="odd">
<td>健康者迁出</td>
<td>健康者迁入</td>
</tr>
<tr class="even">
<td>诊断水平提高</td>
<td>治愈率提高</td>
</tr>
<tr class="odd">
<td>报告率提高</td>
<td></td>
</tr>
</tbody>
</table>
<p>患病率升高和降低的意义应视各种疾病的实际情况而定。患病率的变化要结合发病率、生存率及治愈率等方面的资料进行综合分析，才能做出正确的结论。</p>
<ul>
<li>某些疾病的患病率增高，既可能是发病率真的增高，也可能是诊断水平的提高或因治疗的改进虽不能完全治愈疾病但能使病人寿命延长所致。</li>
<li>某些疾病的患病率降低，可能与发病率下降有关，也可能与治疗措施的改进使治愈率提高，从而使病人病程缩短有关。</li>
</ul>
<p>实际应用中，患病率对于<strong>病程短</strong>的疾病<strong>价值并不大</strong>，而对于<strong>病程长</strong>的一些慢性病，则能为流行状况提供<strong>有价值</strong>的信息，并可反映某地区人群某病的疾病负担程度。此外，可依据患病率来合理地规划卫生设施、人力、物力及卫生资源，研究疾病流行因素及监测慢性病的控制效果等。</p>
<h4 id="感染率">感染率</h4>
<p><strong>感染率(infection rate)是指在受检查的人群中某病现有的感染人数所占的比率,通常用百分率表示。</strong> <span class="math display">\[
感染率=\frac{受检者中阳性人数}{受检人数}\times100\%
\]</span> 感染率的性质与患病率相似。患病率的分子是指病例，而感染率的分子是指感染者。人感染某些传染病，可能不出现任何临床症状，但可通过病原学、血清学及皮肤试验等检测方法获知是否感染。</p>
<p>感染率用途广泛，特别是在具有较多隐性感染的传染病和寄生虫病等的调查中，常用于研究疾病的感染状况和防制工作的效果，估计某病的流行态势，也可为制订防制措施提供依据。</p>
<h4 id="续发率">续发率</h4>
<p><strong>续发率(secondary attack rate , SAR)也称二代发病率，指在一定观察期内某种传染病在易感接触者中二代病例出现的百分率。</strong></p>
<p>易感接触者中出现的第一例病例称为“原发病例”，不计算在续发率内。自原发病例出现后，在该病最短潜伏期至最长潜伏期之间发生的病例称为续发病例，即二代病例。 <span class="math display">\[
续发率=\frac{易感接触者中的二代病例数}{易感接触者总数}\times100\%
\]</span> 计算续发率时要掌握的资料</p>
<ul>
<li>原发病例的发病时间</li>
<li>接触者中易感者人数</li>
<li>观察期间内发生的二代病例数。</li>
</ul>
<p>续发率常用于家庭、集体单位或幼儿园等发生传染病时的流行病学调查。可用于分析比较不同传染病传染力的大小、流行因素及评价防制措施等。</p>
<h4 id="死亡率">死亡率</h4>
<p><strong>死亡率(mortality rate) 是指某人群在一定期间内死于所有原因的人数在该人群中所占的比例。</strong></p>
<p>死亡率是测量人群死亡危险最常用的指标，其分子为死亡人数，分母为该人群年平均人口数。常以年为单位计算。 <span class="math display">\[
死亡率=\frac{某人群某年总死亡人数}{该人群同年平均人口数}\times k,k=1000\textperthousand、10000/万或100000/10万
\]</span> 死于所有原因的死亡率是一种未经过调整的死亡率，所以通常被称为<strong>粗死亡率</strong>(crude death rate)。粗死亡率反映一个人群的总死亡水平，是衡量人群因病伤死亡危险性大小的指标，是一个国家或地区文化、卫生水平的综合反映。它不仅反映一个国家或地区在不同时期的居民健康状况和卫生保健水平，也可为确定当地卫生保健的需求和制定规划提供科学依据。</p>
<p>对于<strong>病死率高</strong>的疾病如胰腺癌等，其死亡率基本上<strong>可以反映该病的发病水平</strong>。但是对于<strong>非致死性疾病</strong>如普通感冒、关节炎等，进行死亡率的分析是<strong>不恰当</strong>的。有些疾病虽然发病率很高，但因其病死率较低，故也不适合用死亡率进行分析。</p>
<p>各地区死亡率进行<strong>比较</strong>时，应特别注意各地<strong>人口构成存在的差异</strong>，因此，用<strong>标准化死亡率</strong>进行比较才有助于得出正确的结论。如甲、乙两地在未标化前的肺癌死亡率是相同的，但实际上乙地人群的肺癌死亡率要明显地高于甲地，其原因在于甲地人口构成中男性老年人口居多，而肺癌的死亡率又与年龄和性别有关，所以用未标化率进行比较时，就会得出甲乙两地肺癌死亡率相同的错误结论。</p>
<p>按疾病的种类、年龄、性别职业或种族等分类计算的死亡率称为<strong>死亡专率</strong>。计算死亡专率时，分母必须是与分子相对应的人口数。例如计算某地40岁以上男性肺癌的死亡专率，分母应是该地40岁以上的男性人口数，而不能用该地区的全人口数。</p>
<h4 id="病死率">病死率</h4>
<p><strong>病死率(fatality rate)表示一定期间内 ，患某病的全部病人中因该病而死亡的比例。</strong> <span class="math display">\[
病死率=\frac{一定期间内因某病死亡人数}{同期患某病的人数}\times100\%
\]</span> 如果某病的死亡专率与发病专率处于比较稳定的状态，病死率也可由死亡专率与发病专率推算而得。 <span class="math display">\[
某病病死率=\frac{该病死亡专率}{该病发病专率}\times100\%
\]</span> 病死率通常多用于<strong>病程短的急性病</strong>，如各种急性传染病、脑卒中、心肌梗死肝癌及胰腺癌等，以衡量<strong>疾病对人生命威胁的程度</strong>。病死率受疾病严重程度和医疗水平的影响，同时也与能否被早期诊断、诊断水平及病原体的毒力等因素有关。因此，当用病死率作为指标评价不同医院的医疗水平时，应考虑上述因素影响的大小及不同医院入院病人的病情严重程度。</p>
<p>应当注意，在不同场合下，计算病死率所使用的分母是不同的，如计算住院病人中某病的病死率，分母为该病病人的住院人数；而计算某种急性传染病的病死率，其分母为该病的所有发病人数。</p>
<h3 id="疾病的流行强度">疾病的流行强度</h3>
<p><strong>散发(sporadic)是指某病在某地区人群中呈历年的一般发病率水平，病例在人群中散在发生或零星出现，病例之间无明显联系。</strong></p>
<p>散发<strong>用于描述较大范围</strong>(如区、县以上)人群的某病流行强度，而不用于人口较少的居民区或单位，因为其发病率受偶然因素影响较大，年度发病率很不稳定。</p>
<p>确定是否散发一般与同一个地区、同一种疾病<strong>前三年的发病率水平比较</strong>，如当年的发病率<strong>未明显超过历年一般发病率水平</strong>时为散发。</p>
<p>形成散发的原因：</p>
<ul>
<li>某病在当地常年流行，居民有--定的免疫力或因疫苗接种维持着人群的一定免疫水平。</li>
<li>以隐性感染为主的传染病。</li>
<li>传播机制难以实现的传染病。</li>
<li>潜伏期长的传染病。</li>
</ul>
<p><strong>流行(epidemic)指某地区、某病在某时间的发病率显著超过历年该病的散发发病率水平。</strong></p>
<p>流行与散发是相对的概念，用于同一地区某病<strong>历年发病率之间的比较</strong>。有时某病的流行在短期内可越过省界波及全国甚至超出国界及洲界，形成世界性大流行。如2003年SARS的流行，几个月的时间就波及32个国家和地区。</p>
<p>流行性感冒及霍乱也曾多次形成世界性大流行。</p>
<p><strong>暴发(outbreak)是指在一个局部地区或集体单位的人群中，短时间内突然发生许多临床症状相似的病人。</strong></p>
<p>暴发往往是通过<strong>共同的传播途径感染</strong>或由<strong>共同的传染源引起</strong>，如集体食堂的食物中毒和托幼机构的麻疹暴发等。</p>
<h3 id="疾病的分布-1">疾病的分布</h3>
<ul>
<li><p>地区分布</p></li>
<li><p>时间分布</p>
<ul>
<li>短期波动(rapid fluctuation)：又称暴发或时点流行，是指在当个集体或固定人群中，短时间内某病发病数突然增多的现象。</li>
<li>季节性：疾病在一定季节内发病频率升高的现象，称为季节性。</li>
<li>周期性(periodicity)：疾病依规律性的时间间隔发生流行。</li>
<li>长期趋势(secular trend)：又称为长期变异(secular change)，是指在一个相当长的时间内(通常为几年、十几年或几十年)，疾病的发病率、死亡率、临床表现、病原体种类及宿主等随着人类生活条件的改变、医疗技术的进步及自然条件的变化而发生显著变化。</li>
</ul></li>
<li><p>人群分布</p>
<ul>
<li>年龄分布</li>
<li>性别分布</li>
<li>职业分布</li>
<li>种族和民族分布</li>
<li>婚姻和家庭状况</li>
<li>社会阶层</li>
<li>行为</li>
</ul></li>
<li><p>地区、时间、人群分布的综合描述</p>
<ul>
<li><p>移民流行病学是通过比较移民人群、移居地当地人群和原居住地人群的某病发病率和死亡率差异，分析该病的发生与遗传因素和环境因素的关系。它是一种综合描述疾病三间分布的方法。</p>
<p>移民流行病学研究的目的是分析疾病病因中，环境因素与遗传因素的作用大小。</p></li>
</ul></li>
</ul>
<h2 id="病因与病因推断">病因与病因推断</h2>
<p>病因：就是那些能使人群发病概率增加的因素，当其中的一个或多个因素不存在时，人群中发生该种疾病的概率就下降。</p>
<p>流行病学一般将病因称为危险因素(risk factor)，其含义就是指能使疾病发生概率升高的因素，包括化学物理、生物、精神心理以及遗传等方面的因素。</p>
<h3 id="病因模型">病因模型</h3>
<ul>
<li>三角模型：疾病发生的三角模型亦称流行病学三角(triangle of epidemiology)。该模型认为疾病的发生是宿主、环境、动因三要素共同作用的结果。正常情况下，三者通过相互作用保持动态平衡，人们呈健康状态。一旦三者中的一个因素发生变化，且超过了该三角平衡所能维持的最高限度时，平衡被打破，人们将发生疾病。</li>
<li>轮状模型：轮状模型也称车轮模型,该模型强调宿主与环境的密切关系。宿主占据轮轴的位置,其中的遗传物质有重要的作用。外围表示环境，包括生物、理化和社会环境，机体生活在环境之中，而病因存在于机体和环境之中。轮状模型构成的各部分具有伸缩性，其大小随不同的疾病而变化。轮状模型较流行病学三角模型更接近于病因之间以及病因与疾病的实际关系，为研究复杂的慢性疾病的病因打开了新的窗口。</li>
<li>病因网模型：多病因学说认为疾病的发生是各种因素共同作用的结果。各种因素可以独立起作用，也可以相互协同或相互拮抗。各因素之间可以互为因果，从而导致疾病发生的多样性。不同的致病因素与疾病间构成不同的连接方式，即病因链(chain of causation)，多个病因链交错连接起来就形成病因网。病因网模型可以提供因果关系的完整路径。该模型的优点是表达清晰具体,系统性强,能很好地阐述复杂的因果关系。</li>
</ul>
<h3 id="病因的分类">病因的分类</h3>
<ul>
<li>宿主因素
<ul>
<li>遗传因素</li>
<li>免疫状况</li>
<li>年龄和性别</li>
<li>种族</li>
<li>性格、气质和精神心理状态</li>
</ul></li>
<li>行为因素
<ul>
<li>环境因素</li>
<li>不良的嗜好</li>
<li>不良的饮食习惯</li>
<li>不良的文体活动习惯</li>
<li>不健康的性行为</li>
<li>不良的医疗习惯</li>
<li>不良的心理因素</li>
<li>不遵守法律和交通法规</li>
</ul></li>
</ul>
<h3 id="因果推断的逻辑方法">因果推断的逻辑方法</h3>
<p>在形成病因假设及验证假设的过程中,常用的有两种推理方法：假设演绎法和Mill准则。</p>
<p>演绎推理是从一般到个别，从普遍到特殊，它的结论是把前提里的道理缩小范围再讲一次，因而前提真则结论必真。</p>
<p>归纳推理是从个别到一般，从特殊到普遍，它的结论是把前提里的道理扩大范围再讲-一次，因而前提真则结论只是可能真。</p>
<h4 id="假设演绎法">假设演绎法</h4>
<p>假设演绎法(hypothetic deductive method)名称中的“演绎”仅仅指待观察的经验事实，可由假设相对于背景知识演绎地推导出来，从一般的假设导出具体个别的事实,就是一个演绎推理。但从具体个别的事实成立而推出一般的假设也成立，则是一个归纳推理。推理过程：假设演绎地推出具体的证据，然后用观察或实验检验这个证据，如果证据成立，则假设亦成立。从逻辑学上看,反推是归纳的。从一个假设可推出多个具体证据，多个具体证据的经验证实，则可使归纳支持该假设的概率增加。</p>
<h4 id="mill准则">Mill准则</h4>
<p>流行病学研究中常采用Mill准则(Mill's cannon)形成病因假设，包括以下几种逻辑推理方法：</p>
<ul>
<li>求同法(method of agreement)又称“异中求同法”，是指在不同事件中寻求其共同点。</li>
<li>求异法(method of difference)又称“同中求异法”，是指在相似的事件之间寻求不同点。</li>
<li>共变法(method of concomitant variation)是指某因素出现的频率和强度发生变化，某病发生的频率与强度也随之变化，则该因素很可能是该病的病因，二者间往往呈剂量-反应关系。</li>
<li>类推法(method of analogy)是指所研究的某种疾病的病因和分布特征与另一种病因已知的疾病的分布特征相似，那么可以推测这两种疾病的病因可能相同。</li>
<li>排除法 (method of exclusion)指通过对假设的排除而建立假设的方法。研究病因的过程中有时会产生若干假设，在许多条件相同的人群中采取排除方法，对已知不可能引起某种医学事件的因素逐一排除，最后保留下来没有任何排除依据的某一因素可能就是引起该医学事件的原因。该方法也是一种逻辑推理方法。</li>
</ul>
<h3 id="因果关联的推断标准">因果关联的推断标准</h3>
<ul>
<li>关联的强度(strength of association) 关联的强度是两事件发生频率的相对比。在流行病学中评价关联强度的主要指标常以相对危险度(RR)或比值比(OR)表示。一般而言，关联的强度越大，则研究因素与某种疾病的因果关系可能性就越大。在设计和分析都正确的前提下，如果RR≥3 ，那么两事件间很可能存在因果关联。某因素与某种疾病的关联强度越大，则二者间虚假关联和间接关联的可能性越小，因果关联的可能性越大。例如，吸烟与肺癌的RR值为13.7，而吸烟与冠心病的RR值为2，因而提示吸烟与肺癌的因果关联的可能性比吸烟与冠心病的因果关联的可能性大。</li>
<li>关联的时间顺序(temporality of association) 因果关联中，有因才有果，“因”一定先于“果”。在确定前因后果的时间顺序上，实验研究、前瞻性研究中容易判断，但病例对照研究或横断面研究中则常常难以判断。例如，伦敦烟雾事件后呼吸道和心血管疾病的死亡率上升，欧洲“反应停”大量上市后发生的海豹短肢畸形儿的数量增加，都提示了明确的时间先后关系。</li>
<li>关联的特异性(specificity of association) 关联的特异性是指病因与疾病有严格的对应关系，即某种因素只能引起某种特定的疾病，某种疾病只能由某因素引起。如果某病与多种因素有关,或某因素与多种疾病有关,就不能称为特异性。这种关联的特异性一般只适用于传染病，而对大多数非传染病而言，病因关联的特异性并不十分明显。随着人们对疾病病因研究的不断深人，尤其是对慢性疾病病因的探讨，该标准的概念可能是不存在的，或是无用的。所以国内外的研究者主张放弃这一标准。</li>
<li>关联的可重复性(consistency of association) 关联的可重复性指在不同的人群、不同的地区、不同的时间由不同的研究者用不同的研究方法进行研究均可获得相同的结果。重复出现的次数越多，因果推断越具有说服力。与观察性研究相比，实验性研究的可重复性较好，这是因为实验性研究的控制条件较好。如关于吸烟与肺癌关系的流行病学研究中，所有的研究均有相似的结果，因而加强了因果关联存在的可能性。</li>
<li>剂量反应关系(dose-response relationship) 随着某因素暴露剂量的增加，人群中发生某疾病的频率随之增加、因果联系的强度增大，则认为该因素与该疾病间存在剂量反应关系。在吸烟与肺癌的研究中，有研究资料表明平均每日吸烟量越多发生肺癌的概率越大；而戒烟人群中，戒烟的年限越长，发生肺癌的概率越小，吸烟与肺癌呈现出明显的剂量反应关系。</li>
<li>因素与疾病分布的一致性(coherence of association) 因素与疾病分布的一致性是指研究的因素与疾病二者的分布相符合。有研究者对1900-1950年间某国肺癌死亡率的增加与烟草的消费量之间呈明显的相关关系，提示肺癌与吸烟之间可能存在因果联系。</li>
<li>关联的生物学合理性(biologic plausibility of association) 暴露与疾病的关联，应该具有生物学上的合理性,应该符合疾病的自然史和生物学原理，在科学上应“言之有理”，即用现代医学知识可以对其做出合理的解释。例如，高血脂症与冠心病的因果关联，与冠状动脉硬化的病理证据以及动物实验结果相吻合。</li>
<li>实验证据(experimental evidence) 观察性研究的结果如能得到实验证据的证实,则说服力大大提高。如孕妇服用“反应停”引起胎儿海豹短肢畸形，停止销售反应停，在一个较长的潜伏期后病例消失，这一结果极大地支持了反应停与海豹肢畸形的病因假设。</li>
<li>相似性(analogy) 相似性是指如果已知某化学物有致病作用，当发现另一种类似的化学物与某种疾病有联系时，则两者因果关系成立的可能性也较大。</li>
</ul>
<p>因果关系的推断过程较复杂，在上述9条标准中,必须满足关联的时间顺序,关联的强度、关联的特异性、关联的可重复性及剂量反应关系等虽然不是必要条件，但也都有极其重要的意义。在因果关联的判断中，满足上述标准的条件越多，因果关联的可能性就越大。但若有些标准不满足,也不能否定因果关联的存在，还要对研究设计进一步考证后才能得出结论。</p>
<h2 id="描述性研究">描述性研究</h2>
<p><strong>描述性研究：指利用已有的资料或通过专题调查获得的资料(包括实验室检查结果)，描述疾病或健康状况的三间分布特征，进而获得病因线索，提出病因假设。</strong></p>
<p>描述性研究是揭示暴露和疾病因果关系过程中最基础的步骤。</p>
<h3 id="描述性研究的特点">描述性研究的特点</h3>
<ul>
<li>以<strong>观察</strong>为主要研究手段，<strong>不</strong>对研究对象<strong>采取任何干预措施</strong>。通过观察和收集相关资料，分析和总结研究对象或事件的特点。</li>
<li>暴露因素<strong>不是随机分配</strong>的，且研究开始时一般<strong>不设立对照组</strong>。</li>
<li><strong>暴露与结局</strong>的<strong>时序关系无法确定</strong>，对于暴露与结局间关系的<strong>因果推断存在一定的局限性</strong>，但可做一些初步的比较性分析，为后续研究提供线索。</li>
</ul>
<h3 id="描述性研究的类型">描述性研究的类型</h3>
<ul>
<li>个例调查(case investigation)：又称个案调查或病家调查，是指对个别发生的病例病例的家庭及周围环境进行的流行病学调查。病例一般为传染病病人，也可以是非传染病病人或病因未明病例。</li>
<li>病例报告(case report)：又称“个案报告”，是临床上对某种罕见病的单个病例或少数病例进行研究的主要形式，也是唯一的方法。病例报告通常是对单个病例或5个以下病例的病情诊断及治疗中发生的特殊情况或经验教训等的详尽临床报告。</li>
<li>病历系列分析(case series analysis)：是临床医生最为熟悉的临床研究方法，它对一组(可以是几例、几十例几百例甚至是几千例)相同疾病病人的临床资料进行整理、统计分析并得出结论。病例分析常常是利用已有资料进行分析，因此它属于回顾性研究范畴。</li>
<li>现况研究</li>
<li>生态学研究</li>
</ul>
<h3 id="现况研究">现况研究</h3>
<p><strong>现况研究(prevalence survey)：指按照事先设计的要求，在某一特定人群中，应用普查或抽样调查等方法收集特定时间内某种疾病或健康状况及有关因索的资料，以描述资料的分布特征。</strong></p>
<p>从时间上说，现况研究是在<strong>特定时间内进行</strong>的，一般不是过去的暴露史或疾病情况，也不是追踪观察将来的暴露与疾病情况，故又称之为<strong>横断面研究</strong>(cross sectional study)。</p>
<p>现况研究从观察分析指标来说，由于这种研究所得到的频率指标一般为特定时间内调查群体的患病率，所以又称为<strong>患病率研究</strong>或<strong>现患研究</strong>(prevalence study)。又由于所收集的有关因素与疾病或健康状况之间关系的资料是调查当时所获得的，故称之为现况研究。</p>
<p>现况研究<strong>并非只对现象做静态分析</strong>，也可以通过对<strong>多个断面的现况研究做动态分析</strong>，了解疾病或健康状况的地区分布和人群分布等在多次调查期间的<strong>变化趋势</strong>，发现疾病或健康状况的发生规律，并有可能对将来的变化趋势做出预测。</p>
<h4 id="现况研究的特点">现况研究的特点</h4>
<ul>
<li>在设计阶段一般不设立对照组</li>
<li>特定时间</li>
<li>确定因果关系时受到限制</li>
<li>对研究对象固有的暴露因素可以作因果推断</li>
<li>用现在的暴露(特征)来代替或估计过去情况的条件</li>
<li>定期重复进行可以获得发病率资料</li>
<li>一般不用于病程较短的疾病</li>
</ul>
<h4 id="现况研究的类型">现况研究的类型</h4>
<ul>
<li>普查(census)：即全面调查，是指为了解某人群健康状况或某疾病的患病率，或制定某生物学检验标准，在特定时间内对特定范围内(某-地区或具有某种特征)人群中每一成员所做的调查或检查。 “特定时间”应该较短，有时甚至指某个时点，如时间太长，人群中某种疾病的患病率或健康状况会发生变化，影响普查质量。一般小规模普查可在几天或几周内完成，大规模普查可在几个月内完成。“特定范围”既可以是某个单位或某个居民点，也可以指某个地区，甚至全国。</li>
<li>抽样调查(sampling survey)：指在特定时点、特定范围内的某人群总体中，按照一定的方法抽取一部分有代表性的个体组成样本进行调查分析，以此推论该人群总体某种疾病的患病率及某些特征的一种调查。</li>
</ul>
<h4 id="现况研究的目的">现况研究的目的</h4>
<ul>
<li>描述特定时间疾病或健康状况的三间分布</li>
<li>发现病因线索</li>
<li>适用于疾病的二级预防</li>
<li>评价疾病的防治效果</li>
<li>用于疾病监测</li>
<li>为研究和决策提供基础性资料</li>
</ul>
<h4 id="现况研究的偏倚及其控制">现况研究的偏倚及其控制</h4>
<ul>
<li>选择偏倚
<ul>
<li>无应答偏倚(non-response bias)：调查对象不合作或因种种原因不能或不愿意参加，由于这些人的身体素质、暴露状况、患病情况、嗜好等可能与应答者不同，由此产生的偏倚称为无应答偏倚。如应答率低于80%就较难通过调查结果来估计整个研究对象群体的现况。</li>
<li>选择性偏倚：在调查过程中，没有严格按照随机化原则抽样或主观选择研究对象，从而导致样本偏离总体的情况。如根据出院号来随机抽样时，任意变换抽样方法，改用人院号等其他方法来抽样；被抽中的调查对象没有找到，而随便找其他人代替，从而可能破坏了调查对象的同质性。</li>
<li>幸存者偏倚：在现况研究中，调查对象均为幸存者，无法调查死亡的对象，因此不能全面反映实际情况，带有一定的局限性和片面性。</li>
</ul></li>
<li>信息偏倚：主要发生在观察、收集资料及测量等实施阶段。
<ul>
<li>调查对象引起的偏倚：询问调查对象有关问题时，由于种种原因回答不准确从而引起偏倚(报告偏倚或说谎偏倚)；调查对象对过去的暴露史等回忆不清，由其家属代替回忆，特别是健康的调查对象由于没有患病的经历，而容易将过去的暴露情况等遗忘，进而导致回忆偏倚。</li>
<li>调查员偏倚：调查员有意识地调查具有某些特征的对象，而不重视或马虎调查其他不具备某些特征的对象，而导致调查偏倚。如对病人再三询问其吸烟史，对健康者则不然。</li>
<li>测量偏倚：指测量工具检验方法不准确，检验技术操作不规范等，或工作粗心而导致测量偏倚。</li>
</ul></li>
<li>偏倚控制：
<ul>
<li>严格遵照抽样方法的要求，确保抽样过程中随机化原则的完全实施。</li>
<li>提高研究对象的依从性和受检率。</li>
<li>正确选择测量工具和监测方法，包括调查表的编制等。</li>
<li>组织好研究工作，调查员要经过统一培训，统-t标准和认识。</li>
<li>做好资料的复查、复核等工作。</li>
<li>选择正确的统计分析方法，注意辨析混杂因素及其影响。</li>
</ul></li>
</ul>
<h4 id="现况研究的优点和缺点">现况研究的优点和缺点</h4>
<ul>
<li>优点
<ul>
<li>常用抽样调查，结果有较强推广意义。</li>
<li>有来自同一群体的自然形成的同期对照组，结果具有可比性。</li>
<li>可同时观察多种因素。</li>
</ul></li>
<li>缺点
<ul>
<li>难以确定先因后果的时相关系。</li>
<li>不能获得发病率资料。</li>
<li>研究对象可能处于临床前期而被误定为正常人。</li>
</ul></li>
</ul>
<h3 id="生态学研究">生态学研究</h3>
<p><strong>生态学研究(ecological study) ：描述性研究中的一种，它是以群体为基本单位收集和分析资料，在群体的水平上描述不同人群中某因素的暴露状况与某种疾病的频率，研究某种因素与某种疾病之间的关系。</strong></p>
<p>例如烟草消耗量与肺癌发病率关系的研究就是生态学研究。</p>
<h4 id="生态学研究的特点">生态学研究的特点</h4>
<ul>
<li>与现况研究不同，生态学研究在收集疾病以及某因素的资料时，不是在个体水平上进行，而是<strong>以群体为单位</strong>(如国家、城市、学校等)。虽然无法得知个体的暴露与效应间的关系，但可以<strong>反映群体的平均水平</strong>，这是生态学研究的最基本特征。通过描述某种疾病或健康状况在各群体中所占的百分数或比数，以及有某种特征的个体在群体中所占的百分数或比数，从这两组群体数据分析某种疾病或健康状况的分布与群体特征分布的关系，从而探求病因线索。</li>
<li>生态学研究是从许多因素中探索病因线索的一种方法，然而其提供的信息是不完整的，只是一种<strong>粗线条的描述性研究</strong>。</li>
</ul>
<h4 id="生态学研究的优点和局限性">生态学研究的优点和局限性</h4>
<ul>
<li><p>优点</p>
<ul>
<li>可应用常规或现成资料进行研究，节省时间、人力、物力、财力。</li>
<li>可提供线索供病因未明疾病的病因学研究，这是生态学研究最显著的优点。</li>
<li>对于个体的暴露剂量无法测量的变量研究(如空气污染与肺癌的关系)和人群中变异较小和难以测定的暴露研究(如脂肪摄入量与乳腺癌的关系)，生态学研究是唯一可供选择的研究方法。</li>
<li>适合于对人群干预措施的评价。</li>
<li>当研究的暴露因素在一个人群中的变异范围很小时，很难测量其与疾病的关系。这种情况下，更适合采用多个人群比较的生态学研究。</li>
<li>在疾病监测工作中，应用生态趋势研究可估计某种疾病的发病趋势。</li>
</ul></li>
<li><p>局限性</p>
<ul>
<li><p>生态学谬误(ecological fallacy)：生态学研究是以由各个不同情况的个体集合而成的群体为观察和分析的单位，无法得知个体的暴露与效应(疾病或健康状况)间的关系，得到的资料是群体的平均水平，是粗线条的描述，因此会削弱变量之间的联系，同时存在的混杂因素等原因会造成研究结果与真实情况不符，从而产生了生态学谬误，它是生态学研究最主要的缺点。</p>
<p>生态学谬误的产生主要有以下几种情况：</p>
<ul>
<li>无法控制可疑的混杂因素。</li>
<li>缺乏暴露与结局联合分布的资料。</li>
<li>相关资料中的暴露水平只是近似值或平均水平，并不是个体真实暴露情况，无法精确评价暴露与疾病的关系，造成对暴露与研究结局之间联系的一种曲解。</li>
</ul></li>
<li><p>缺乏控制可疑混杂因素的能力</p></li>
<li><p>当暴露因素与疾病之间存在着非线性关系时，生态学研究很难得出正确结论</p></li>
</ul></li>
</ul>
<h2 id="队列研究">队列研究</h2>
<p><strong>队列研究(cohort study)：将研究人群按照是否暴露于某个因素或暴露的程度分为暴露组和非暴露组，追踪观察并比较两组成员在特定时间内与暴露因素相关结局(如疾病)发生率的差异，从而判定暴露因素与结局之间有无因果关联及关联程度的一种观察性研究方法。</strong></p>
<p>与队列研究类似的名称有<strong>前瞻性研究</strong>(prospective study)、<strong>发生率研究</strong>(incidence study)、<strong>随访研究</strong>(follow-up study)或<strong>纵向研究</strong>(longitudinal study)等。</p>
<p><strong>暴露(exposure)：泛指能影响结局(如疾病)的各种因素，即研究对象所具有的与结局有关的特征或状态(如年龄性别、职业、遗传、行为、生活方式等)或曾接触与结局有关的某因素(如X线照射、重金属、环境因素等)，这些特征状态或因素即为暴露因素，也称为研究因素或研究变量。</strong></p>
<p>因此，暴露在不同的研究中有不同的含义，暴露可以是有害的，也可以是有益的，但都是研究者感兴趣的。</p>
<p><strong>队列(cohort)：表示具有某种共同特征的一组人群。</strong></p>
<p>例如长期居住在某地区范围内的人群(社区人群队列)或者符合特定标准的某种疾病的病人人群(专病队列)。</p>
<p>根据研究对象进出队列的时间不同，队列又可分为两种，这两种队列结局发生率的计算方法不同。</p>
<ul>
<li>固定队列(fixed cohort)：指观察对象都在某一时刻或一个短时期之内进入队列，之后不再加入新的成员，随访观察至观察期终止，观察对象很少或几乎没有因为所研究疾病等结局事件以外的其他原因退出，即在整个观察期内队列成员是相对固定的。</li>
<li>动态队列(dynamic cohort)：在整个观察期内，原有的队列成员可以不断退出，新的观察对象可以随时进人，即整个观察期内队列成员不是固定的。</li>
</ul>
<h3 id="队列研究的基本原理">队列研究的基本原理</h3>
<p>队列研究的基本原理是在某一特定人群中，根据目前或过去某个时期是否暴露于某个/些待研究的因素将研究对象分为暴露组和非暴露组，或按不同的暴露水平将研究对象分成不同的亚组，如低水平暴露组、中等水平暴露组和高水平暴露组，随访观察各组人群待研究结局(如疾病、死亡或其他健康事件)的发生情况，比较各组结局的发生率，从而判定暴露因素与结局的因果关系。如果暴露组与非暴露组之间某结局发生率的差异有统计学意义，研究中又不存在明显的偏倚，则可推测暴露与结局之间可能存在因果关系，再进一步估计暴露与结局之间关联的强度。</p>
<ul>
<li>队列研究基本原理示意图</li>
</ul>
<figure>
<img src="../images/队列研究的基本原理示意图.png" alt="队列研究的基本原理示意图" /><figcaption aria-hidden="true">队列研究的基本原理示意图</figcaption>
</figure>
<h3 id="队列研究的特点">队列研究的特点</h3>
<ul>
<li>时间上是前瞻性的</li>
<li>属于观察性研究</li>
<li>研究对象按暴露与否进行分组</li>
<li>是从“因”到“果”的研究</li>
</ul>
<h3 id="队列研究的类型">队列研究的类型</h3>
<ul>
<li>前瞻性队列研究</li>
<li>历史性队列研究</li>
<li>历史前瞻性队列研究</li>
</ul>
<h3 id="队列研究的用途">队列研究的用途</h3>
<ul>
<li>检验病因假设</li>
<li>评价预防效果</li>
<li>研究疾病自然史</li>
<li>预后因素研究和新药上市后监测</li>
</ul>
<h3 id="队列研究的研究设计与实施">队列研究的研究设计与实施</h3>
<h4 id="确定研究人群">确定研究人群</h4>
<ul>
<li>暴露组的选择
<ul>
<li>职业人群：如果要研究某种可疑的职业暴露因素与疾病或健康的关系，必须选择相关职业人群作为暴露人群。</li>
<li>特殊暴露人群：指由于某种原因对某因素有较高暴露水平的人群。</li>
<li>一般人群：即某行政区域或地理区域范围内的全体人群。</li>
<li>有组织的人群团体：即某些群众组织或专业团体成员、机关或社会团体成员、部队成员、参加人寿保险或医疗保险的人员等。</li>
</ul></li>
<li>对照人群的选择
<ul>
<li>内对照(internal control)：如果在一般人群或有组织的人群团体中选择暴露于所研究因素的对象作为暴露组，那么其余非暴露者就可作为对照组，此即内对照。</li>
<li>外对照(external control)：当选择职业人群或特殊暴露人群作为暴露组时，往往不能从这些人群中选出足够数量的具有可比性的对照，常需在该人群之外寻找对照组，这样选择的对照称为外对照。</li>
<li>总人口对照(total population control)：即在采用职业人群或特殊暴露人群作为暴露组时，以该地区全人口的发病或死亡率作为对照。</li>
<li>多重对照(multiple controls)：即同时选取上述两种或两种以上形式的对照。</li>
</ul></li>
</ul>
<h4 id="估计样本量">估计样本量</h4>
<p>一般说来，对照组的样本量不宜少于暴露组的样本量，通常是相等的。如果某一组样本太少，将使合并标准差增大，因而要求总样本量增大。</p>
<p>队列研究通常要追踪观察相当长一段时间，这期间内研究对象的失访几乎是难免的。因此，在计算样本量时，需要<strong>预先估计失访率</strong>，<strong>适当扩大样本量</strong>，防止在研究的最后阶段因失访所致的样本量不足而影响结果的分析。如假设失访率为10% ，则可按计算出来的样本量再加10%作为实际样本量。</p>
<p>样本量的影响因素</p>
<ol type="1">
<li><strong>对照组(或一般人群)</strong>的估计结局发生率 <span class="math inline">\(p_0\)</span></li>
<li><strong>暴露组</strong>的估计结局发生率 <span class="math inline">\(p_1\)</span></li>
<li>统计学要求的显著性水平 <span class="math inline">\(α\)</span></li>
<li>把握度 <span class="math inline">\(1-β\)</span></li>
</ol>
<ul>
<li>前两个因素可通过查阅相关文献或预调查获得，估计的暴露组与对照组结局发生率之差越小，所需样本量越大。</li>
<li><span class="math inline">\(α\)</span> 和 <span class="math inline">\(β\)</span> 值由研究者根据实际情况来确定， <span class="math inline">\(α\)</span> 和 <span class="math inline">\(β\)</span> 值越小，则所需样本量越大。为保证研究的可靠性，把握度应至少为0.80。</li>
<li>如果不能获得暴露组人群结局发生率 <span class="math inline">\(p_1\)</span> ，也可通过查阅文献获得相对危险度 <span class="math inline">\(RR\)</span> 的值，由式 <span class="math inline">\(p_1=RR×p_0\)</span> 求得 <span class="math inline">\(p_1\)</span> 。</li>
<li>如果没有 <span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(RR\)</span> 资料时，可以根据专业知识人为设定RR达到某个阈值时才有病因学意义。</li>
</ul>
<p>在暴露组与对照组样本量相等的情况下，可用下式计算出各组所需的样本量。式中 <span class="math inline">\(p_1\)</span> 与 <span class="math inline">\(p_0\)</span> 分别代表暴露组与对照组的估计结局发生率， <span class="math inline">\(\overline p\)</span> 为两组结局发生率的平均值， <span class="math inline">\(q=1-p\)</span> ， <span class="math inline">\(Z_α\)</span> 和 <span class="math inline">\(Z_β\)</span> 分别为 <span class="math inline">\(α\)</span> 和 <span class="math inline">\(β\)</span> 对应的标准正态分布临界值，可查表获得。 <span class="math display">\[
n=\frac{(Z_α\sqrt{2\overline{p}\overline{q}}+Z_β\sqrt{p_0q_0+p_1q_1})^2}{(p_1-p_0)^2}
\]</span></p>
<h3 id="队列研究的资料分析">队列研究的资料分析</h3>
<p>与其他研究方法相同，队列研究在资料分析前，应对原始资料进行审查，了解资料的正确性与完整性。对有明显错误的资料应进行重新调查、修正或剔除；对不完整的资料要设法补齐。</p>
<p>队列研究的资料整理与分析思路：</p>
<ul>
<li>先对资料做描述性统计：确定研究对象的暴露状态与暴露人数或人时数，确定结局事件发生人数及失访情况等，描述研究对象的人口学特征，分析两组的可比性及资料的可靠性。</li>
<li>然后再进行推断性分析：计算并比较两组或多组结局发生率的差异，分析暴露的效应，即暴露与结局是否有关联及其关联强度。</li>
</ul>
<h4 id="结局发生率">结局发生率</h4>
<p>看书 p58(累计发病率、发病密度)</p>
<h4 id="关联强度">关联强度</h4>
<p>看书 p59(RR 、AR)</p>
<h3 id="队列研究的偏倚及其控制">队列研究的偏倚及其控制</h3>
<p>选择偏倚及其控制</p>
<ul>
<li>暴露与结局之间的关系可能因失访而被歪曲，这种情况称为<strong>失访偏倚</strong>(lost to follow-up bias)，它是队列研究中最常见的选择偏倚。
<ul>
<li>如果暴露组和对照组的失访率相近，各组中失访者和未失访者的基本特征和结局发生率相似，则可以认为通过该研究获得的各组发病率可以反映该研究人群的实际情况，失访对研究结果没有影响。</li>
<li>如果暴露组失访者的发病率高于未失访者，则从继续观察者获得的发病率要低于全部研究对象的实际发病率，使暴露与结局的联系被低估；如果暴露组失访者的发病率低于未失访者，则其偏倚效应相反。</li>
</ul></li>
<li>选择偏倚一旦产生，往往很难消除，因此应采取预防为主的方针，严格按规定的标准选择便于随访的人群；研究对象一旦选定 ，必须尽可能克服困难，坚持对每个研究对象随访到整个研究结束。一项队列研究的失访率最好不超过10% ，否则应慎重解释结果和推论，即在资料分析时，对失访者和已完成随访者的基线特征进行比较，并从各种途径尽可能了解失访者最后的结局，与已完成随访者的最后观察结果做比较，推测失访可能对研究结果产生的影响，做出恰如其分的结论。</li>
</ul>
<p>信息偏倚及其控制</p>
<ul>
<li>队列研究中的信息偏倚常是由于使用的仪器不精确、询问技巧不佳、检验技术不熟练、对暴露组和对照组成员随访方法不一致、诊断标准不明确或不统一等造成的暴露错分、疾病错分以及暴露与疾病的联合错分所致。</li>
<li>选择精确稳定的测量方法、调准仪器、严格实验操作规程、同等地对待暴露组和对照组成员或采取盲法随访、提高临床诊断技术、明确各项标准并严格执行是防止信息偏倚的重要措施。此外，还应认真做好调查员培训，提高询问调查技巧，统一标准，并要求调查员有一定的责任心。</li>
</ul>
<p>混杂偏倚及其控制</p>
<ul>
<li>在队列研究中，如果暴露组和对照组在一些影响研究结果的主要特征(如性别、年龄等)上不一致，就会产生混杂偏倚。</li>
<li>可通过在研究设计阶段对研究对象的条件作某种限制，以便获得同质的研究样本，或者采用匹配的办法选择对照，以保证暴露组和对照组在一些重要变量上的可比性；以及在资料分析阶段采用标准化率分析、分层分析和多变量分析等方法来控制混杂偏倚。</li>
</ul>
<h3 id="队列研究的优点与局限性">队列研究的优点与局限性</h3>
<ul>
<li>优点
<ul>
<li>由于研究对象暴露资料的收集在结局发生之前，并且都是由研究者亲自观察得到或来自历史记录，所以资料可靠。</li>
<li>可以直接获得暴露组和对照组的发病(或死亡)率，直接计算出RR和AR等反映暴露与疾病关联强度的指标。</li>
<li>由于暴露在前，疾病发生在后，因果时间顺序明确，加之偏倚较少，故检验病因假说的能力较强，可证实因果联系。</li>
<li>随访观察过程有助于了解人群疾病的自然史。</li>
<li>能对一种暴露因素所致的多种疾病同时进行观察，分析一种暴露与多种疾病的关系。</li>
</ul></li>
<li>局限性
<ul>
<li>前瞻性研究耗费的人力物力、财力和时间较多，不易实施。</li>
<li>不适于发病率很低的疾病的病因研究。</li>
<li>由于随访时间较长，容易产生失访偏倚。</li>
<li>在随访过程中，未知变量引人人群，或人群中已知变量的变化等，都可使结局受到影响，使分析复杂化。</li>
</ul></li>
</ul>
<h2 id="病例对照研究">病例对照研究</h2>
<p><strong>病例对照研究(case-control study)：按照有无所研究的疾病或某种卫生事件，将研究对象分为病例组和对照组，分别追溯其既往(发病或出现某种卫生事件前)所研究因素的暴露情况，并进行比较，以推测疾病与因素之间有无关联及关联强度大小的一种观察性研究。</strong></p>
<p>病例对照研究的基本设计思路是收集病例和对照过去的暴露情况，在时间顺序上属回顾性质，因此又称其为<strong>回顾性研究</strong>(retrospective study)，但并不是所有的回顾性调查研究都是病例对照研究。病例对照研究是一种回顾性的、<strong>由果及因</strong>的研究方法，是在疾病发生之后去追溯假定的病因因素的方法。</p>
<h3 id="病例对照研究的基本原理">病例对照研究的基本原理</h3>
<p>按照设计要求，根据研究对象是否患有所要研究的某种疾病或出现研究者所感兴趣的卫生事件，将研究对象分为病例组和对照组，通过询问、实验室检查或复查病史等方法，收集两组人群过去某些因素的暴露情况和(或)暴露程度，测量并比较病例组与对照组中各因素的暴露比例之间的差别是否有统计学意义。</p>
<p>如果病例组的暴露比例[a/(a+c)]与对照组的暴露比例[b/(b+d)]差别有统计学意义，则认为这种暴露与所研究疾病存在统计学关联，进而在估计各种偏倚对研究结果影响的基础上，分析暴露与疾病的关联强度。</p>
<p>病例对照研究中的所谓“病例”可以是某疾病的病人，或某种病原体的感染者，或具有某特征事件(如健康、有效、痊愈、死亡、药物副作用等)的人，对照可以是未患该病的其他病人，或不具有所感兴趣的事件的个体，或健康人。病例对照研究中的暴露因素，既可以是增加疾病等事件发生概率的各种危险因素，也可以是降低疾病等事件发生概率的保护因素。</p>
<ul>
<li>病例对照研究基本原理示意图</li>
</ul>
<figure>
<img src="../images/病例对照研究基本原理示意图.png" alt="病例对照研究基本原理示意图" /><figcaption aria-hidden="true">病例对照研究基本原理示意图</figcaption>
</figure>
<h3 id="病例对照研究的特点">病例对照研究的特点</h3>
<ul>
<li>属于观察性研究</li>
<li>设立对照</li>
<li>由果推因</li>
<li>论证强度：一般而言不能证实暴露因素与疾病之间的因果联系，但可为队列研究及实验性研究提供病因研究的线索和方向。</li>
</ul>
<h3 id="病例对照研究的类型">病例对照研究的类型</h3>
<ul>
<li>非匹配病例对照研究：对于病例和对照之间的关系不作限制和规定。在设计所规定的病例和对照人群中，分别抽取一定数量的研究对象，一.般对照人数应等于或多于病例人数。</li>
<li>匹配病例对照研究：匹配(matching)又称作配比，是指所选择的对照在某些因素或特征上与病例保持一致。这些因素或特征被称为匹配因素或匹配变量，例如年龄、性别、居住地等。匹配的目的是去除这些因素或特征对研究结果的干扰，从而更准确地说明所研究因素与疾病的关系，提高研究的效率。
<ul>
<li>成组匹配病例对照研究：成组匹配(category matching)又称频数匹配(frequency matching)，是指对照组具有某种或某些因素或特征者所占的比例与病例组一致或相近，即病例组与对照组之间某些因素和特征的分布一致或接近。</li>
<li>个体匹配病例对照研究：个体匹配(individual matching)是指以个体为单位使病例和对照在某种或某些因素或特征方面相同或接近。1个病例可以匹配1个对照，这种情况叫配对(pair matching)。如果对照易得而病例罕见时，也可以1个病例匹配多个对照，如1：2、1.3.....1：R。由Pitman效率递增公式2R/(R+1)可知，随着R值的增加效率也在增加，但增加的幅度越来越小。由于超过1 ： 4匹配时研究效率增加缓慢且增加工作量，故不建议采用。</li>
</ul></li>
</ul>
<h3 id="病例对照研究的用途">病例对照研究的用途</h3>
<ul>
<li>广泛探索影响因素</li>
<li>深入检验某个或某几个病因假说</li>
<li>研究健康状态等事件发生的影响因素</li>
<li>疾病预后因素的研究</li>
<li>临床疗效影响因素的研究</li>
</ul>
<h3 id="病例对照研究的研究设计与实施">病例对照研究的研究设计与实施</h3>
<h4 id="确定研究对象">确定研究对象</h4>
<p>病例</p>
<ul>
<li>病例对照研究中的病例是指患有所研究疾病且符合研究入选标准的人。</li>
<li>病例选择的原则：
<ul>
<li>代表性：选择的病例应足以代表产生病例的靶人群(即产生这组病人的目标人群)中的全部病例。</li>
<li>诊断明确：必须对所研究疾病的诊断标准作出明确的规定，所有病例都应符合严格的诊断标准。疾病的诊断标准应客观具体、可操作性强，尽可能按国际及国内统一标准执行，以便与他人的工作比较。对于无明确诊断标准的疾病，可根据研究的需要制定明确的工作定义。</li>
<li>此外，为了控制非研究因素对结果的干扰，可对研究对象的某些特征(如性别年龄、民族等)作出规定或限制。</li>
</ul></li>
<li>病例的类型：
<ul>
<li>新发病例(incident case)</li>
<li>现患病例(prevalent case)</li>
<li>死亡病例(death case)</li>
</ul></li>
<li>病例的来源：
<ul>
<li>来自医院，即以医院为基础(hospital-based)：从医院中选择的病例，可以是门诊病人或住院病人，也可以是已经出院甚至死亡的病人。其优点是方便可行，节省费用，合作性好，信息较完整、准确，对于罕见病有时是唯一可行的方法，但从医院中选择病例容易发生选择偏倚。</li>
<li>来自社区，即以社区为基础(community-based)：从社区人群中选择病例时，可以利用疾病监测资料或居民健康档案选择合格的病例，对于常见病也可以组织专门的调查(普查、抽样调查)，从社区居民中发现该病的病例。其最大优点是代表性较强，但病例获得比较困难，工作量和工作难度均较大。</li>
</ul></li>
</ul>
<p>对照</p>
<ul>
<li>对照的选择原则：
<ul>
<li>对照必须是未患所研究疾病的人，即按照所研究疾病的诊断标准判定的非病人。</li>
<li>选择对照应遵循代表性和可比性的原则。
<ul>
<li>代表性体现为所选择的对照应能代表目标人群暴露的分布情况，最好是全人群的一个无偏样本 ，或是产生病例的靶人群中全体未患该病人群的一个随机样本，如进行某社区40岁以上女性糖尿病危险因素的研究，对照应为该社区人群中同龄女性非糖尿病者的随机样本。</li>
<li>可比性是指除研究因素(暴露因素)以外，其他有关因素在病例组与对照组间的分布应一致，如年龄性别、居住地等。</li>
</ul></li>
</ul></li>
<li>对照的形式：
<ul>
<li>选择对照时主要采取匹配与非匹配两种方式。匹配的目的主要是提高研究效率(study efficiency )，其次在于控制混杂因素的干扰。因此，在条件许可时尽可能采取匹配的方式选取对照，如果病例和对照的来源都较充分，则以配对为佳；如果病例少而对照相对易得，则可采用一个病例匹配多个对照的方式。</li>
</ul></li>
<li>对照的来源：
<ul>
<li>同一或多个医疗机构中其他疾病的病人</li>
<li>社区人口或团体人群中非该病病例或健康人</li>
<li>病例的邻居或同一住宅区内的健康人或非该病病人</li>
<li>病例的配偶、同胞、亲戚、同学或同事等</li>
</ul></li>
</ul>
<h4 id="估计样本量-1">估计样本量</h4>
<p>足够的样本量是获得预期结果的必要条件和保证，病例对照研究中样本量的估计是研究设计的必要步骤。</p>
<p>样本量的影响因素</p>
<ol type="1">
<li>研究因素在对照人群(对照组)中的估计暴露率 <span class="math inline">\(p_0\)</span></li>
<li>研究因素与疾病关联强度的估计值，即相对危险度 <span class="math inline">\(RR\)</span> 或比值比 <span class="math inline">\(OR\)</span></li>
<li>假设检验的显著性水平，即第I类错误的概率 <span class="math inline">\(α\)</span></li>
<li>检验的把握度 <span class="math inline">\(1-β\)</span> ， <span class="math inline">\(β\)</span> 为第II类错误的概率</li>
</ol>
<ul>
<li>一般而言， <span class="math inline">\(α\)</span> 和 <span class="math inline">\(β\)</span> 越小，所需样本量越大。</li>
<li><span class="math inline">\(α\)</span> 、 <span class="math inline">\(β\)</span> 和 <span class="math inline">\(p_0\)</span> 一定时， <span class="math inline">\(RR\)</span> 或 <span class="math inline">\(OR\)</span> 的估计值越远离1，即因素对疾病发生的作用越强，所需的样本量越小。</li>
<li><span class="math inline">\(p_0\)</span> 与 <span class="math inline">\(p_1\)</span> 差值越大，所需样本量越小。</li>
</ul>
<p>估计公式同队列研究。其中， <span class="math inline">\(p_1\)</span> 还可以通过下式计算。 <span class="math display">\[
p_1=\frac{OR\times p_0}{1-p_0+OR\times p_0}
\]</span></p>
<h3 id="病例对照研究的资料分析">病例对照研究的资料分析</h3>
<h4 id="暴露与疾病的关联性分析">暴露与疾病的关联性分析</h4>
<p>看书 p70</p>
<h4 id="关联强度分析">关联强度分析</h4>
<p>看书 p71</p>
<h4 id="or可信区间分析">OR可信区间分析</h4>
<p>看书 p71</p>
<h3 id="病例对照研究的偏倚及其控制">病例对照研究的偏倚及其控制</h3>
<ul>
<li>选择偏倚
<ul>
<li>入院率偏倚</li>
<li>现患病例-新发病例偏倚</li>
<li>检出症候偏倚</li>
</ul></li>
<li>信息偏倚
<ul>
<li>回忆偏倚</li>
<li>调查偏倚</li>
</ul></li>
<li>混杂偏倚</li>
</ul>
<h3 id="病例对照研究的优点与局限性">病例对照研究的优点与局限性</h3>
<ul>
<li>优点
<ul>
<li>适用于罕见的、潜伏期长的疾病研究，有时往往是罕见病病因研究的唯一选择。 也适于研究一些新出现的或原因不明的疾病，能广泛地探索其影响因素，可为公共卫生干预策略与方案的制定提供重要依据。</li>
<li>与队列研究相比，病例对照研究需要的样本量较小，因此，相对更节省人力、物力、经费和时间，并且较易于组织实施。</li>
<li>适用于多种暴露因素与某一种疾病关联的研究，也可进行多种因素间交互作用的研究。</li>
<li>不仅应用于病因的探讨，也可用于疾病预后、临床疗效、药物不良反应、疫苗免疫学效果的评价及影响因素的研究，也可在疾病暴发调查中为寻找病因提供线索。</li>
</ul></li>
<li>局限性
<ul>
<li>不适用于研究人群中暴露比例很低的因素，因需要的样本量较大，从而影响研究的可行性。</li>
<li>易发生各种偏倚，包括选择偏倚、信息偏倚混杂偏倚，尤其是难以避免回忆偏倚、选择偏倚，故而影响到病例对照研究结果的真实性。</li>
<li>难以确定暴露与疾病的时间先后顺序，无法直接推论因果关联。</li>
<li>不能直接计算暴露组和非暴露组的发病率，只能估计相对危险度，因此，难以充分而直接地分析研究因素与疾病之间的关系。</li>
</ul></li>
</ul>
<h2 id="实验流行病学研究">实验流行病学研究</h2>
<p>实验流行病学(experimental epidemiology )研究：又称干预试验(interventional trial)，是指研究者根据研究目的，按照预先确定的研究方案将研究对象随机分配到试验组和对照组，对试验组人为地施加或减少某种因素，然后追踪观察该因素的作用结果，比较和分析两组或多组人群的结局，从而判断干预措施的效果。</p>
<ul>
<li><p>实验流行病学研究的基本原理：</p>
<figure>
<img src="../images/实验流行病学研究原理示意图.png" alt="实验流行病学研究原理示意图" /><figcaption aria-hidden="true">实验流行病学研究原理示意图</figcaption>
</figure></li>
</ul>
<h3 id="实验流行病学研究的特点">实验流行病学研究的特点</h3>
<ul>
<li>属于前瞻性研究</li>
<li>随机分组</li>
<li>具有均衡可比的对照组</li>
<li>有人为施加的干预措施</li>
</ul>
<h3 id="实验流行病学研究的类型">实验流行病学研究的类型</h3>
<ul>
<li>临床试验</li>
<li>现场试验</li>
<li>社区干预试验</li>
</ul>
<h3 id="临床试验">临床试验</h3>
<p>临床试验(clinical trial)：以已确诊患有某病的病人作为研究对象，以临床治疗措施(药物或治疗方案)为研究内容，通过观察和比较试验组和对照组的临床疗效和安全性，从而对临床各种治疗措施的效果进行科学评价。</p>
<p>在临床试验时，首先从具有临床症状的大量病人中选出合适的研究对象，然后将研究对象分为二组：一组为试验组， 给予某种干预措施(新药或新疗法)，另一组为对照组，给予安慰剂或传统疗法。然后观察两组的治疗效果及转归，比较两组的治愈率好转率、病死率等指标，从而评价临床治疗措施的效果。</p>
<p>临床试验主要用途包括：①新药临床试验。新药在取得新药证书前必须经过临床试验，确定安全有效后，才能被批准进行批量生产，进人市场广泛应用。②临床上不同药物或治疗方案的效果评价。通过临床试验选择有效的药物或治疗方案，提高病人的治愈率，降低致残率和病死率，延长病人的寿命及提高病人的生存质量。</p>
<h4 id="临床试验的基本原则">临床试验的基本原则</h4>
<ul>
<li>对照原则</li>
<li>随机化原则</li>
<li>盲法原则</li>
<li>重复原则</li>
</ul>
<h4 id="临床试验的研究设计与实施">临床试验的研究设计与实施</h4>
<h5 id="设立严格的对照">设立严格的对照</h5>
<ul>
<li>标准对照(standard control)或称阳性对照(positive control)：临床上最常用的一种对照方法，也称有效对照或积极对照。此种对照设立的方法是以现行最有效或临床上最常用的药物或治疗方法作为对照，用以判断新药或新疗法是否优于该常用药物或疗法。</li>
<li>安慰剂对照(placebo control)或称阴性对照(negative control)：药物常具有特异和非特异效应，为了排除非特异效应的干扰，常用安慰剂作对照。安慰剂常用没有任何药理作用的淀粉、乳糖、生理盐水等制成。使用安慰剂对照时要注意两点：第一，要求安慰剂的剂型和外观尽量与试验药物相同，而且对人体无害，以利于盲法试验；第二，要掌握安慰剂的使用指征，此种对照由于病人未得到治疗，故应限于研究那些目前尚无有效药物治疗方法的疾病，或在使用安慰剂期间，对病情和预后基本没有影响，否则不应使用安慰剂对照。</li>
<li>交叉对照(crossover control)：一种特殊的随机对照，即按随机方法将研究对象分为甲、乙两组。甲组先用试验药,乙组先用对照药。一个疗程结束后,间隔一段时间以消除治疗药物的滞留影响，然后甲组再用对照药，乙组再用试验药，最后分析和比较疗效。这样既能自身前后对比，又可分析用药顺序对疗效的影响。两次治疗的间隔时间因疾病的症状或药物残留作用的时间长短而应有所不同。此种对照一般在研究药物应用先后顺序对治疗结果的影响，以及研究药物最佳配伍时应用。</li>
<li>互相对照(mutual control)：如果同时研究几种药物或治疗方法时,可以不设专门的对照，分析结果时，各组之间互为对照，从中选出疗效最好的药物或疗法。</li>
<li>自身对照(self control)：在同一研究对象中应用试验和对照的方法,如比较用药前后体内某些指标的变化情况，或研究皮肤科用药时使用左右肢体作试验和对照，分析何种药物疗效更好。</li>
</ul>
<h5 id="随机分组">随机分组</h5>
<p>随机化：指所有的对象均按照预先设定的概率被分配到试验组或对照组中，而不受研究者或受试者主观愿望或客观原因的影响。随机化是为了使对照组与试验组具有可比性，以提高研究结果的正确性，减少偏倚。</p>
<ul>
<li>简单随机化(simple randomization)：最常用的方法是利用随机数字表或随机排列表，也可用抽签或抛硬币等方法。</li>
<li>区组随机化(block randomization)：当研究对象人数较少，而影响实验结果的因素又较多时，可以采用区组随机化法进行分组。其基本方法是将特征(如年龄、性别、病情等)相近的一组受试对象作为一个区组，再将每个区组内的研究对象进行随机化分组。该法的优点是在分组过程中，可尽量保持试验组与对照组病例数一致，并可根据实验要求设计不同的区组。</li>
<li>分层随机化(stratified randomization)：按主要临床特点或预后因素将研究对象分为1-3层，再运用随机化方法将每层内的研究对象分到试验组和对照组。通过分层随机化，使得两组的临床特征比较相近,增加组间可比性,结论更可靠。</li>
</ul>
<h5 id="应用盲法">应用盲法</h5>
<ul>
<li>单盲(single blind)：指研究对象不知道自己的分组和所接受处理情况，但观察者和资料收集分析者知道。单盲方法简便，容易进行，且观察者知道受试者分组的情况，对受试者的健康和安全有利。</li>
<li>双盲(double blind)：研究对象和观察者都不知道分组情况，也不知道研究对象接受的处理措施，称为双盲。病人与医生只知道研究对象的序号，待试验结束和资料分析后才宣布分组情况。</li>
<li>三盲(triple blind)：研究对象、观察者和资料整理分析者均不知道研究对象的分组和处理情况，只有研究的组织者知道，直到试验结束时才公布分组和处理情况。</li>
<li>在实际应用中通常用双盲随机对照试验。</li>
</ul>
<h4 id="临床试验的资料分析">临床试验的资料分析</h4>
<p>相对危险度降低(relative risk reduction， RRR) <span class="math display">\[
RRR=\frac{对照组事件发生率-实验组事件发生率}{对照组事件发生率}
\]</span> 绝对危险度降低(absolute risk reduction， ARR) <span class="math display">\[
ARR=对照组事件发生率-实验组事件发生率
\]</span> 需治疗人数(number needed to treat， NNT) <span class="math display">\[
NNT=\frac{1}{ARR}
\]</span> 在评价治疗或预防疾病措施效果的实验研究中，NNT表示在特定时间内，为防止1例某种不良结局或获得1例某种有利结局，需要用某种干预方法处理的人数，NNT值越小越好。例如，有一项关于加强胰岛素治疗减少视网膜病变恶化的随机对照临床试验，ARR为25% ，那么，NNT=1/ARR=1/25%=4，即用加强胰岛素治疗每4例病人，可防止1例发生视网膜病变恶化。如NNT为负数，表示在特定时间内，用某种干预引起1例某种不良事件所需要的人数(number needed to harm， NNH)，NNH用于评价干预造成的有害效应，NNH的绝对值越大越好。</p>
<h4 id="临床试验的偏倚及其控制">临床试验的偏倚及其控制</h4>
<ul>
<li>失访(loss of follow up)：研究对象因迁移或其他疾病死亡等而造成失访，从而破坏了原有样本的代表性。</li>
<li>干扰(co-intervention)：试验组额外接受了与实验效应一致的其他处理措施，从而造成人为夸大疗效的假象。</li>
<li>沾染(contamination)：对照组病人额外地接受了试验组药物，造成人为夸大对照组疗效，从而低估效应的现象。</li>
</ul>
<h3 id="现场试验和社区干预试验">现场试验和社区干预试验</h3>
<p>现场试验和社区试验均是以社区人群作为研究对象、在现场环境下进行的干预研究，但前者接受干预措施的基本单位是个人，后者接受干预措施的基本单位是整个社区，或某一人群的各个亚人群。也有人把两者统称为“现场试验”。</p>
<p>这两种方法常用于对某种预防措施或方法的效果进行评价。</p>
<p>与临床试验不同，现场试验的研究对象是一般社区人群，需到社区“现场”(工作场所、家庭、部队、学校等)开展研究。</p>
<h4 id="现场试验和社区干预试验的评价指标">现场试验和社区干预试验的评价指标</h4>
<p>保护率(protection rate， PR) <span class="math display">\[
保护率=\frac{对照组发病(或死亡)率-实验组发病(或死亡)率}{对照组发病(或死亡)率}\times100\%
\]</span> 效果指数(index of effectiveness) <span class="math display">\[
效果指数=\frac{对照组发病率}{实验组发病率}
\]</span></p>
<h3 id="实验流行病学研究的优点与局限性">实验流行病学研究的优点与局限性</h3>
<ul>
<li>优点
<ul>
<li>采用随机化分组将研究对象随机分为试验组和对照组，两组间除干预措施外，其他基本特征相似，具有较高的可比性，减少了混杂偏倚。</li>
<li>实验流行病学研究为前瞻性研究，在整个试验过程中，通过随访将每个研究对象的反应和结局自始至终观察到底，试验组和对照组同步进行比较，最终作出肯定性的结论，因而检验假设的能力比队列研究强。</li>
<li>有助于了解疾病的自然史，并且可以获得一种干预与多种结局的关系。</li>
</ul></li>
<li>局限性
<ul>
<li>整个实验设计和实施条件要求高控制严难度较大，在实际工作中有时难以做到。</li>
<li>受干预措施适用范围的约束，所选择的研究对象代表性不够，以致会不同程度的影响实验结果推论到总体。</li>
<li>有时需要随访较长的时间，因此依从性不易做得很好，影响实验效应的评价。</li>
<li>由于长期的随访，因为死亡、退出搬迁等造成的失访难以避免，从而影响研究的真实性。</li>
<li>有时对照组不使用药物或其他疗法，只使用安慰剂；或者受试药物的疗效不如传统药物或存在副作用，就会存在伦理学问题。</li>
</ul></li>
</ul>
<h2 id="筛检与诊断试验">筛检与诊断试验</h2>
<p><strong>筛检(screening)：运用快速、简便的检验、检查或其他措施在健康人群中将那些可能有病或有缺陷但表面健康的人同那些真正无病或无缺陷的人区别开来。</strong></p>
<p>筛检提出的背景是如能尽早地使用一种或几种检测方法检测出疾病在临床前期出现的一些可识别的异常特征，如肿瘤早期标志物，血脂、血糖、血压升高等，并在此基础上，对异常或可疑异常的人进一步进行临床诊断、治疗，就可以在疾病早期延缓或阻止疾病的进展。筛检所用的各种手段和方法称为筛检试验(screening test)，包括常规体格检查、问卷调查物理学检查、实验室检验和分子标志物检测等。</p>
<p><strong>诊断(diagnosis)：指医务人员通过详尽的检查及调查等方法收集信息，经过整理加工后对病人的病情进行基本认识和判断，诊断是把病人与可疑有病但实际无病者区别开来。</strong></p>
<p>用于诊断的各种检查方法称为诊断试验(diagnostic test)。它不仅包括各种实验室检查，也包括病史、体检所获得的临床资料、超声诊断等公认的诊断方法。诊断时利用这些资料和技术标准对患病和未患病作出确切的结论。</p>
<p>筛检与诊断的区别</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>筛检试验</th>
<th>诊断试验</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>目的不同</td>
<td>区别无症状的早期病人或病人与健康人</td>
<td>区别无症状的早期病人或病人与健康人</td>
</tr>
<tr class="even">
<td>对象不同</td>
<td>健康或表面健康的人</td>
<td>病人或可疑病人</td>
</tr>
<tr class="odd">
<td>要求不同</td>
<td>快速、简便、灵敏度高</td>
<td>复杂、准确、特异性高</td>
</tr>
<tr class="even">
<td>费用不同</td>
<td>一般应使用简便 、价廉的方法</td>
<td>一般在医院内进行，花费较高</td>
</tr>
<tr class="odd">
<td>结果处理不同</td>
<td>阳性者须作进一步的诊断或干预</td>
<td>阳性者要给予治疗</td>
</tr>
</tbody>
</table>
<h3 id="筛检与诊断试验确定界值的原则">筛检与诊断试验确定界值的原则</h3>
<p>诊断试验及其指标确定之后，还应该确定诊断试验的标准，也就是诊断的界值，用以区别正常和异常。如果诊断标准不一致，根据其所计算的发病率、患病率等则不一样，不同标准间的结果不能直接比较。另一方面，对于某一诊断试验而言，理想的灵敏度和特异度均为100%，这时正常者与异常者的测定值的分布完全没有重叠。</p>
<p>但是实际应用中很少有这种理想的情况。常常是病人与正常人的参数范围相互交叉重叠。</p>
<p>如果患病人群的指标高于正常人，将诊断标准定在病人分布的最低点， 高于此点为病人，该标准不会漏掉病人，但将会把一部分非病人划人病人组中。</p>
<p>如果将诊断标准分界定在正常人分布的最高点，虽没有将非病人误诊为病人，但又有可能将结果低于该值的一部分病人漏诊</p>
<p>将分界定在二者之间的某个数值，则既有一小部分病人被漏诊，又有一小部分非病人被误诊。</p>
<p>在确定诊断标准时，应该考虑到诊断为假阴性(漏诊)或假阳性(误诊)时，鉴别诊断试验的繁简程度，以及漏诊或误诊-一个可能的病例其后果的严重性。</p>
<p>在确定诊断试验的标准时，一般要遵循以下原则：</p>
<ul>
<li>对于预后差，漏诊可能后果严重，但有可以利用的有效治疗方法，而且早期诊断可以获得较好的治疗效果，病人从伦理和经济的角度可以接受，应将诊断的阳性标准定在高灵敏度的水平，尽可能地把所有的病人都诊断出来。但此时会使误诊增多，导致需要进一步确诊的可疑病例增多，从而增加检查成本。这类疾病如结核病、梅毒和霍奇金淋巴瘤等。</li>
<li>对于治疗效果不理想的疾病，或疾病预后不严重但误诊-一个非病人为病人时后果严重，对病人的心理、生理和经济上造成严重的影响，应将诊断的阳性标准定在高特异度的水平，尽量排除非病人。如艾滋病等。</li>
<li>当假阳性和假阴性的重要性相等时，-.般可以把诊断标准定在病人与非病人分布的交界处，或定在正确诊断指数最大处。</li>
</ul>
<h3 id="筛检与诊断试验的评价">筛检与诊断试验的评价</h3>
<p>评价某一种诊断试验的效果，须将该诊断试验的结果与已有公认的“金标准”检测的结果相比较。要对参加的受试对象同时应用“金标准”和该诊断试验进行检测。值得注意的是在对进行诊断试验评价时，要求判断待评价诊断试验结果的人，在不知道“金标准"诊断结果的情况下独立判断试验结果，避免过高或过低估计诊断试验与“金标准”的符合程度，避免观察者偏倚。</p>
<table>
<thead>
<tr class="header">
<th>诊断试验</th>
<th>患某病</th>
<th>未患某病</th>
<th>合计</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>阳性</td>
<td>真阳性 a</td>
<td>假阳性 b</td>
<td>a+b</td>
</tr>
<tr class="even">
<td>阴性</td>
<td>假阴性 c</td>
<td>真阴性 d</td>
<td>c+d</td>
</tr>
<tr class="odd">
<td>合计</td>
<td>a+c</td>
<td>b+d</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>对于诊断试验的评价，除了考虑方法本身的安全和操作上的简单、快速、方便及价格低廉等因素外，还要考虑试验的真实性、可靠性及收益三个方面。</p>
<h4 id="真实性的评价">真实性的评价</h4>
<p>同一诊断试验的灵敏度和特异度分别说明发现病人和排除非病人的能力。似然比(likelihood ratio，LR)和约登指数(Youden index)是将二者结合起来的指标。</p>
<h5 id="灵敏度">灵敏度</h5>
<p>灵敏度(sensitivity，Se)：也称敏感度、真阳性率，是指评价诊断试验发现病人的能力。即实际有病且被该诊断试验正确地判为有病的概率。 <span class="math display">\[
灵敏度(Se)=\frac{a}{a+c}\times100\%
\]</span> 灵敏度只与“金标准”判断为阳性组有关，理想的诊断试验的灵敏度为100%。</p>
<p>假阴性率(false negative rate， FNR)：也称为漏诊率或第二类错误，即实际有病但依据该诊断试验被确定为非病人的概率。 <span class="math display">\[
假阴性率(FNR)=\frac{c}{a+c}\times100\%
\]</span></p>
<h5 id="特异度">特异度</h5>
<p>特异度(specificity，Sp)：也称为真阴性率，是诊断试排除没有病的人的能力。即实际无病，按该诊断试验被正确地判为无病的概率。 <span class="math display">\[
特异度(Sp)=\frac{d}{b+d}\times100\%
\]</span> 特异度只与金标准判断为阴性的对照组有关，理想的诊断试验特异度为100%。</p>
<p>假阳性率(false positive rate ， FPR)：也称为误诊率或第一类错误，即实际无病但该诊断试验判定为有病的概率。 <span class="math display">\[
假阳性率(FPR)=\frac{b}{b+d}\times100\%
\]</span></p>
<h5 id="似然比">似然比</h5>
<p>似然比为“金标准”阳性组中出现某种检测结果(阳性或阴性)的概率与金标准阴性组中出现相应结果的概率之比，说明金标准阳性组中出现该结果的机会是阴性组的多少倍。由于检测结果通常分为阳性和阴性，因此似然比也相应地分为阳性似然比(positive likelihood ratio，LR+)与阴性似然比(negative likelihood ratio， LR-)两种。</p>
<p>阳性似然比为真阳性率与假阳性率的比值。说明“金标准”阳性组中该诊断试验出现阳性结果的机会是“金标准”阴性组中诊断试验出现阳性结果的机会的多少倍。该比值越大，说明该诊断试验的诊断价值越高。其计算公式为： <span class="math display">\[
LR_+=真阳性率/假阳性率=\frac{a}{a+c}/\frac{b}{b+d}=\frac{Se}{1-Sp}
\]</span> 阴性似然比为假阴性率与真阴性率的比值。说明“金标准”阳性组该诊断试验出现阴性结果的机会是“金标准”阴性组的多少倍，该比值越小，说明该诊断试验的诊断价值越高。其计算公式为： <span class="math display">\[
LR_-=假阴性率/真阴性率=\frac{c}{a+c}/\frac{d}{b+d}=\frac{1-Se}{Sp}
\]</span> 在选择诊断试验时应该选择阳性似然比较高、阴性似然比较低的方法。</p>
<h5 id="约登指数">约登指数</h5>
<p>约登指数(Youden index ， YI)：也称正确诊断指数，为灵敏度与特异度之和减1。 <span class="math display">\[
约登指数(YI)=(灵敏度+特异度)-1=1-(假阳性率+假阴性率)
\]</span> 该指数表示诊断试验能正确判断病人和非病人的能力。范围在0~1之间，可用于两个或多个诊断试验的比较。理想的约登指数为1。</p>
<h5 id="灵敏度与特异度的关系">灵敏度与特异度的关系</h5>
<p>就同一个诊断试验而言，区分诊断试验正常和异常的临界点会影响灵敏度和特异度提高灵敏度，特异度将会降低；反之，提高特异度，灵敏度将会降低。</p>
<h4 id="收益">收益</h4>
<h5 id="预测值">预测值</h5>
<p>灵敏度、特异度等准确性指标是诊断试验本身的特征，是临床医生等是否采纳该诊断试验的重要决策的依据。一旦采纳该诊断试验后，针对某一诊断试验结果，临床医生面临的工作就是判断有这种结果的人患病可能性的大小。</p>
<p><strong>预测值：应用诊断试验结果来估计受检者患病与否及其可能性大小的指标。</strong></p>
<p>由于诊断试验的结果分为阳性和阴性，因此预测值分为阳性预测值和阴性预测值。由于预测值反映的是持有这种诊断结果的受试者患病与否的可能性(概率)，因此又称为验后概率或后验概率。</p>
<p><strong>阳性预测值(positive predictive value，PPV)：是诊断试验结果为阳性的对象中真正是病人(金标准阳性)的概率。</strong>对于一项诊断试验来说，阳性预测值越大越好。</p>
<p><strong>阴性预测值(negative predictive value ， NPV)：是诊断试验为阴性结果中真正无病(金标准阴性)的概率。</strong>该值也是越大越好。</p>
<h3 id="提高筛检与诊断试验效率的方法">提高筛检与诊断试验效率的方法</h3>
<ul>
<li>选择患病率高的人群</li>
<li>采用联合试验
<ul>
<li>并联试验(parallel test)：也叫平行试验 ，即同时应用多个诊断试验进行诊断，只要有任何一项试验结果为阳性就可定为阳性，只有全部试验结果均为阴性才将最终结果判断为阴性。该法可以提高灵敏度，降低特异度。在临床急需作出诊断时，可采取并联试验，不易漏诊，阴性预测值提高。但其代价是特异度降低，假阳性率升高，容易造成误诊。</li>
<li>串联试验(serial test)：也叫系列试验，即依次应用多项诊断试验进行诊断，全部试验结果均为阳性，才将最终结果判断为阳性，任何一项试验结果为阴性就可定为最终结果阴性。该方法可以提高特异度，降低灵敏度。当目前使用的几种诊断方法的特异度均较低时，可选用串联试验，减少误诊。其代价是灵敏度降低，漏诊率增加。另外，某些诊断试验本身价格昂贵或有一定的危险性，为确诊某病又不得不做，这时可以选择几种虽特异度不高但简单安全的方法进行试验，提示有可能有某种病时，再进一步做价格昂贵的试验。</li>
</ul></li>
</ul>
<h2 id="传染流行病学">传染流行病学</h2>
<p>感染谱(spectrum of infection)：指宿主机体对病原体传染过程反应轻重程度的频率。</p>
<h3 id="流行过程">流行过程</h3>
<p>流行过程(epidemic process)：指传染病在人群中发生、蔓延的过程,即病原体从感染者体内排出，经过一定的传播途径,侵人易感者机体而形成新的感染，并不断发生、发展的过程。流行过程是群体现象，受自然和社会因素制约。传染源、传播途径和易感人群构成了流行过程的3个基本条件，即流行过程的3个基本环节。只有这3个环节同时存在并相互联系才能形成传染病的流行过程。</p>
<h4 id="流行过程的基本环节">流行过程的基本环节</h4>
<p>传染源(reservoir of infection)：指体内有病原体生长、繁殖，并能排出病原体的人和动物，包括病人、病原携带者和受感染动物。</p>
<p>潜伏期(incubation period)：病原体侵人机体至最早出现临床症状的这段时间。不同的传染病潜伏期长短不一，短至数小时，长至数月，甚至数年。即使是同一种传染病，其潜伏期也不尽相同，但大多数局限于一定范围。潜伏期长短受病原体侵入的途径数量、毒力、繁殖能力及机体状态等诸多因素影响。</p>
<p>潜伏期的流行病学意义及用途</p>
<ul>
<li>根据潜伏期可判断病人受感染的时间，以追踪传染源，寻找传播途径。</li>
<li>确定接触者的留验、检疫或医学观察期限，一般以平均潜伏期增加1至2天为准，危害严重的传染病可按最长潜伏期予以留验。</li>
<li>确定免疫接种时间。</li>
<li>评价预防措施效果。</li>
<li>潜伏期长短可影响疾病的流行特征。一般潜伏期短的传染病，常呈现暴发，而潜伏期长的传染病流行持续时间可能较长。</li>
</ul>
<p>传播途径(route of transmission)：指病原体更换宿主时在外环境中所经历的途径，即病原体由传染源排出，侵入另一易感宿主所经过的途径。传播媒介或传播因素是指病原体停留和转移所依附的各种媒介物。</p>
<ul>
<li>经空气传播，经空气传播的传染病的流行特征为
<ul>
<li>传播广泛，发病率高</li>
<li>冬春季节高发</li>
<li>儿童和老年人多见</li>
<li>在未经免疫预防的人群中，发病可呈现周期性升高</li>
<li>居住拥挤和人口密度大的地区高发</li>
</ul></li>
<li>经水传播，经水传播的传染病的流行特征为
<ul>
<li>病人有接触疫水史，发病有职业差异，主要是接触疫水的职业</li>
<li>呈现地方性或季节性特点，多见于水网地区、雨季和收获季节</li>
<li>大量易感人群进人流行区，可呈暴发或流行</li>
<li>对疫水采取措施或加强个人防护可控制疾病发生</li>
</ul></li>
<li>经食物传播，经食物传播的传染病的流行特征为
<ul>
<li>病人有进食同一食物史，不食者不发病</li>
<li>一次大量污染可致暴发</li>
<li>病人一般潜伏期较短，临床症状较重</li>
<li>当停供污染食物后，暴发即可很快平息</li>
</ul></li>
<li>经接触传播</li>
<li>经土壤传播</li>
<li>医源性传播</li>
<li>垂直传播：病原体在人与人之间相互传播统称为水平传播(horizontal transmission)，而病原体由母体传给子代的传播则称为垂直传播(vertical transmission)或母婴传播
<ul>
<li>经胎盘传播：指受感染的孕妇经胎盘血液将病原体传给胎儿。</li>
<li>上行性传播：指病原体从孕妇阴道经子宫颈口到达绒毛膜或胎盘引起胎儿感染。</li>
<li>分娩时传播：指分娩过程中胎儿在通过严重感染的孕妇产道时所致的感染。</li>
</ul></li>
</ul>
<p>人群易感性(herd susceptibility)：指人群作为一个整体对传染病的易感程度。人群易感性的高低取决于总人口中易感人口所占的比例，也与人群的一般健康状况有关。人群易感性高低与传染病的流行有密切关系。当免疫人口增加时，可大大降低传染病的发病率。这是因为具有免疫力的人除了免于发病外，还对易感者起到屏障和保护作用。当人群中免疫人口达到足够比例时，传染病的流行即可终止。</p>
<h4 id="流行过程的疫源地">流行过程的疫源地</h4>
<p>疫源地(epidemic focus)：指传染源及其排出的病原体向周围所能波及的范围，即可能发生新病例或新感染的区域。疫源地是构成传染病流行过程的<strong>基本单位</strong>和必要环节。</p>
<p>疫源地消灭的条件：只有同时具备以下3个条件时，针对疫源地的防疫措施方可结束。</p>
<ul>
<li>传染源被移走(如隔离、死亡)或不再排出病原体(治愈)。</li>
<li>传染源散播在外环境中的病原体被彻底消灭。</li>
<li>所有易感接触者经过该病最长潜伏期未出现新病例或被证明未受到感染。</li>
</ul>
<h4 id="流行过程的影响因素">流行过程的影响因素</h4>
<ul>
<li>自然因素
<ul>
<li>地理、气候、土壤、动植物等</li>
</ul></li>
<li>社会因素
<ul>
<li>生产环境和生产方式</li>
<li>生活条件和生活方式</li>
<li>社会动荡和社会制度</li>
<li>人口增加和人口流动</li>
<li>医疗卫生条件</li>
</ul></li>
</ul>
<h3 id="传染病的控制">传染病的控制</h3>
<h4 id="经常性的预防措施">经常性的预防措施</h4>
<p>预防接种(vaccination)：将抗原或抗体注人人体 ，使人体产生对某种传染病的特异性免疫力，从而保护易感人群，预防传染病的发生。它是预防、控制和消灭传染病的重要措施。</p>
<p>预防接种类型</p>
<ul>
<li>人工主动免疫(artificial active immunization)：是指将免疫原物质接种人体,使人体产生特异性免疫。</li>
<li>人工被动免疫(artificial passive immunization)：是指将含有抗体的血清或其制剂接种人体，使人体立即获得抗体而受到保护。</li>
<li>被动主动免疫(passive and active immunization)：是指将含有抗体的血清或其制剂接种人体的同时，将免疫原物质亦接种人体，使人体迅速获得特异性抗体的同时，产生持久的免疫力。</li>
</ul>
<h4 id="针对传染源的措施">针对传染源的措施</h4>
<p>对接触者的措施：指曾接触传染源而有可能受感染者均应接受检疫。检疫期限从最后接触之日起至相当于该病的最长潜伏期。</p>
<ul>
<li>留验：即隔离观察。对甲类传染病的接触者应进行留验。将他们收留在指定场所进行观察，限制活动范围,实施诊察检验和治疗。</li>
<li>医学观察：对乙类和丙类传染病接触者应施行医学观察，即在正常工作学习的情况下,接受体检、病原学检查和必要的卫生处理。</li>
<li>应急接种：对潜伏期较长的传染病,如脊髓灰质炎、麻疹、白喉等，可对接触者施行预防接种。应急接种时间越早效果越好。一般在潜伏期早期或感染后3天内接种麻疹疫苗能防止发病。</li>
<li>药物预防：某些有特效预防药物的传染病，必要时可采用药物预防。如用青霉素或磺胺药物预防猩红热；乙胺嘧啶或氯喹预防疟疾等。药物预防多用于密切接触者或特殊职业人群,要防止滥用药物预防，以免造成病原体耐药。</li>
</ul>
<h4 id="针对传播途径的措施">针对传播途径的措施</h4>
<p>消毒(disinfection)：用化学、物理、生物的方法杀灭或消除环境中致病性微生物的一种措施。一般分为预防性消毒和疫源地消毒。</p>
<ul>
<li>预防性消毒(preventive disinfection)：针对可能受病原体污染的场所和物品所施行消毒。如空气消毒、饮水消毒和乳品消毒等。</li>
<li>疫源地消毒(disinfection of epidemic focus)：对现有或曾有传染源存在的场所进行的消毒，其目的是消灭传染源排出的病原体。
<ul>
<li>随时消毒：指在有传染源存在的疫源地，对其排泄物及分泌物或被污染的物品、场所及时进行消毒。</li>
<li>终末消毒：指传染源痊愈、死亡或离开后对疫源地进行的一次彻底消毒，其目的是完全清除传染源播散在环境中的病原体。只有对外环境抵抗力较强的病原体才需要进行终末消毒，如鼠疫、霍乱、炭疽、伤寒、副伤寒、痢疾、病毒性肝炎、脊髓灰质炎结核、白喉、猩红热等。对外环境抵抗力较弱的病原体，如麻疹、水痘流行性感冒等，一般不需终末消毒。</li>
</ul></li>
</ul>
<h2 id="循证医学">循证医学</h2>
<p>循证医学是一门新兴学科，它的内涵和外延在不断地丰富和完善。</p>
<p>1996年，加拿大著名的临床流行病学家David Sackett和牛津大学卫生科学研究院院长Muri Gray爵士通过《英国医学杂志》对循证医学进行了定义：“循证医学是有意识地、明确地、审慎地利用现有最好的证据制定关于个体病人的诊治方案。实施循证医学意味着医生要综合考虑最好的研究证据、临床经验和病人的意见”。</p>
<p>2000年David Sackett在其主编的第2版《循证医学：如何实践和教学》一书中指出，循证医学是“慎重、准确和明智地应用当前所能获得的最佳的研究证据，同时结合临床医生的个人专业技能和多年临床经验，考虑病人的权利、价值和期望，将三者完美地结合以制定出病人的治疗措施"。</p>
<h3 id="循证医学实践的步骤">循证医学实践的步骤</h3>
<ol type="1">
<li>提出问题：提出一个明确、可回答的临床问题。</li>
<li>收集证据：循证实践强调基于现有的最佳证据。</li>
<li>评价证据：检索到的研究证据在应用于解决具体临床问题前，常需要用临床流行病学和循证医学质量评价的标准对其进行严格评价。</li>
<li>应用证据：经过严格评价文献，如果从中获得的证据是真实可靠并且具有临床应用价值的，应当尽快用以指导临床实践；对于经过评价是无效甚至是有害的措施则应该立即停止；对于尚无定论的措施，则可以为进一步的研究提供信息。</li>
<li>后效评价：依据现有最好的证据制定的临床决策实施后，是否达到了预期效果应当进行评价，从中总结出经验和教训，并据此提出改进建议，重新提出问题，进人新一轮循证过程。正是通过这样不断的循证医学实践和不断地评价总结，才能达到逐步提高学术水平和医疗质量，推动医学实践不断发展的目的。</li>
</ol>
<h3 id="meta分析">meta分析</h3>
<p>meta分析(meta analysis)是对研究设计相同或相似且具有相同目的，但又相互独立的多个研究结果(证据)进行系统的综合定量分析，计算其合并效应量，并做出结果解释的分析。通过对多个同类独立研究的汇总和合并分析，达到增大样本量、提高检验效能提高效应量估计精度的目的，特别当多个研究结果不一致或无统计学意义时，meta分析可以得到更接近真实情况的统计结果。分析时需要根据研究类型与评价内容选择恰当的效应量，并根据异质性检验结果选择采用固定效应模型或随机效应模型，结果常用森林图表示（看书 p174）。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-01-14T16:00:00.000Z" itemprop="datePublished">2022/01/15</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8C%BB%E5%AD%A6/" rel="tag">医学</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-数据建模"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/">数据建模</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="数据模型">1. 数据模型</h2>
<h3 id="数据">1.1. 数据</h3>
<p>数据：现实世界的记录，是原始素材。</p>
<h3 id="数据的表达">1.2. 数据的表达</h3>
<p>数据通常被认为是一系列外部环境的事实的表达。</p>
<p>数据是计算机能够处理的对象。</p>
<p>数据泛指对客观对象的数量、属性、位置及其相互关系的抽象表示，以适合于用人工（如计算机）的方式进行保存、传递和处理。</p>
<p>数据要通过人们约定俗成的字符和定义表现出来。</p>
<p>数据具有一个使用范围，不同领域的人在描述同一事物是会出现不同的数据。</p>
<h3 id="数据模型-1">1.3. 数据模型</h3>
<p>数据模型：一组由符号、文本组成的集合，用以准确表达信息景观，达到有效交流沟通的目的。</p>
<p><strong>数据模型的构成：数据类型、相互作用、连接媒介</strong></p>
<p>模型的分类：</p>
<ul>
<li>概念模型：建立模型是为了以文档形式记录较抽象的想法。（业务需求）</li>
<li>逻辑模型：模型的建立纯粹是为了以文档形式记录元素的规律和结构。（业务解决方案）</li>
<li>物理模型：数据模型为设计数据库，是编写代码建立表、视图、完整性约束的基础。（详细的技术解决方案）</li>
</ul>
<p>模型数据的生命周期：数据元素确定、计划阶段、数据收集、数据储存、数据综合、决策应用、数据归档、数据丢弃（删除）</p>
<h3 id="基本概念">1.4. 基本概念</h3>
<h4 id="实体">1.4.1. 实体</h4>
<p>实体表示对于业务非常重要或值得获取的事物及与之相关的信息集合。</p>
<p>实体表达了一个集合，而实例就是集合中的一个元素。实例是一个具体实体的呈现或者说是具体的值。</p>
<p>通常采用“6W”方法（Who、What、When、Where、Why、Way）归纳所有的实体。</p>
<p>实体的三个层面：</p>
<ul>
<li>概念：通常是建模对象中所定义的术语。是对基本的、关键的业务概念描述（通常受制于建模对象的范围）。</li>
<li>逻辑：比概念展示更多的细节，即详细的解决方案。一个概念实体可以表示成多个逻辑数据模型实体。例如：属性。</li>
<li>物理：展现实体包含的技术细节，即详细的技术解决方案。例如：在关系型数据库（RDBMS）中的数据库表或视图。</li>
</ul>
<p>强实体是指独立存在的人、事物或地点。 弱实体是指依赖于其他实体而存在，它的实例依赖于引用其他实例。</p>
<h4 id="属性">1.4.2. 属性</h4>
<p>属性是实体实例所具有的一组各自独立的描述信息。</p>
<p>属性根据细节展示程度分为三个层面：</p>
<ul>
<li>概念层要求是对建模对象的业务有基本且关键的特性的概念性的描述。</li>
<li>逻辑层用来描述业务特征，与业务解决方案密切相关，与软、硬件技术无关。</li>
<li>物理层可以形象地概括为一个“物理容器”来储存数据。</li>
</ul>
<h5 id="属性的域">1.4.2.1. 属性的域</h5>
<p>域是一个属性所有取值构成的集合。域有验证标准，满足多个属性的使用。</p>
<p>域的类型：</p>
<ul>
<li>格式域：将数据指定为数据库系统中的标准类型。</li>
<li>列表域：优先元素构成的集合，格式域的精简。</li>
<li>范围域：设置最大和最小值。</li>
</ul>
<p>域的好处：</p>
<ul>
<li>插入数据前，通过域检查来提高数据质量。</li>
<li>交流性更强。</li>
<li>提高维护和新建模型的效率。</li>
</ul>
<h4 id="关系">1.4.3. 关系</h4>
<p>关系是数据模型中的规则（特定情形下的行为的规定和指示），用来说明实体间的规则或导航路径，通常用连接线段表示。</p>
<p>关系的类型：</p>
<ul>
<li>数据规则：指示数据间的关联内容。
<ul>
<li>结构完整型（SI）：参与某个关系的实体实例的数量。</li>
<li>参照完整型（RI）：定义了参与某个关系的实体实例取值的有效性。</li>
</ul></li>
<li>行为规则：指示属性包含某个特定值时，需要采取什么操作。</li>
</ul>
<p>关系的三个层面：</p>
<ul>
<li>概念关系：高级别的规则或被关联的一些关键概念间的导航路径。</li>
<li>逻辑关系：定义细节的业务规则或逻辑实体间的导航关系。</li>
<li>物理关系：具体的、依赖于实现技术的规则或被关联的物理结构间的导航关系。</li>
</ul>
<h5 id="关系的基数">1.4.3.1. 关系的基数</h5>
<p>基数表示一个实体中多少实例与另一个实体的实例发生关联。通常在关系域两端用符号来表示，指定了一种可以被实施的数据规则。</p>
<h5 id="关系的递归">1.4.3.2. 关系的递归</h5>
<p>递归关系指同一实体内实例间的规则。</p>
<p>递归关系包含：</p>
<ul>
<li>一对多的层次结构：一个实体实例最多只能有一个父关系。</li>
<li>多对多的网状结构：一个实体实例可以有多个父关系。</li>
</ul>
<p>递归关系的特点：</p>
<ul>
<li>优点：递归关系将复杂业务简单化（模糊）描述，增加建模的灵活性。</li>
<li>缺点：递归关系会过于简单化，掩盖其背后的业务规则。</li>
<li>建模者需要权衡规则模糊与灵活性，分析案例不能简单照搬。</li>
</ul>
<h5 id="关系的子类型">1.4.3.3. 关系的子类型</h5>
<p>子类型可以将类似的属性或相似且关联的实体关系进行分组。通常用于相似实例、相似概念展示。</p>
<h4 id="键">1.4.4. 键</h4>
<p>键由一个或多个属性构成。</p>
<p>键的目的：实施规则、有效数据检索、实体间导航。</p>
<p>键的分类：</p>
<ul>
<li>候选键：一个或多个可以唯一标识实体实例的属性。具有4个基本特征：
<ul>
<li>唯一性：不能标识多于一个实体实例。</li>
<li>强制性：不能为空，每个实体实例要求必须能被一个特定的候选键值所标识。</li>
<li>非易变性：取值不能被更改。</li>
<li>最小化：多个属性的最小组合。</li>
</ul></li>
<li>主键：从候选键中选择，能以最好的方式标识实体实例。选择主键应考虑简洁性和隐私保护。</li>
<li>备选建：候选键中除了主键以外的键。</li>
<li>代理键：数据表的唯一标识符，不具备任何业务意义，通常由一个固定大小、无人工干预的计数器产生，而且与业务对比不可见。作用是提高了搜索、系统集成的效率。</li>
<li>辅助键：经常被访问或者需要被快速检索到的一个或多个属性。又称为非唯一索引或倒排入口（Inversion Entry, IE）。特征是不要求唯一或稳定，也可以不要求必须拥有值。</li>
</ul>
<h2 id="数据建模">2. 数据建模</h2>
<p>数据建模：构建数据模型的过程。</p>
<p>数据建模的目的：</p>
<ul>
<li>为满足使用数据创建新定义的信息提供条件，尽可能以最基本、最不可分割、最基础的可复用组件的方法来收集和储存数据。</li>
<li>通常需要组合这些基本的数据元素，设计合适的储存和处理工具来成功地完成这项任务。</li>
</ul>
<p>数据建模的基本要素：</p>
<ul>
<li>发现这些数据元素。</li>
<li>确定目前它们之间的关联方式。</li>
<li>未来可以识别和使用这些数据。</li>
</ul>
<p><strong>数据建模的价值：核心价值：交流性（开发者）和精确性（应用者）</strong></p>
<p>数据建模任务：</p>
<ul>
<li>常规记录与分析：具有明确的规律和次序，需要反复执行。
<ul>
<li>维护不同种类数据文档，包括：企业级概念数据文档、项目逻辑数据文档、物理数据对象文档等。</li>
<li>提议ICT标准，包括提议标准化项目文档，参与代码、过程和文件的检查。</li>
<li>调查现有技术和工具，包括记录业务流程和范围、记录用户需求、将业务流程映射成数据对象等。</li>
</ul></li>
<li>改进与创新：适应未来环境的变化和企业的愿景提出的设计、建议或改进。
<ul>
<li>设计新的数据结构，创建新的企业概念或逻辑数据视图、设计新的数据库结构等。</li>
<li>将组织或公司新计划整合到公司数据环境中并消除冗余，确定自建或购买等。</li>
<li>提供数据库设计的完整性、质量和风险的预估。</li>
</ul></li>
</ul>
<p>数据建模流程：问题描述、数据准备、数据探索、预测建模、结果可视化。</p>
<p>两种不同建模方式：</p>
<ul>
<li>关系数据建模通过准确的业务规则描述业务如何运作的过程。</li>
<li>维度数据建模通过准确的导航来描述业务如何被监控的过程。</li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th><strong>关系</strong></th>
<th><strong>维度</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>概念</strong></td>
<td>数据规则。</td>
<td>导航。</td>
<td>所有概念、业务规则、应用范围。</td>
</tr>
<tr class="even">
<td><strong>逻辑</strong></td>
<td>基于业务规则的详细业务解决方案。</td>
<td>基于导航的详细业务解决方案。</td>
<td>所有属性和业务规则。</td>
</tr>
<tr class="odd">
<td><strong>物理</strong></td>
<td>详细的技术解决方案。</td>
<td>详细的技术解决方案。</td>
<td>详细的技术解决方案。</td>
</tr>
</tbody>
</table>
<h3 id="关系数据建模">2.1. 关系数据建模</h3>
<h4 id="概念数据建模">2.1.1. 概念数据建模</h4>
<p>概念数据模型由一组符号和文本构成，用来为特定的用户，针对特定的业务需求或应用程序范围，描述关键概念以及概念间的相互规则。即：描述了预设范围内的业务需求，展示了特定领域下的关键概念，以及概念间的相互作用。</p>
<ul>
<li>关系概念模型：包括概念、概念定义以及表示业务规则的概念间的相互规则。</li>
<li>维度概念模型：包括概念、概念定义以及在不同层级分析量度时所用的导航路径。</li>
</ul>
<p>概念数据模型的创建步骤（5步）：</p>
<ol type="1">
<li>提出5个策略性的问题。
<ul>
<li>应用程序（或系统）将要做什么（本质确定应用范围）？</li>
<li>“现在”还是“将要”？</li>
<li>是否必须进行统计分析？</li>
<li>谁是用户（识别用户，用于确定概念模型的形式）？</li>
<li>灵活性还是简洁性？</li>
</ul></li>
<li>概念的识别与定义。
<ul>
<li>对于关系概念模型，采用6W方法确立概念模板，以表格形式列出模型中的实体。</li>
<li>对于维度概念模型，首先要明确哪些特定的业务问题必须被回答。</li>
</ul></li>
<li>创建关系。清晰、完整定义概念，并确定概念之间的关系。
<ul>
<li>对于关系概念模型，要明确实体间的相互关联。清晰掌握所有的规则。实体间每一条关系线，需要通过问题表确定参与性、可选性与子类型关系。</li>
<li>对于维度概念模型，要对上一步汇总的问题进行处理并创建一个粒度矩阵。粒度矩阵是一个二维表，列由根据业务问题而形成的量度构成，行由根据业务问题而形成的维度级别构成。</li>
</ul></li>
<li>确定一个最有效的形式。通常采用三种形式来展示模型：
<ul>
<li>使用传统的数据模型符号。</li>
<li>使用业务草图。</li>
<li>使用轴技术符号。</li>
</ul></li>
<li>检查数据模型，提出修改或重新定义一些概念。审阅上述结果并向逻辑数据建模阶段提交适当的内容。</li>
</ol>
<h4 id="逻辑数据建模">2.1.2. 逻辑数据建模</h4>
<p>逻辑数据模型是在应用概念数据模型定义的业务需求的基础上，形成的下一级的业务解决方案。该业务方案用逻辑数据模型来表达。即逻辑数据模型是为了解决特定业务需求而形成的业务解决方案。</p>
<p>前提：经过概念数据模型的构建，已经形成一个宽泛的要解决问题的业务范围和用户需求。</p>
<p>目的：实现用户需求的解决，即用逻辑数据模型来生成一套具体的解决方案。</p>
<ul>
<li>关系逻辑模型：通过准确的业务规则表达来描述业务运转过程。包含实体及实体间的关系和属性。</li>
<li>维度逻辑模型：通过准确的导航表达来描述业务是如何被监控的过程。</li>
</ul>
<h5 id="规范化">2.1.2.1. 规范化</h5>
<p>规范化：应用一组规则对事物进行整理的过程。</p>
<ul>
<li>确保每个属性都是单值的，即一个属性只能包含一则信息。</li>
<li>提供一个完全的、唯一的依赖于主键事实。</li>
</ul>
<p>规范化方法：</p>
<ul>
<li>第一范式：一个关系模式R的所有属性的域都是原子的（每个属性必须是单值）。</li>
<li>第二范式：关系模式R中的所有非主属性都完全函数依赖于所有候选码。</li>
<li>第三范式：关系模式R中的非主属性既不部分依赖也不传递函数依赖于R上的所有候选码。</li>
</ul>
<h5 id="抽象">2.1.2.2. 抽象</h5>
<p>抽象是一项可选技术。即通过重定义和将一些实体、属性、关系在模型范围内结合成更通用的条目，为数据模型注入灵活性。</p>
<p>抽象的不足：</p>
<ul>
<li>降低了交流性。抽象后模型所表达的内容不再明确，即抽象后经常会将实体变成实体实例。</li>
<li>损失业务规则。抽象前可以使数据模型实施业务规则，而抽象后则需程序代码等其他方式来确保规则。</li>
<li>增大开发难度。如对程序员来说直接对抽象前的实体加载数据要简单很多，而且程序代码更加精简。</li>
</ul>
<h4 id="物理数据建模">2.1.3. 物理数据建模</h4>
<p>物理数据模型是使用由逻辑数据模型定义的业务解决方案，构建下一层次的技术解决方案。即一旦解决了与硬件、软件无关的问题，接下来应该根据具体的硬件、软件环境对模型进行必要的调整。</p>
<p>前提：经过逻辑数据模型的构建，已经形成一个具体的业务解决方案。</p>
<p>目的：实现方案应用，即用物理数据模型来进行具体的技术解决方案设计。</p>
<ul>
<li>关系物理模型：通过准确的业务规则表达来描述业务运转过程。包含实体及实体定义、关系和各列及相应定义。</li>
<li>维度物理模型：通过准确的导航表达来描述业务是如何被监控的过程。</li>
</ul>
<h5 id="反规范化">2.1.3.1. 反规范化</h5>
<p>反规范化：选择性地违反规范化规则并在模型（数据库）中重新引入冗余的过程。好处是额外的冗余有助于降低数据检索时间，有助于创建一个用户友好的模型。</p>
<p>好处：</p>
<ul>
<li>额外的冗余有助于降低数据检索时间。</li>
<li>有助于创建一个用户友好的模型。</li>
</ul>
<p>注意：逻辑模型和物理模型的区别就在于逻辑模型建立一个标准的清晰的解决方案而物理模型是为了更好的技术实现构建技术解决方案，这也是反规范化技术的目的。反规范化这一术语只能排他的应用于关系物理模型，因为在规范化之前是不可能进行反规范化的。</p>
<p>Rolldown：关系中父实体将消失，父实体所有列和关系将被下移至子实体。使用该技术的两种情形：</p>
<ul>
<li>当需要保持规范化模型的灵活性时。</li>
<li>当需要降低开发时间和复杂性时。</li>
</ul>
<p>Rollup：一列或多列的组合可能在同一个实体内被重复两次或多次。使用该技术的两种情形：</p>
<ul>
<li>当保留父实体而替代子实体显得更有意义时。即当父实体的使用频率要明显高于子实体时，或者父实体中保存有某些规则或特殊列时，此时保留父实体显得更有意义。</li>
<li>当实体实例数目永远不会超过列数之和。</li>
</ul>
<p>在维度模型中通过flattening（平铺）和collapsing（扁平化）来反规范化。</p>
<h5 id="视图">2.1.3.2. 视图</h5>
<p>视图：一种虚拟表，由SQL查询定义的作用于真正储存数据的表（或其他视图）之上的“视窗”或窗口视图。视图一经定义，就可以和基本表一样被查询、删除，也可以在一个视图上再定义新的视图，但对视图的更新（增、删、改）操作则有一定的限制。</p>
<p>视图的作用：</p>
<ul>
<li>简化了操作，把经常使用的数据定义为视图。</li>
<li>安全性，用户只能查询和修改能看到的数据。</li>
<li>逻辑上的独立性，屏蔽了真实表的结构带来的影响。</li>
</ul>
<p>视图的缺点：</p>
<ul>
<li>性能差。数据库必须把视图查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，数据库要把它变成一个复杂的结合体，需要花费一定的时间。</li>
<li>修改限制。当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。</li>
</ul>
<h5 id="索引">2.1.3.3. 索引</h5>
<p>索引：一个值，是指向表中该值实例的指针。主键和备用键可以转化为唯一索引，而倒排入口（辅助键）可以转化为非唯一索引。</p>
<p>优点：</p>
<ul>
<li>创建唯一性索引，保证数据库表中每一行数据的唯一性。</li>
<li>大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>加速表和表之间的连接，特别是在实现数据的参照完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中使用隐藏优化器，提高系统的性能。</li>
</ul>
<p>缺点：</p>
<ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。</li>
</ul>
<h5 id="分区">2.1.3.4. 分区</h5>
<p>分区：将一个表划分为两个或多个表。</p>
<p>分区的两种形式：</p>
<ul>
<li>水平分区是对表的行进行分区，所有在表中定义的列在每个数据集中都能找到，所以表的特性依然得以保持。</li>
<li>垂直分区是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。</li>
</ul>
<h3 id="维度数据建模">2.2. 维度数据建模</h3>
<p>在维度建模中，将度量称为“事实”，将环境描述为“维度”，维度是用于分析事实所需要的多样环境。</p>
<h4 id="维度模型的基本组成">2.2.1. 维度模型的基本组成</h4>
<ul>
<li>维（维层次路径、维层次、维实例、维层次属性）</li>
<li>事实（度量）</li>
<li>数据立方体</li>
</ul>
<h5 id="维">2.2.1.1. 维</h5>
<p>对数据进行分类的一种结构，以用于从特定的角度观察数据。</p>
<p>维的层次：特定角度的不同细节程度。</p>
<p>维的属性：维度所包含的表示维度的列。</p>
<p>维的主要用途：</p>
<ul>
<li>选择针对期望详细程度的层次的数据。</li>
<li>分组对细节数据综合（聚集）到相应的详细程度的数据层次。</li>
</ul>
<p>维的组织方式：维层次路径（代表不同详细程度的维层次组成）。</p>
<p>维的层级：维度属性组内属性之间的两级或多级结构。高一级的属性构成的维度完全包含低一级的一个或多个属性构成的维度。</p>
<h5 id="事实度量">2.2.1.2. 事实（度量）</h5>
<p>度量：数据的实际意义，一般是一个数值度量指标。如销售量、销售额等。</p>
<p>事实：存储一个多维数据。</p>
<ul>
<li>表达期望分析的主题（目的、感兴趣的事情、事件或指标等）。</li>
<li>具有一定的粒度(同一维度下，数据统计的粗细程度)，粒度的大小与维层次相关。</li>
<li>一个事实中通常包含一个或多个度量。</li>
</ul>
<h5 id="立方体">2.2.1.3. 立方体</h5>
<p>按照一定维层次结构和度量（事实）的逻辑上的组织。其逻辑上相当于一个多维数组。</p>
<h4 id="维度模型的二维表达">2.2.2. 维度模型的二维表达</h4>
<p>维度模型是一种非规范化的关系模型（即有关系建模又有维度建模）。通常由一组属性构成的表组成，表与表之间的关系通过关键字和外键来定义。</p>
<p>两类表来表示多维模型结构：事实表和维度表。</p>
<ul>
<li>事实表仅由键和数据型度量所组成，具有健壮性和完整性的特点。事实表的设计是以能够正确记录历史信息为准则。</li>
<li>维度表不具有健壮性和完整性，有大量的描述性字段。维度表的设计是以能够以合适的角度来聚合主题内容为准则。维度表的属性一般有两个主要用途：查询约束/过滤和标记查询结果集。</li>
</ul>
<h5 id="事实表">2.2.2.1. 事实表</h5>
<p>事实表：用来存储事实的度量及指向各个维的外键值。表示对分析主题的度量。事实表包含了与各维度表相关联的外键，并与维度表关联。事实表的度量通常是数值类型，且记录数会不断增加（可加性），表规模迅速增长。</p>
<p>事实表的特征：</p>
<ul>
<li>非常大</li>
<li>列数较少</li>
<li>经常发生（数据追加）变化</li>
</ul>
<p>事实表的设计中要解决几个重要问题：</p>
<ul>
<li>粒度（记录事实的细节级）：事实表中包含信息的详细程度称为粒度。每个事实表必须只有一种粒度。</li>
<li>相加性：事实的可加性是至关重要的。</li>
<li>文本度量值：度量事实在理论上可以是文本形式的，文本度量可以是某种事物的描述。</li>
<li>键选择：多维数据建模中的键选择是一个难题。它包含性能和易于管理之间的权衡（trade-off）。键选择主要适用于维度。为维度所选择的键必须是事实的外键。</li>
</ul>
<h5 id="维度表">2.2.2.2. 维度表</h5>
<p>维度表：用来存储维的描述信息（元数据），包括层次和类等。维度表对应现实世界中的一个对象或者概念。维度表示对数据进行分析时所用的一个量。</p>
<p>维度表的特征：</p>
<ul>
<li>包含了众多描述性的列</li>
<li>与事实表相比，行数较少</li>
<li>内容相对固定</li>
</ul>
<p>维度表的应用：</p>
<ul>
<li>基于维属性的过滤（切片、切块等）</li>
<li>基于维属性的个中聚集操作（上卷、下钻）</li>
<li>报表中各类标签的主要来源</li>
<li>事实表通过维表进行应用</li>
</ul>
<h4 id="维度建模的模型">2.2.3. 维度建模的模型</h4>
<h5 id="星型模型">2.2.3.1. 星型模型</h5>
<p>星形模型(Star Schema)是最常用的维度建模方式。星形模型是以事实表为中心，所有的维度表直接连接在事实表上，像星星一样。</p>
<p>星形模型的维度建模由一个事实表和一组维度表成，且具有以下特点：</p>
<ul>
<li><p>维度表只和事实表关联，维度表之间没有关联。</p></li>
<li><p>每个维度表主键为单列，且该主键放置在事实表中，作为两边连接的外键。</p></li>
<li><p>以事实表为核心，维度表围绕核心呈星形分布。</p></li>
</ul>
<h5 id="雪花模型">2.2.3.2. 雪花模型</h5>
<p>雪花模型(Snowflake Schema)是对星形模型的扩展。雪花模型的维度表是可以拥有其他维度表的，虽然这种模型相比星形更规范一些，但是由于这种模型不太容易理解，维护成本比较高，而且性能方面需要关联多层维度表，性能也比星形模型要低。所以一般不是很常用。</p>
<h5 id="星座模型">2.2.3.3. 星座模型</h5>
<p>星座模型是星形模型延伸而来，星形模型是基于一张事实表的，而星座模型是基于多张事实表的，而且共享维度信息。</p>
<p>前面介绍的两种维度建模方法都是多维表对应单事实表，但在很多时候维度空间内的事实表不止一个，而一个维表也可能被多个事实表用到。在业务发展后期，绝大部分维度建模都采用的是星座模型。</p>
<h4 id="维度建模的流程">2.2.4. 维度建模的流程</h4>
<p>选取业务处理 -&gt; 定义粒度 -&gt; 选定维度 -&gt; 确定事实</p>
<ol type="1">
<li>根据业务过程的优先级选定业务过程。业务处理过程是机构中进行的一般都由源系统提供支持的自然业务活动。听取用户的意见是选取业务处理过程的效率最高的方式。在选取业务阶段，数据模型设计者需要具有全局和发展的视角，应该理解整体业务流程的基础上，从全局角度选取业务处理。</li>
<li>确定事实表粒度，最好是原子级粒度。粒度定义意味着对各事实表行实际代表的内容给出明确的说明。粒度传递了同事实表度量值相联系的细节所达到的程度方面的信息。它给出了后面这个问题的答案:“如何描述事实表的单个行?”。粒度定义是不容轻视的至关重要的步骤。在定义粒度时应优先考虑为业务处理获取最有原子性的信息而开发维度模型。原子型数据是所收集的最详细的信息，这样的数据不能再做更进一步的细分。通过在最低层面上装配数据，大多原子粒度在具有多个前端的应用场合显示出其价值所在。原子型数据是高度维结构化的。事实度量值越细微并具有原子性，就越能够确切地知道更多的事情，所有那些确切知道的事情都转换为维度。</li>
<li>选择相关的维度。维度所引出的问题是，“业务人员将如何描述从业务处理过程得到的数据?”应该用一组在每个度量上下文中取单一值而代表了所有可能情况的丰富描述，将事实表装扮起来。如果对粒度方面的内容很清楚，那么维度的确定一般是非常容易的。通过维度的选定，可以列出那些使每个维度表丰满起来的离散的文本属性。常见维度的例子包括日期、产品、客户、账户和机构等。</li>
<li>选择适用于业务过程的事实。设计过程的最后一步在于仔细确定哪些事实要在事实表中出现。事实的确定可以通过回答“要对什么内容进行评测”这个问题来进行。业务用户在这些业务处理性能度量值的分析方面具有浓厚的兴趣。设计中所有供选取的信息必须满足在第2步中定义的粒度要求。明显属于不同粒度的事实必须放在单独的事实表中。</li>
</ol>
<p>通常可以从以下三个角度来建立事实表：</p>
<ul>
<li>针对某个特定的行为动作，建立一个以行为活动最小单元为粒度的事实表。最小活动单元的定义，依赖于分析业务需求。如用户的一次网页点击行为、一次网站登录行为，一次电话通话记录。这种事实表，主要用于从多个维度统计，行为的发生情况，主要用于业务分布情况，绩效考核比较等方面的数据分析。</li>
<li>针对某个实体对象在当前时间上的状况。我们通过对这个实体对象在不同阶段存储它的快照，如账户的余额、用户拥有的产品数等，通过这种可以统计实体对象在不同的生命周期中的关键数量指标。</li>
<li>针对业务活动中的重要分析和跟踪对象，统计在整个企业不同业务活动中的发生情况。如会员，可以执行或参与多个特定的行为活动。这种事实表是以上两种事实表的一个总结和归纳。它主要用于针对我们业务中的活动对象进行跟踪和考察。</li>
</ul>
<h4 id="常见维度类型">2.2.5. 常见维度类型</h4>
<p>6种维度类型：固定维度。退化维度。多值维度。不齐整维度。收缩维度。渐变维度。</p>
<ul>
<li>固定维度：又称0型渐变维度。其包含的值不随时间改变。</li>
<li>退化维度：维度的属性都被移至事实表中。最典型的退化维度是原始维度中仅包含单一的数据属性。</li>
<li>多值维度：用来解决属性或字段存在多值的情况。即维度表中的某个属性字段同时有多个值或事实表在某个维度表中有多条对应记录。
<ul>
<li>处理多值维度最好的办法是<strong>降低事实表的粒度</strong>。这种处理方式也是维度建模的一个原则，即事实表应该建立在最细粒度上。这样的处理，需要对事实表的事实进行分摊。但是有些时候，事实表的粒度是不能降低的，多值维度的出现是无法避免的。</li>
<li>可以<strong>采用桥接表技术进行处理</strong>。在多个维度表的值可以赋给单个事实事务时，事实表和维度表之间通常是多对多关系。精确地处理这种情况需要创建一个桥接表。</li>
<li>桥接表有重复计数的风险。要解决这个问题，可以<strong>向桥接表中添加加权因子列</strong>。加权因子是一个分数值，所有组的加权因子累加起来为1。将加权因子和累加事实相乘，按照每个组在分组中的比重分配事实。</li>
</ul></li>
<li>不整齐维度：在一个不整齐维度中，至少有一个成员的父成员在其上级维度中缺失。即不整齐维度允许层级的深度是不确定的。</li>
<li>收缩维度：通常只包含少量非度量性属性。常用于处理大块文本数据。为了节省空间和提高检索效率，大块文本会被存储在独立于数据库的结构中。收缩维度通常用于解决维度表中多对一的关系。属性之间分层的、多对一(M:1)的关系通常未规范化，或者被收缩到扁平型维度表中。要将其规范化或将M:1关系拆分成更小的子维度，维度反向规范化是维度建模中常用的词汇。</li>
<li>渐变维度（SCD）：维度数据会随着时间发生变化，这种维度数据通常称作渐变维。如：电商平台的用户维度表，用户可能会随着时间推移改变收件地址，因此用户维度表中的收件地址就是一个缓慢变化维。SCD 根据变化情况划分为 0-6：
<ul>
<li>SCD 0与固定维度概念一致，其值不随时间变化。</li>
<li>SCD 1意味着仅仅存储当前维度成员值，而忽略数值的历史变化。</li>
<li>SCD 2意味着需要存储所有的历史数据（一种时间机器）。</li>
<li>SCD 3意味着仅仅需要记录一部分历史信息，如当前状态和最近状态或当前状态和原始状态。</li>
<li>SCD 6表示存在复杂维度，该维度历史存在多种变化。</li>
</ul></li>
</ul>
<h3 id="元数据建模">2.3. 元数据建模</h3>
<p>元数据（Meta Data）是关于数据的数据，是用来描述数据的数据。元数据描述数据的结构和意义。元数据具有上下文相关性，也就是说，元数据是相对的。从定义可知，描述数据的数据是元数据，那么元数据本身也是数据，就还存在可以描述元数据的数据，这样不断重复，理论上是无穷尽的。通常把数据和元数据的区别称为类型和实例区别，只要确定了数据就可以得到描述该数据的元数据。</p>
<p>元数据建模是一种应用元数据技术在软件工程和系统工程中用于分析和构建适用于描述问题的、预定义的模型，模型的存在定义并约束了系统中能够存在的元素。</p>
<p>元数据的作用：</p>
<ul>
<li>为数据使用者提供信息。</li>
<li>为数据创建者提供信息。</li>
<li>为数据环境管理者提供信息。</li>
<li>为企业管理人员提供信息。</li>
</ul>
<p>元数据的优点：</p>
<ul>
<li>自描述。即公共语言运行库模块和程序集是自描述的。模块的元数据包含与另一个模块进行交互所需的全部信息。如：元数据自动提供 COM 中 IDL 的功能，允许将一个文件同时用于定义和实现。运行库模块和程序集甚至不需要向操作系统注册。结果，运行库使用的说明始终反映编译文件中的实际代码，从而提高应用程序的可靠性。</li>
<li>设计。元数据提供所有必需的有关已编译代码的信息，以供从用不同语言编写的PE文件中继承类。可以创建用任何托管语言（任何面向公共语言运行库的语言）编写的任何类的实例，而不用担心显式封送处理或使用自定义的互用代码。</li>
</ul>
<p>元数据的获取：元数据可以从学习中获得信息， 也可从经验和试验项目中获得，一般划分两个： 技术和业务。</p>
<ul>
<li><p>技术元数据：用来支持企业数据管理方案的有关应用程序、工具和系统的信息。</p></li>
<li><p>业务元数据：使技术元数据能够被业务界理解和利用。 提供技术方案和业务需求的解释、映射、 路径图和转换。这种类型的元数据是在业务人员的帮助下完成的。 这些元数据帮助我们明白如何接近业务人员以获得丰富的数据资源。</p></li>
</ul>
<p>实时元数据：一旦数据值收集完毕，它们就会与它们所描述的过程断开，这就产生它们实际上与现实不同步的危险。实时元数据不仅可以作为关于数据事实的参考集合，而且作为关键变量嵌入到实际代码和工作中。实时元数据不仅需要采取严格的规范使元数据处于实际处理过程之中，而且需要借助XML、ETL工具中发现数据和操作软件目录。</p>
<ul>
<li><p>XML（Extensible Markup Language）可扩展标记语言，标准通用标记语言的子集。是一种用于标记电子文件使其具有结构性的标记语言。</p></li>
<li><p>ETL（Extraction, Transformation, Load 提取、转换、加载）软件创建映射表并且处理从源端到目的端的数据移动。</p></li>
</ul>
<h4 id="mof规范">2.3.1. MOF规范</h4>
<p>MOF规范以一种统一的方式对模型结构进行描述。MOF规范的4个层次定义了元模型框架，提供一组模型元素以及使用这些元素的规则，为构建面向对象元模型定义了一种公共的抽象语言。</p>
<ul>
<li>M3是元元模型用于定义元模型，提供基础模型快速组装一个元模型包，例如定义元模型须要的领域、类、属性、关系等等；</li>
<li>M2是元模型，是M3的实例，是一种模型的规范，具体来讲就是描述组成模型的元素和元素之间的关系，如关系数据库元模型，从库到表、实例、表、字段、索引之间的关系；</li>
<li>M1是模型，是用于描述数据的数据，例如一本书的目录信息（做者、ISBN、价格等），通常对应到物理表的表字段、API响应的字段等；</li>
<li>M0是基于此模型的对象，也就是物理世界中的数据，通常对应到物理表中的数据。</li>
</ul>
<p>MOF的层次关系：</p>
<ul>
<li>上层模型对下层模型的关系是定义与约束的关系</li>
<li>下层模型对上层模型是继承和包含的子集关系</li>
</ul>
<p>四个层次之间的联系：先后定义的顺序，如植物生长一样，最上面的一定先有。范围的包含关系，下层模型从上层模型衍生出来，所以下层模型的内容范围一定包含上层模型并多于上层模型。M0、M1、M2、M3对象在真实系统中的关系能够总结以下：</p>
<ul>
<li>M1是M0层的抽象，M0表明实际存储的数据，M1表明存储这组数据须要的结构，一般对应到业务系统中就是一组表结构、一组文件等等。</li>
<li>M2是M1层的抽象，M2表明对M1这些表结构、文件等的存储模型，M2层虽然是元模型，但同时M2也是数据，所以元模型也须要统一的存储结构而且具有扩展性。</li>
<li>M3是M2层的抽象，M3表明对M2的抽象，具备通用型，就和设计工具相似，能够设计各式各样的元模型。</li>
</ul>
<h3 id="模型质量评估">2.4. 模型质量评估</h3>
<h4 id="in-the-know模板">2.4.1. IN-THE-KNOW模板</h4>
<p>用来获取对数据需求有所贡献和验证功能的人员及文档。其记录了相关人员的姓名、角色和联系信息，同时罗列了一些重要资源的出处。</p>
<p>构成：</p>
<ul>
<li><p>条目：列举概念名称，此处列举的概念来自数据模型或概念列表（一项技术）。</p></li>
<li><p>资源：该列为信息源。该列可以被扩展而存储为任何有用的信息。其中包括人员、需求、文档、报告等，但在进行描述时应尽量做到具体化。</p></li>
<li><p>类型：为每一个资源指定通用分类。</p></li>
<li><p>角色/如何使用：说明罗列的资源对于项目开发为何是有价值的。</p></li>
<li><p>出处/联系：提供如何查找资源的路径。</p></li>
</ul>
<p>好处：</p>
<ul>
<li>提供方便、完整的参考列表。</li>
<li>可用资源列表便于返校缺失或冗余。模板的使用凸显了任何缺失信息。</li>
<li>充当一份标志文件。</li>
</ul>
<h4 id="概念列表">2.4.2. 概念列表</h4>
<p>用来罗列业务运作过程中，一些非常重要的概念及定义。概念列表罗列了对于业务非常重要的关键概念，而无需使用建模符号。作为建模开发人员，应该在概念列表中精炼各个条目以及它们的定义，确保各概念的时效性和价值性。</p>
<p>构成：</p>
<ul>
<li><p>名称：指每个概念对应的最通用的说明。</p></li>
<li><p>近义词：用来放置与该条目意思相近的各个别名。</p></li>
<li><p>定义：指对每一个条目的简洁描述。</p></li>
<li><p>疑问：包含一些对于精炼概念定义而具有一定价值的询问和评述。</p></li>
</ul>
<p>好处：</p>
<ul>
<li><p>在应用系统范围内获取高层次的概念列表。</p></li>
<li><p>让整个项目团队摆脱困境。</p></li>
<li><p>方便实体及属性的命名和定义。</p></li>
<li><p>在项目团队与业务用户之间建立融洽的关系。</p></li>
</ul>
<h4 id="家族树">2.4.3. 家族树</h4>
<p>一种用来在应用系统范围内，为每个概念或属性获取源应用程或其他关键元数据的电子表格。信息源数量越多，则家族树越有价值。</p>
<p>构成：</p>
<ul>
<li>名称：存放应用系统范围内涉及的所有概念或属性的名称。</li>
<li>信息源：存储的是为每个概念或属性提供数据来源的应用程序的名称。</li>
<li>定义：可以为每个概念或属性给出多重定义。</li>
<li>历史：记录了数据源保存该概念或属性信息的年数。</li>
</ul>
<p>目标：</p>
<ul>
<li>获取每个概念或属性的信息源。</li>
<li>在项目开发之前，进行工作量估算。</li>
<li>对可能存在的信息源问题进行早期诊断。</li>
</ul>
<h4 id="计分卡">2.4.4. 计分卡</h4>
<p>一个客观的评测方法来判断数据模型的优劣。计分卡是一种积极、有效的数据模型质量评价方法。</p>
<p>基本特征：</p>
<ul>
<li>不仅会凸显需要改进的地方，而且还会强调可取之处。</li>
<li>提供一个外部的、客观的视角。</li>
<li>提供简单、直观的审查方法。</li>
<li>支持所有类型的模型。</li>
</ul>
<p>构成：</p>
<ul>
<li>总分：表示该计分项对整个模型的影响程度。</li>
<li>模型得分：特定的模型评审结果。</li>
<li>百分比：存储了模型得分除以对应计分项总分的结果。即百分比=模型得分/总分。</li>
<li>备注：记录关于模型得分的细节，以及修改模型可以采取的行动。</li>
</ul>
<p>好处：</p>
<ul>
<li>在数据建模初期使用计分卡可以有效降低返工几率，即便一些新手也可以对数据模型提出改进意见。</li>
</ul>
<h2 id="数学建模">3. 数学建模</h2>
<p>科学计算：利用计算机来完成科学研究和工程技术中提出的数学问题的计算，是一种使用计算机解释和预测实验中难以验证的、复杂现象的方法。</p>
<p>数学模型：针对参照某种事物系统的特征或数量依存关系，采用数学语言，概括地或近似地表述出的一种数学结构，这种数学结构是借助于数学符号刻划出来的某种系统的纯关系结构。数学模型源于现实生活中的实际问题，但是又高于现实，是现实的提炼、总结。</p>
<p>数学模型的特点：模型的逼真性、可行性、非预制性、渐进性、条理性、强健性、技艺性、可转移性、局限性</p>
<p>数学模型的分类：</p>
<ul>
<li>应用领域：人口、交通、经济、生态</li>
<li>数学方法：初等数学、微分方程、规划、统计</li>
<li>表现特性：确定和随机、静态和动态、离散和连续、线性和非线性</li>
<li>建模目的：描述、优化、预报、决策</li>
<li>了解程度：白箱、灰箱、黑箱</li>
</ul>
<p>数学建模的一般步骤： <img src="../images/数学建模一般步骤.png" alt="数学建模一般步骤" /></p>
<ul>
<li>问题分析：分析实际问题中的各种因素，使用变量表示；分析这些变量之间的关系，哪些是相互依存的，哪些是独立的，他们具有什么样的关系。了解问题的实际背景，明确其实际意义，搜集有关信息，掌握对象的各种特征。</li>
<li>提出假设：根据对象的特征和建模目的，对问题进行必要的、合理的简化，用精确的语言作出假设。要充分发挥想象力、洞察力和判断力，善于辨别主次，而且为了使处理方法简单，应尽量使问题线性化、均匀化。</li>
<li>构成模型：根据所作的假设分析对象的因果关系，利用对象的内在规律和适当的数学工具，构造各个量间的等式关系或其它数学结构。建立数学模型是为了让更多的人明了并能加以应用，因此工具愈简单愈有价值。</li>
<li>模型求解：利用获取的数据资料，对模型的所有参数做出计算（或近似计算)。可以采用解方程、画图形、证明定理、逻辑运算、数值运算等各种传统的和近代的数学方法，特别是计算机技术。</li>
<li>解的分析：对所要建立模型的思路进行阐述，对所得的结果进行数学上的分析。能否对模型结果作出细致精当的分析，决定了你的模型能否达到更高的档次。不论哪种情况都需进行误差分析、数据稳定性分析。</li>
<li>检验与验证：将模型分析结果与实际情形进行比较，以此来验证模型的准确性、合理性和适用性。如果模型与实际较吻合，则要对计算结果给出其实际含义，并进行解释。如果模型与实际吻合较差，则应该修改假设，再次重复建模过程。</li>
<li>应用与推广：应用方式因问题的性质和建模的目的而异，而模型的推广就是在现有模型的基础上对模型有一个更加全面的考虑，建立更符合现实情况的模型。</li>
</ul>
<p>数学建模的意义：</p>
<ul>
<li>“数学是一种关键的、普遍的、可以应用的技术”</li>
<li>“计算和建模重新成为中心课题，它们是数学科学技术转化的主要途径”</li>
</ul>
<h3 id="基础知识">3.1. 基础知识</h3>
<p>数值方法：将要求解的数学模型（数学问题）简化成一系列算术运算和逻辑运算，以便在计算机上求出问题的数值解，并对算法的收敛性和误差进行分析、计算。</p>
<p>算法：不只是单纯的数学公式，也是指由基本的运算和运算顺序的规定所组成的整个解题方案和步骤。</p>
<p>算法评价指标：</p>
<ul>
<li>算法的数值稳定性（分析初始误差的传播、积累对算法计算结果的影响）</li>
<li>计算时间的多少</li>
</ul>
<h4 id="误差">3.1.1. 误差</h4>
<h5 id="过失非过失误差">3.1.1.1. 过失/非过失误差</h5>
<p>在数值计算和数学建模过程中会出现各种误差，可分为“过失误差” 和“非过失误差” 两大类。</p>
<ul>
<li>“过失误差”或“疏忽误差”：在工作中的粗心大意而产生的，如笔误以及误用公式等。它完全是人为造成的，只要工作中仔细、谨慎，可以尽量减少和避免。</li>
<li>“非过失误差”（模型误差、观测误差、截断误差、舍入误差）：在数值计算中这往往是无法避免的，如近似值带来的误差。对于“非过失误差”，应该设法尽量降低其数值，尤其要控制住经多次运算后误差的积累，以确保计算结果的精度。</li>
</ul>
<p>数学模型一旦建立，进入具体计算时所要考虑和分析的就是观测误差、截断误差和舍入误差了。在讨论算法时，有必要对其观测误差的传播、截断误差的估算和舍入误差的控制作适当的分析。</p>
<h5 id="绝对误差">3.1.1.2. 绝对误差</h5>
<p>设某一个准确值（称为真值）为 <span class="math inline">\(x\)</span> ，其近似值为 <span class="math inline">\(x^*\)</span> ，则 <span class="math inline">\(ε(x) = x - x^*\)</span> 称为近似值 <span class="math inline">\(x^*\)</span> 的“绝对误差”，简称“误差”。当 <span class="math inline">\(ε(x) &gt;0\)</span> 时，称为亏近似值或弱近似值，反之，则称为盈近似值或强近似值。 由于真值往往是未知或无法知道的，因此， <span class="math inline">\(ε(x)\)</span> 的准确值也就无法求出。但一般可估计绝对误差的上限，即可以求出一个正值 <span class="math inline">\(η\)</span> ，使 <span class="math inline">\(|ε(x)| = |x - x^*| ≤ η\)</span> 成立。 <span class="math inline">\(η\)</span> 称为近似值的“绝对误差限”，简称“误差限”，或称“精度”。 <span class="math inline">\(η\)</span> 越小，表示该近似值 <span class="math inline">\(x^*\)</span> 的精度越高。</p>
<h5 id="相对误差">3.1.1.2. 相对误差</h5>
<p>用绝对误差还不能完全评价近似值的精确度。这说明要评价一个近似值的精确度，除了要看其绝对误差的大小外，还必须考虑该量本身的大小，这就需要引进相对误差的概念。相对误差不仅能表示出绝对误差，而且在估计近似值运算结果的误差时，它比绝对误差更能反映出误差的特性。因此在误差分析中，相对误差比绝对误差更为重要。</p>
<p>绝对误差与真值之比，即 <span class="math inline">\(ε_r(x) = \frac{ε(x)}{x} = \frac{x - x^*}{x}\)</span> 称为近似值 <span class="math inline">\(x^*\)</span> 的“相对误差”。显然，相对误差与绝对误差的相互关系式为 <span class="math inline">\(ε(x) = x \cdot ε_r(x)\)</span> 。 因为 <span class="math inline">\(ε(x)\)</span> 和 <span class="math inline">\(x\)</span> 均无法准确求得,相对误差也是无法准确求出。但可以估计它的大小范围，即可以找到一个正数 <span class="math inline">\(δ\)</span> ，使 <span class="math inline">\(ε_r(x)≤δ\)</span> 。 <span class="math inline">\(δ\)</span> 称为近似值 <span class="math inline">\(x^*\)</span> 的“相对误差限”。相对误差是个纯数字，它没有量纲。真值 <span class="math inline">\(x\)</span> 总是无法知道的，因此，在实际计算中常用 <span class="math inline">\(ε_r(x) = \frac{ε(x)}{x^*}\)</span> 作为相对误差的近似值。</p>
<h5 id="误差传播">3.1.1.3. 误差传播</h5>
<p>在实际的数值计算中，参与运算的数据往往都是些近似值，带有误差，这些数据误差在多次运算过程中会进行传播，使计算结果产生误差。</p>
<p><strong>加减法的绝对误差传播公式</strong>，等于各近似值绝对误差的代数和。 <span class="math display">\[
ε(x_1 \pm x_2) = ε(x_1) \pm ε(x_2)
\]</span> <strong>加法的相对误差传播公式</strong> <span class="math display">\[
ε_r(x_1 + x_2) = \frac {x_1}{x_1 + x_2}ε_r(x_1) + \frac {x_2}{x_1 + x_2}ε_r(x_2) ≤ max(ε_r(x_1), ε_r(x_2))
\]</span> <strong>减法的相对误差传播公式</strong>，当 <span class="math inline">\(x1^* ≈ x2^*\)</span> ，即两个相近的近似数相减时，其相对误差 <span class="math inline">\(ε_r(x_1 - x_2)\)</span> 可能会很大，计算结果的有效数字将严重丢失，计算精度会很低。故在实际计算中，应尽量设法避免相近的近似数相减。 <span class="math display">\[
ε_r(x_1 - x_2) = \frac {x_1}{x_1 - x_2}ε_r(x_1) - \frac {x_2}{x_1 - x_2}ε_r(x_2)
\]</span> <strong>乘法的误差传播公式</strong>，近似值之积的相对误差等于相乘各因子的相对误差的代数和。当乘数的绝对值很大时，乘积的绝对误差可能会很大，因此应设法避免。 <span class="math display">\[
ε(x_1x_2) = x_2ε(x_1) + x_1^*ε_r(x_2)\\
ε_r(x_1x_2) = ε_r(x_1) + \frac {x_1^*}{x_1}ε_r(x_2) ≈ ε_r(x_1) + ε_r(x_2)
\]</span> <strong>除法的绝对误差传播公式</strong>，可见，当除数<span class="math inline">\(x_2^*\)</span>的绝对值很小，接近于零时，商的绝对误差可能会很大，故应设法避免让绝对值太小的数作为除数。 <span class="math display">\[
ε(\frac {x_1}{x_2}) ≈ \frac {x_1^*}{x_2^*}[ε_r^*(x_1) - ε_r^*(x_2)]
\]</span> <strong>除法的相对误差传播公式</strong>，即两近似值之商的相对误差等于被除数的相对误差与除数的相对误差之差（代数和）。 <span class="math display">\[
ε_r(\frac {x_1}{x_2}) ≈ ε_r^*(x_1) - ε_r^*(x_2)
\]</span> <strong>乘方及开方运算的误差传播公式</strong>，乘方运算将使结果的相对误差增大为原值 <span class="math inline">\(ε_r^*(x)\)</span> 的 <span class="math inline">\(p\)</span> （乘方的方次数）倍，降低了精度;开方运算则使结果的相对误差缩小为原值 <span class="math inline">\(ε_r^*(x)\)</span> 的 $ $ （开方的方次数），精度得到提高。 <span class="math display">\[
ε(x^p) ≈ p(x^*)^{p-1}ε(x)\\
ε_r^*(x^p) ≈ pε_r^*(x)
\]</span> <strong>误差传播估计的一般公式</strong>，从误差的传播公式可知，误差增长因子的绝对值很大时，数据误差在运算中传播后，可能会造成计算结果的很大误差。凡原始数据的微小变化可能引起结果的很大变化的这类问题,称为病态问题或坏条件问题。 <span class="math display">\[
ε(y) = y - y^* = f(x_1, x_2) - f(x_1^*, x_2^*) ≈ (\frac {\partial f}{\partial x_1})^* \cdot ε(x_1) + (\frac {\partial f}{\partial x_2})^* \cdot ε(x2)\\
ε_r(y) ≈ (\frac {\partial f}{\partial x_1})^* \cdot \frac {ε(x_1)}{y^*} + (\frac {\partial f}{\partial x_2})^* \cdot \frac {ε(x2)}{y^*} = (\frac {\partial f}{\partial x_1})^* \cdot \frac {x_1^*}{y^*} \cdot ε_r^*(x_1)+ (\frac {\partial f}{\partial x_2})^* \cdot \frac {x_2^*}{y^*} \cdot ε_r^*(x_2)
\]</span> 综上分析可知，大小相近的同号近似数相减，乘数的绝对值很大，以及除数接近于零等，在数值计算中都应设法避免。</p>
<h4 id="算法的数值稳定性">3.1.2. 算法的数值稳定性</h4>
<p><span class="math inline">\(10^9 + 1 = 0.1 \times 10^{10} + 0.0000000001 \times 10^{10} = 0.1 \times 10^{10} = 10^9\)</span> 受到机器字长的限制，导致绝对值小的数被绝对值大的数“淹没”。这些相对小的数被“淹没”后就无法发挥其应有的影响，由此带来误差，造成计算结果的严重失真。因此，当多个数在计算机中相加时，最好从其中绝对值最小的数到绝对值最大的数依次相加，使和的误差减小。</p>
<p>算法的数值稳定性对于数值计算是非常重要的，算法无足够的稳定性，将会导致计算的最终失败。为了防止误差传播、积累带来的危害，提高计算的稳定性，数值计算中应注意如下几点：</p>
<ul>
<li>选用数值稳定的计算方法，避开不稳定的算式。</li>
<li>注意简化计算步骤及公式，设法减少运算次数，选用运算次数少的算式，尤其是乘方幂次要低，乘法和加法的次数要少，以减少舍入误差的积累，同时也可节约计算机的机时。</li>
<li>应合理安排运算顺序，防止参与运算的数在数量级相差悬殊时，“大数”淹没“小数”的现象发生。多个数相加时，最好从其中绝对值最小的数到绝对值最大的数依次相加；多个数相乘时，最好从其中有效位数最多的数到有效位数最少的数依次相乘。</li>
<li>应避免相近的近似数相减，可用恒等变换的方法来解决。</li>
<li>绝对值太小的数不宜作为除数。否则产生的误差过大，在计算机中造成“溢出”错误。</li>
</ul>
<h3 id="十大算法">3.2. 十大算法</h3>
<h4 id="线性规划">3.2.1. 线性规划</h4>
<p>线性规划问题是在一组线性约束条件的限制下，求一线性目标函数最大或最小的问题。</p>
<p>在企业的各项管理活动中,例如计划、生产、运输、技术等问题，线性规划是指从各种限制条件的组合中，选择出最为合理的计算方法，建立线性规划模型从而求得最佳结果。</p>
<p>目标函数及约束条件</p>
<ul>
<li>均为线性函数，称为线性规划模型。</li>
<li>否则，称为非线性规划模型。</li>
</ul>
<p>决策变量</p>
<ul>
<li><span class="math inline">\(x_j\)</span> 取整数，称为整数规划模型。</li>
<li><span class="math inline">\(x_j\)</span> 部分取整数，称为混合整数规划模型。</li>
<li><span class="math inline">\(x_j\)</span> 只取 0 或 1 两个值，称为 0~1 规划模型。</li>
</ul>
<p>目标函数</p>
<ul>
<li>若目标函数只有一个，称为单目标规划模型。</li>
<li>若目标函数多于一个，称为多目标规划模型。</li>
</ul>
<h4 id="插值与拟合">3.2.2. 插值与拟合</h4>
<p>插值：求过已知有限个数据点的近似函数。即在离散数据的基础上补插连续函数，使得这条连续曲线通过全部给定的离散数据点。插值是离散函数逼近的重要方法，利用它可通过函数在有限个点处的取值状况，估算出函数在其他点处的近似值。</p>
<p>拟合：已知有限个数据点，求近似函数，不要求过已知数据点，只要求在某种意义下它在这些点上的总偏差最小。</p>
<p>拟合与插值的区别</p>
<ul>
<li>插值要过已知有限个数据点。即在离散数据的基础上补插连续函数，使得这条连续曲线通过全部给定的离散数据点。</li>
<li>拟合是求近似函数，不要求过已知数据点，只要求在某种意义下它在这些点上的总偏差最小。拟合曲线整体效果更好。</li>
<li>插值和拟合都是要根据一组数据构造一个函数作为近似，由于近似的要求不同，二者的数学方法上是完全不同的。而面对一个实际问题，究竟应该用插值还是拟合，有时容易确定，有时则并不明显。</li>
</ul>
<p>常见插值方法</p>
<ul>
<li>拉格朗日多项式插值</li>
<li>牛顿插值</li>
<li>分段线性插值</li>
<li>Hermite 插值</li>
<li>三次样条插值</li>
</ul>
<p>常用拟合方法</p>
<ul>
<li>多项式拟合（polyfit函数）</li>
</ul>
<p>判别准则</p>
<ul>
<li>使偏差的绝对值之和最小</li>
<li>使偏差的最大绝对值最小</li>
<li>使偏差的平方和最小（最小二乘法）</li>
</ul>
<h2 id="matlab">4. MATLAB</h2>
<h3 id="数值数据">4.1. 数值数据</h3>
<h4 id="整型">4.1.1. 整型</h4>
<p>无符号8位整数数据范围： <span class="math inline">\(00000000 \sim 11111111 (0 \sim 2^8-1)\)</span> ，即0~255。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">x</span><span class="op">=</span><span class="va">uint8</span>(<span class="fl">129</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="va">x</span><span class="op">=</span><span class="fl">129</span></span></code></pre></div>
<p>带符号8位整数数据范围： <span class="math inline">\(10000000 \sim 01111111(-2^7 \sim 2^7-1)\)</span> ，即-128~127。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">x</span><span class="op">=</span><span class="va">int8</span>(<span class="fl">129</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="va">x</span><span class="op">=</span><span class="fl">127</span></span></code></pre></div>
<h4 id="浮点型">4.1.2. 浮点型</h4>
<p><code>single</code> 函数 ：将其他类型的数据转换为单精度型 。</p>
<p><code>double</code> 函数 ：将其他类型的数据转换为双精度型 。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">class</span>(<span class="fl">4</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="va">double</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">class</span>(<span class="va">single</span>(<span class="fl">4</span>))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="va">single</span></span></code></pre></div>
<h4 id="复数型">4.1.3. 复数型</h4>
<p>复型数据包括实部和虚部两个部分，实部和虚部默认为双精度型，虚数单位用 i 或 j 来表示。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="fl">6</span><span class="op">+</span><span class="fl">5i</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="fl">6.0000</span> <span class="op">+</span> <span class="fl">5.0000i</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="fl">6</span><span class="op">+</span><span class="fl">5j</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="fl">6.0000</span> <span class="op">+</span> <span class="fl">5.0000i</span></span></code></pre></div>
<p><code>real</code> 函数： 求复数的实部</p>
<p><code>imag</code> 函数： 求复数的虚部</p>
<h4 id="数值数据的输出格式">4.1.4 数值数据的输出格式</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">format</span> <span class="va">long</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="fl">50</span><span class="op">/</span><span class="fl">3</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="fl">16.666666666666668</span></span></code></pre></div>
<p><code>format</code> 命令只影响数据输出格式，而不影响数据的计算和存储。</p>
<h3 id="变量">4.2. 变量</h3>
<p>变量名是以字母开头，后接字母、数字或下画线的字符序列，最多 63 个字符。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">x</span><span class="op">=</span><span class="fl">5</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="va">x</span> <span class="op">=</span> <span class="fl">5</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">y</span><span class="op">=</span><span class="fl">6</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="va">y</span> <span class="op">=</span> <span class="fl">6</span></span></code></pre></div>
<p>赋值语句两种格式：</p>
<ul>
<li><p>变量=表达式</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">z</span><span class="op">=</span><span class="va">x</span><span class="op">+</span><span class="va">y</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="va">z</span> <span class="op">=</span> <span class="fl">11</span></span></code></pre></div></li>
<li><p>表达式</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">x</span><span class="op">+</span><span class="va">y</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="fl">11</span></span></code></pre></div></li>
</ul>
<h3 id="矩阵">4.3. 矩阵</h3>
<h4 id="矩阵的建立">4.3.1. 矩阵的建立</h4>
<p>利用直接输入法建立矩阵：将矩阵的元素用中括号括起来，按矩阵行的顺序输入各元素，同一行的各元素之间用逗号或空格分隔，不同行的元素之间用分号分隔。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">3</span><span class="op">;</span><span class="fl">4</span><span class="op">,</span><span class="fl">5</span><span class="op">,</span><span class="fl">6</span><span class="op">;</span><span class="fl">7</span><span class="op">,</span><span class="fl">8</span><span class="op">,</span><span class="fl">9</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fl">1</span>  <span class="fl">2</span>  <span class="fl">3</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="fl">4</span>  <span class="fl">5</span>  <span class="fl">6</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="fl">7</span>  <span class="fl">8</span>  <span class="fl">9</span></span></code></pre></div>
<p>如果给出的行下标或列下标大于原来矩阵的行数和列数，那么 MATLAB 将自动扩展原来的矩阵，并将扩展后没有赋值的矩阵元素置为 0 。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span>(<span class="fl">4</span><span class="op">,</span><span class="fl">5</span>)<span class="op">=</span><span class="fl">10</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="fl">1</span> <span class="fl">2</span> <span class="fl">3</span> <span class="fl">0</span> <span class="fl">0</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="fl">4</span> <span class="fl">5</span> <span class="fl">6</span> <span class="fl">0</span> <span class="fl">0</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="fl">7</span> <span class="fl">8</span> <span class="fl">9</span> <span class="fl">0</span> <span class="fl">0</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">0</span> <span class="fl">10</span></span></code></pre></div>
<h4 id="冒号表达式">4.3.2. 冒号表达式</h4>
<p><code>e1:e2:e3</code>：<code>e1</code>是初始值， <code>e2</code>是步长， <code>e3</code>是终止值。省略步长 <code>e2</code> ，则步长为 1 。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">t</span><span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="va">t</span> <span class="op">=</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">2</span> <span class="fl">3</span> <span class="fl">4</span> <span class="fl">5</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">t</span><span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">5</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="va">t</span> <span class="op">=</span> <span class="fl">0</span> <span class="fl">1</span> <span class="fl">2</span> <span class="fl">3</span> <span class="fl">4</span> <span class="fl">5</span></span></code></pre></div>
<h4 id="矩阵元素的引用">4.3.3. 矩阵元素的引用</h4>
<p>通过下标来引用矩阵的元素。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">3</span><span class="op">;</span><span class="fl">4</span><span class="op">,</span><span class="fl">5</span><span class="op">,</span><span class="fl">6</span>]<span class="op">;</span> <span class="co">%用分号阻止结果直接输出</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span>(<span class="fl">2</span><span class="op">,</span><span class="fl">3</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="fl">6</span></span></code></pre></div>
<h4 id="子矩阵">4.3.4. 子矩阵</h4>
<p>子矩阵是指由矩阵中的一部分元素构成的矩阵。</p>
<table>
<thead>
<tr class="header">
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>A(i,:)</code></td>
<td>第 <code>i</code> 行的全部元素</td>
</tr>
<tr class="even">
<td><code>A(:,j)</code></td>
<td>第 <code>j</code> 列的全部元素</td>
</tr>
<tr class="odd">
<td><code>A(i:i+m, k:k+m)</code></td>
<td>第 <code>i~i+m</code> 行内且在第 <code>k~k+m</code> 列中的所有元素</td>
</tr>
<tr class="even">
<td><code>A(i:i+m,:)</code></td>
<td>第 <code>i~i+m</code> 行的全部元素</td>
</tr>
</tbody>
</table>
<h4 id="特殊矩阵">4.3.5. 特殊矩阵</h4>
<h5 id="零矩阵">4.3.5.1. 零矩阵</h5>
<p><code>zeros</code> 函数：产生全 0 矩阵，即零矩阵。</p>
<ul>
<li><code>zeros(m)</code> ：产生 m × m 零矩阵。</li>
<li><code>zeros(m,n)</code> ：产生 m × n 零矩阵。</li>
<li><code>zeros(size(A))</code> ：产生与矩阵 A 同样大小的零矩阵。</li>
</ul>
<h5 id="幺矩阵">4.3.5.2. 幺矩阵</h5>
<p><code>ones</code> 函数：产生全 1 矩阵，即幺矩阵。</p>
<h5 id="单位矩阵">4.3.5.3. 单位矩阵</h5>
<p><code>eye</code> 函数：产生对角线为 1 的矩阵。当矩阵是方阵时，得到一个单位矩阵。</p>
<p>数量矩阵：对角线上的元素相等的对角矩阵。</p>
<h5 id="随机矩阵">4.3.5.4. 随机矩阵</h5>
<p><code>rand</code> 函数：产生（0，1）区间均匀分布的随机矩阵。</p>
<p><code>randn</code> 函数：产生均值为 0 ，方差为 1 的标准正态分布随机矩阵。</p>
<blockquote>
<p>例：首先产生 5 阶两位随机整数矩阵 A ，再产生均值为 0.6 、方差为 0.1 的 5 阶正态分布随机矩阵 B ，最后验证 <code>(A+B)I=IA+BI</code>（ I 为单位矩阵）。</p>
<p><code>fix</code> 函数：向下取整。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">% 首先产生 5 阶两位随机整数矩阵 A ：</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span><span class="va">fix</span>(<span class="fl">10</span><span class="op">+</span>(<span class="fl">99</span><span class="op">-</span><span class="fl">10</span><span class="op">+</span><span class="fl">1</span>)<span class="op">*</span><span class="va">rand</span>(<span class="fl">5</span>))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="fl">83</span>    <span class="fl">18</span>    <span class="fl">24</span>    <span class="fl">22</span>    <span class="fl">69</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="fl">91</span>    <span class="fl">35</span>    <span class="fl">97</span>    <span class="fl">47</span>    <span class="fl">13</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="fl">21</span>    <span class="fl">59</span>    <span class="fl">96</span>    <span class="fl">92</span>    <span class="fl">86</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="fl">92</span>    <span class="fl">96</span>    <span class="fl">53</span>    <span class="fl">81</span>    <span class="fl">94</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="fl">66</span>    <span class="fl">96</span>    <span class="fl">82</span>    <span class="fl">96</span>    <span class="fl">71</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">% 再产生均值为 0.6 、方差为 0.1 的 5 阶正态分布随机矩阵 B ：</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">B</span><span class="op">=</span><span class="fl">0.6</span><span class="op">+</span><span class="va">sqrt</span>(<span class="fl">0.1</span>)<span class="op">*</span><span class="va">randn</span>(<span class="fl">5</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="va">B</span> <span class="op">=</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.9272</span>    <span class="fl">0.8809</span>    <span class="fl">1.0549</span>    <span class="fl">0.5677</span>    <span class="fl">0.5905</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.8299</span>    <span class="fl">0.2373</span>    <span class="fl">0.7028</span>    <span class="fl">0.5236</span>    <span class="fl">0.5479</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.5040</span>    <span class="fl">0.2620</span>    <span class="fl">0.3613</span>    <span class="fl">0.7009</span>    <span class="fl">0.7985</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.6929</span>    <span class="fl">0.3440</span>    <span class="fl">1.0333</span>    <span class="fl">0.6989</span>    <span class="fl">0.9457</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.3510</span>   <span class="op">-</span><span class="fl">0.3311</span>    <span class="fl">0.0588</span>    <span class="fl">0.3265</span>    <span class="fl">0.9508</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co">% 最后验证 (A+B)I=IA+BI（I为单位矩阵）：</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">C</span><span class="op">=</span><span class="va">eye</span>(<span class="fl">5</span>)<span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> (<span class="va">A</span><span class="op">+</span><span class="va">B</span>)<span class="op">*</span><span class="va">C</span><span class="op">==</span><span class="va">C</span><span class="op">*</span><span class="va">A</span><span class="op">+</span><span class="va">B</span><span class="op">*</span><span class="va">C</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>  <span class="fl">5</span>×<span class="fl">5</span> <span class="va">logical</span> 数组</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span>   <span class="fl">1</span></span></code></pre></div>
</blockquote>
<h5 id="对角矩阵">4.3.5.5 对角矩阵</h5>
<p>只有对角线上有非零元素的矩阵。</p>
<p><code>diag(A)</code> ：提取矩阵 A 主对角线元素，产生一个列向量。</p>
<p><code>diag(A,k)</code> ：提取矩阵 A 第 k 条对角线的元素，产生一个列向量。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="fl">83</span>    <span class="fl">18</span>    <span class="fl">24</span>    <span class="fl">22</span>    <span class="fl">69</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="fl">91</span>    <span class="fl">35</span>    <span class="fl">97</span>    <span class="fl">47</span>    <span class="fl">13</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="fl">21</span>    <span class="fl">59</span>    <span class="fl">96</span>    <span class="fl">92</span>    <span class="fl">86</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="fl">92</span>    <span class="fl">96</span>    <span class="fl">53</span>    <span class="fl">81</span>    <span class="fl">94</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="fl">66</span>    <span class="fl">96</span>    <span class="fl">82</span>    <span class="fl">96</span>    <span class="fl">71</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">diag</span>(<span class="va">A</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="fl">83</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="fl">35</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="fl">96</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="fl">81</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="fl">71</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">diag</span>(<span class="va">A</span><span class="op">,</span><span class="fl">1</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="fl">18</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="fl">97</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="fl">92</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="fl">94</span></span></code></pre></div>
<p><code>diag(V)</code> ：以向量 V 为主对角线元素，产生对角矩阵。</p>
<p><code>diag(V,k)</code> ：以向量 V 为第k条对角线元素，产生对角矩阵。</p>
<pre><code>&gt;&gt;D=diag(1:5)
D =
1   0   0   0   0
0   2   0   0   0
0   0   3   0   0
0   0   0   4   0
0   0   0   0   5
&gt;&gt;D=diag(1:5,1)
D =
0   1   0   0   0   0
0   0   2   0   0   0
0   0   0   3   0   0
0   0   0   0   4   0
0   0   0   0   0   5
0   0   0   0   0   0</code></pre>
<h5 id="三角矩阵">4.3.5.6. 三角矩阵</h5>
<p>上三角矩阵：矩阵的对角线以下的元素全为零的矩阵。</p>
<p><code>triu(A)</code> ：提取矩阵A的主对角线及以上的元素。</p>
<p><code>triu(A,k)</code> ：提取矩阵A的第k条对角线及以上的元素。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="fl">83</span>  <span class="fl">18</span>  <span class="fl">24</span>  <span class="fl">22</span>  <span class="fl">69</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="fl">91</span>  <span class="fl">35</span>  <span class="fl">97</span>  <span class="fl">47</span>  <span class="fl">13</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="fl">21</span>  <span class="fl">59</span>  <span class="fl">96</span>  <span class="fl">92</span>  <span class="fl">86</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="fl">92</span>  <span class="fl">96</span>  <span class="fl">53</span>  <span class="fl">81</span>  <span class="fl">94</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="fl">66</span>  <span class="fl">96</span>  <span class="fl">82</span>  <span class="fl">96</span>  <span class="fl">71</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">triu</span>(<span class="va">A</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="fl">83</span>  <span class="fl">18</span>  <span class="fl">24</span>  <span class="fl">22</span>  <span class="fl">69</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span>  <span class="fl">35</span>  <span class="fl">97</span>  <span class="fl">47</span>  <span class="fl">13</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span>   <span class="fl">0</span>  <span class="fl">96</span>  <span class="fl">92</span>  <span class="fl">86</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span>  <span class="fl">81</span>  <span class="fl">94</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span>  <span class="fl">71</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">triu</span>(<span class="va">A</span><span class="op">,</span><span class="fl">2</span>)</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="fl">0</span>   <span class="fl">0</span>  <span class="fl">24</span>  <span class="fl">22</span>  <span class="fl">69</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span>  <span class="fl">47</span>  <span class="fl">13</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span>  <span class="fl">86</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span>   <span class="fl">0</span></span></code></pre></div>
<p>下三角矩阵：对角线以上的元素全为零的矩阵。</p>
<p>在MATLAB中，提取矩阵A的下三角矩阵的函数是 <code>tril</code> ，其用法与 <code>triu</code> 函数完全相同。</p>
<h4 id="矩阵操作">4.3.6. 矩阵操作</h4>
<h5 id="矩阵的转置">4.3.6.1. 矩阵的转置</h5>
<ul>
<li>转置运算符是小数点后面接单引号 <code>.'</code> 。</li>
<li>共轭转置，其运算符是单引号 <code>'</code> ，它在转置的基础上还要取每个数的复共轭。</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">3</span><span class="op">;</span><span class="fl">3</span><span class="op">+</span><span class="fl">4i</span><span class="op">,</span><span class="fl">1</span><span class="op">-</span><span class="fl">2i</span>] </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span> </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0000</span><span class="op">+</span><span class="fl">0.0000i</span>  <span class="fl">3.0000</span><span class="op">+</span><span class="fl">0.0000i</span> </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="fl">3.0000</span><span class="op">+</span><span class="fl">4.0000i</span>  <span class="fl">1.0000</span><span class="op">-</span><span class="fl">2.0000i</span> </span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span>.’ </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span><span class="op">=</span> </span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0000</span><span class="op">+</span><span class="fl">0.0000i</span>  <span class="fl">3.0000</span><span class="op">+</span><span class="fl">4.0000i</span> </span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="fl">3.0000</span><span class="op">+</span><span class="fl">0.0000i</span>  <span class="fl">1.0000</span><span class="op">-</span><span class="fl">2.0000i</span> </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span>’ </span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span><span class="op">=</span> </span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0000</span><span class="op">+</span><span class="fl">0.0000i</span>  <span class="fl">3.0000</span><span class="op">-</span><span class="fl">4.0000i</span> </span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="fl">3.0000</span><span class="op">+</span><span class="fl">0.0000i</span>  <span class="fl">1.0000</span><span class="op">+</span><span class="fl">2.0000i</span></span></code></pre></div>
<h5 id="矩阵的旋转">4.3.6.2 矩阵的旋转</h5>
<p><code>rot90(A,k)</code> ：将矩阵A逆时针方向旋转90º的k倍，当k为1时可省略。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">;-</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">1</span><span class="op">;</span><span class="fl">4</span><span class="op">,</span><span class="fl">1</span><span class="op">,</span><span class="fl">2</span>] </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span> </span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span> <span class="fl">3</span> <span class="fl">2</span> </span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fl">3</span> <span class="fl">2</span> <span class="fl">1</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">4</span> <span class="fl">1</span> <span class="fl">2</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">rot90</span>(<span class="va">A</span>) </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="fl">2</span>  <span class="fl">1</span>  <span class="fl">2</span> </span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="fl">3</span>  <span class="fl">2</span>  <span class="fl">1</span> </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="fl">1</span> <span class="op">-</span><span class="fl">3</span>  <span class="fl">4</span> </span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">rot90</span>(<span class="va">A</span><span class="op">,</span><span class="fl">2</span>) </span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> </span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="fl">2</span>  <span class="fl">1</span>  <span class="fl">4</span> </span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="fl">1</span>  <span class="fl">2</span> <span class="op">-</span><span class="fl">3</span> </span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="fl">2</span>  <span class="fl">3</span>  <span class="fl">1</span></span></code></pre></div>
<h5 id="矩阵的翻转">4.3.6.3. 矩阵的翻转</h5>
<p><code>fliplr(A)</code> ：对矩阵A实施左右翻转。</p>
<p><code>flipud(A)</code> ：对矩阵A实施上下翻转。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">;-</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">1</span><span class="op">;</span><span class="fl">4</span><span class="op">,</span><span class="fl">1</span><span class="op">,</span><span class="fl">2</span>] </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span> </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span> <span class="fl">3</span> <span class="fl">2</span> </span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fl">3</span> <span class="fl">2</span> <span class="fl">1</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">4</span> <span class="fl">1</span> <span class="fl">2</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;&gt;</span> <span class="va">fliplr</span>(<span class="va">A</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>     <span class="fl">2</span>     <span class="fl">3</span>     <span class="fl">1</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>     <span class="fl">1</span>     <span class="fl">2</span>    <span class="op">-</span><span class="fl">3</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>     <span class="fl">2</span>     <span class="fl">1</span>     <span class="fl">4</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">flipud</span>(<span class="va">A</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>     <span class="fl">4</span>     <span class="fl">1</span>     <span class="fl">2</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">-</span><span class="fl">3</span>     <span class="fl">2</span>     <span class="fl">1</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>     <span class="fl">1</span>     <span class="fl">3</span>     <span class="fl">2</span></span></code></pre></div>
<h5 id="矩阵的逆">4.3.6.4. 矩阵的逆</h5>
<p><code>inv(A)</code> ：求方阵A的逆矩阵。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">;-</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">1</span><span class="op">;</span><span class="fl">4</span><span class="op">,</span><span class="fl">1</span><span class="op">,</span><span class="fl">2</span>] </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span> </span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span> <span class="fl">3</span> <span class="fl">2</span> </span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fl">3</span> <span class="fl">2</span> <span class="fl">1</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">4</span> <span class="fl">1</span> <span class="fl">2</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a> <span class="op">&gt;&gt;</span> <span class="va">inv</span>(<span class="va">A</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.2727</span>   <span class="op">-</span><span class="fl">0.3636</span>   <span class="op">-</span><span class="fl">0.0909</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="fl">0.9091</span>   <span class="op">-</span><span class="fl">0.5455</span>   <span class="op">-</span><span class="fl">0.6364</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>   <span class="op">-</span><span class="fl">1.0000</span>    <span class="fl">1.0000</span>    <span class="fl">1.0000</span></span></code></pre></div>
<h5 id="矩阵方阵的行列式">4.3.6.5. 矩阵（方阵）的行列式</h5>
<p><code>det(A)</code> ：求方阵 A 所对应的行列式的值。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">;-</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">1</span><span class="op">;</span><span class="fl">4</span><span class="op">,</span><span class="fl">1</span><span class="op">,</span><span class="fl">2</span>] </span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span> </span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span> <span class="fl">3</span> <span class="fl">2</span> </span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fl">3</span> <span class="fl">2</span> <span class="fl">1</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">4</span> <span class="fl">1</span> <span class="fl">2</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">det</span> (<span class="va">A</span>)</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="fl">11</span></span></code></pre></div>
<h5 id="矩阵的秩">4.3.6.6. 矩阵的秩</h5>
<p><code>rank(A)</code> ：求矩阵 A 的秩。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">;-</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">1</span><span class="op">;</span><span class="fl">4</span><span class="op">,</span><span class="fl">1</span><span class="op">,</span><span class="fl">2</span>] </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span> </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span> <span class="fl">3</span> <span class="fl">2</span> </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fl">3</span> <span class="fl">2</span> <span class="fl">1</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">4</span> <span class="fl">1</span> <span class="fl">2</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">rank</span>(<span class="va">A</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="fl">3</span></span></code></pre></div>
<h5 id="矩阵的范数">4.3.6.7. 矩阵的范数</h5>
<p><code>norm(A)</code> 或 <code>norm(A,2)</code> ：计算矩阵A 的 2 范数。</p>
<p><code>norm(A,1)</code> ：计算矩阵 A 的 1 范数。</p>
<p><code>norm(A.inf)</code> ：计算矩阵 A 的 ∞ 范数。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">;-</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">1</span><span class="op">;</span><span class="fl">4</span><span class="op">,</span><span class="fl">1</span><span class="op">,</span><span class="fl">2</span>] </span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="va">A</span> <span class="op">=</span> </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a> <span class="fl">1</span> <span class="fl">3</span> <span class="fl">2</span> </span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fl">3</span> <span class="fl">2</span> <span class="fl">1</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a> <span class="fl">4</span> <span class="fl">1</span> <span class="fl">2</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">norm</span>(<span class="va">A</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="fl">5.4775</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">norm</span>(<span class="va">A</span><span class="op">,</span><span class="fl">1</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="fl">8</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">norm</span>(<span class="va">A</span><span class="op">,</span><span class="va">inf</span>)</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="fl">7</span></span></code></pre></div>
<h3 id="基本算术运算">4.4. 基本算术运算</h3>
<p>基本算术运算符：<code>＋</code>、<code>－</code>、 <code>*</code>、 <code>/</code>(右除)、<code>\</code>(左除)、<code>^</code>(乘方)。</p>
<p>注意：</p>
<ul>
<li>MATLAB 的运算是在矩阵意义下进行的。</li>
<li>单个数据的算术运算只是矩阵运算的一种特例。</li>
</ul>
<h4 id="加减运算">4.4.1. 加减运算</h4>
<ul>
<li>若两矩阵同型，则运算时两矩阵的相应元素相加减。</li>
<li>若两矩阵不同型，则 MATLAB 将给出错误信息。</li>
<li>一个标量也可以和矩阵进行加减运算，这时把标量和矩阵的每一个元素进行加减运算。</li>
</ul>
<h4 id="乘法运算">4.4.2. 乘法运算</h4>
<ul>
<li>矩阵 A 和 B 进行乘法运算，要求 A 的列数与 B 的行数相等，此时则称 A 、 B 矩阵是可乘的，或称 A 和 B 两矩阵维数和大小相容。</li>
<li>如果两者的维数或大小不相容，则将给出错误信息，提示用户两个矩阵是不可乘的。</li>
</ul>
<h4 id="除法运算">4.4.3. 除法运算</h4>
<ul>
<li>在MATLAB中，有两种矩阵除法运算：右除 <code>/</code> 和左除 <code>\</code> 。</li>
<li>如果A矩阵是非奇异方阵，则 <code>B/A</code> 等效于 <code>B*inv (A)</code>， <code>A\B</code> 等效于 <code>inv(A)*B</code> 。</li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">3</span><span class="op">;</span><span class="fl">4</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">6</span><span class="op">;</span><span class="fl">7</span><span class="op">,</span><span class="fl">4</span><span class="op">,</span><span class="fl">9</span>]<span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">B</span><span class="op">=</span>[<span class="fl">4</span><span class="op">,</span><span class="fl">3</span><span class="op">,</span><span class="fl">2</span><span class="op">;</span><span class="fl">7</span><span class="op">,</span><span class="fl">5</span><span class="op">,</span><span class="fl">1</span><span class="op">;</span><span class="fl">12</span><span class="op">,</span><span class="fl">7</span><span class="op">,</span><span class="fl">92</span>]<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">C1</span><span class="op">=</span><span class="va">B</span><span class="op">/</span><span class="va">A</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="va">C1</span> <span class="op">=</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fl">0.1667</span> <span class="op">-</span><span class="fl">3.3333</span> <span class="fl">2.5000</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fl">0.8333</span> <span class="op">-</span><span class="fl">7.6667</span> <span class="fl">5.5000</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="fl">12.8333</span> <span class="fl">63.6667</span> <span class="op">-</span><span class="fl">36.5000</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">C2</span><span class="op">=</span><span class="va">A</span><span class="op">\</span><span class="va">B</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="va">C2</span> <span class="op">=</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="fl">0.5000</span> <span class="op">-</span><span class="fl">0.5000</span>  <span class="fl">44.5000</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0000</span>  <span class="fl">0.0000</span>  <span class="fl">46.0000</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="fl">0.5000</span>  <span class="fl">1.1667</span> <span class="op">-</span><span class="fl">44.8333</span></span></code></pre></div>
<h4 id="乘方运算">4.4.4. 乘方运算</h4>
<p>一个矩阵的乘方运算可以表示成<code>A^x</code> ，要求 A 为方阵， x 为标量。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">3</span><span class="op">;</span><span class="fl">4</span><span class="op">,</span><span class="fl">5</span><span class="op">,</span><span class="fl">6</span><span class="op">;</span><span class="fl">7</span><span class="op">,</span><span class="fl">8</span><span class="op">,</span><span class="fl">0</span>]<span class="op">;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">^</span><span class="fl">2</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="fl">30</span> <span class="fl">36</span> <span class="fl">15</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="fl">66</span> <span class="fl">81</span> <span class="fl">42</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="fl">39</span> <span class="fl">54</span> <span class="fl">69</span></span></code></pre></div>
<h4 id="点运算">4.4.5. 点运算</h4>
<p>点运算符： <code>.*</code>、 <code>./</code>、 <code>.\</code>和 <code>.^</code>。两矩阵进行点运算是指它们的对应元素进行相关运算，要求两矩阵同型。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">A</span><span class="op">=</span>[<span class="fl">1</span><span class="op">,</span><span class="fl">2</span><span class="op">,</span><span class="fl">3</span><span class="op">;</span><span class="fl">4</span><span class="op">,</span><span class="fl">5</span><span class="op">,</span><span class="fl">6</span><span class="op">;</span><span class="fl">7</span><span class="op">,</span><span class="fl">8</span><span class="op">,</span><span class="fl">9</span>]<span class="op">;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">B</span><span class="op">=</span>[<span class="op">-</span><span class="fl">1</span><span class="op">,</span><span class="fl">0</span><span class="op">,</span><span class="fl">1</span><span class="op">;</span><span class="fl">1</span><span class="op">,-</span><span class="fl">1</span><span class="op">,</span><span class="fl">0</span><span class="op">;</span><span class="fl">0</span><span class="op">,</span><span class="fl">1</span><span class="op">,</span><span class="fl">1</span>]<span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">C</span><span class="op">=</span><span class="va">A</span><span class="op">.*</span><span class="va">B</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="va">C</span> <span class="op">=</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fl">1</span>  <span class="fl">0</span>  <span class="fl">3</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a> <span class="fl">4</span> <span class="op">-</span><span class="fl">5</span>  <span class="fl">0</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a> <span class="fl">0</span>  <span class="fl">8</span>  <span class="fl">9</span></span></code></pre></div>
<h4 id="关系运算">4.4.6. 关系运算</h4>
<p>关系运算符： <code>&lt;</code> 小于 、 <code>&lt;=</code> 小于或等于 、 <code>&gt;</code> 大于 、 <code>&gt;=</code> 大于或等于 、 <code>==</code> 等于 、 <code>～=</code> 不等于 。</p>
<ul>
<li>当两个比较量是标量时，直接比较两数的大小。若关系成立，关系表达式结果为 1 ，否则为 0 。</li>
<li>当参与比较的量是两个同型的矩阵时，比较是对两矩阵相同位置的元素按标量关系运算规则逐个进行，最终的关系运算的结果是一个与原矩阵同型的矩阵，它的元素由 0 或 1 组成。</li>
<li>当参与比较的一个是标量，而另一个是矩阵时，则把标量与矩阵的每一个元素按标量关系运算规则逐个比较，最终的关系运算的结果是一个与原矩阵同型的矩阵，它的元素由 0 或 1 组成。</li>
</ul>
<h4 id="逻辑运算">4.4.7. 逻辑运算</h4>
<p>逻辑运算符： <code>&amp;</code> (与) 、 <code>|</code> (或)和 <code>～</code> (非)。</p>
<ul>
<li><p>若参与逻辑运算的是两个标量 a 和 b ，那么运算规则为:</p>
<ul>
<li><p><code>a&amp;b</code> a、 b 全为非零时，运算结果为 1 ，否则为 0 。</p></li>
<li><p><code>a|b</code> a、 b 中只要有一个为非零时，运算结果为 1 。</p></li>
<li><p><code>～a</code> 当 a 为零时，运算结果为 1 ；当 a 为非零时，运算结果为 0 。</p></li>
</ul></li>
<li><p>若参与逻辑运算的是两个同型矩阵，那么将对矩阵相同位置上的元素按标量规则逐个进行运算，最终运算结果是一个与原矩阵同型的矩阵，其元素由 1 或 0 组成。</p></li>
<li><p>若参与逻辑运算的一个是标量，一个是矩阵，那么将在标量与矩阵中的每个元素之间按标量规则逐个进行运算，最终运算结果是一个与矩阵同型的矩阵，其元素由 1 或 0 组成。</p></li>
</ul>
<h3 id="字符串">4.5. 字符串</h3>
<p>在MATLAB 中，字符串是用单引号括起来的字符序列。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span><span class="va">xm</span> <span class="op">=</span><span class="ss">&#39;Central South University&#39;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span><span class="va">xm</span>(<span class="fl">1</span><span class="op">:</span><span class="fl">3</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="va">Cen</span></span></code></pre></div>
<p>若字符串中的字符含有单引号，则该单引号字符要用两个单引号来表示。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="er">&#39;I&#39;&#39;m a teacher.’</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="va">I</span><span class="op">&#39;</span><span class="va">m</span> <span class="va">a</span> <span class="va">teacher</span>.</span></code></pre></div>
<p>建立多行字符串，形成字符串矩阵。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span><span class="va">ch</span> <span class="op">=</span>[<span class="ss">&#39;abcdef&#39;</span><span class="op">;</span><span class="ss">&#39;123456&#39;</span>]<span class="op">;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span><span class="va">ch</span>(<span class="fl">2</span><span class="op">,</span><span class="fl">3</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="va">ans</span> <span class="op">=</span> <span class="fl">3</span></span></code></pre></div>
<h3 id="matlab-程序">4.6. MATLAB 程序</h3>
<p>程序是用某种计算机能够理解并且能够执行的语言来描述的解决问题的方法和步骤。</p>
<p>程序设计的基本步骤：</p>
<ul>
<li>分析问题，确定求解问题的数学模型或方法</li>
<li>设计算法，并画出流程图</li>
<li>选择编程工具，根据算法编写程序</li>
<li>调试程序，分析程序输出结果</li>
</ul>
<p>脚本文件：可在命令行窗口直接执行的文件，也叫命令文件。</p>
<p>函数文件：定义一个函数，不能直接执行，而必须以函数调用的方式来调用它。</p>
<p>程序的三种基本结构：</p>
<ul>
<li>顺序结构</li>
<li>选择结构：选择结构又称为分支结构，是根据给定的条件是否成立来决定程序的执行流程。</li>
<li>循环结构：循环结构又称为重复结构，是利用计算机运算速度快以及能进行逻辑控制的特点来重复执行某些操作。</li>
</ul>
<p>函数</p>
<ul>
<li>当输出形参多于一个时，应该用方括号括起来，构成一个输出矩阵。</li>
<li>函数文件名通常由函数名再加上扩展名.m组成，函数文件名与函数名也可以不相同。当函数文件名与函数名不相同时，MATLAB将忽略函数名，调用时使用函数文件名。</li>
<li>return语句表示结束函数的执行。通常，在函数文件中也可以不使用return语句，那么被调用函数执行完成后会自动返回。</li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> 输出形参表<span class="op">=</span>函数名(输入形参表) </span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>函数体语句 <span class="co">%注释说明部分</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co">% 例: 编写函数文件，求多边形周长。</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> [<span class="va">s</span>]<span class="op">=</span><span class="va">N_perimeter</span>(<span class="va">A</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="va">x</span><span class="op">=</span><span class="va">A</span>(<span class="op">:,</span><span class="fl">1</span>)<span class="op">&#39;;</span> <span class="co">%所有顶点的x坐标</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="va">y</span><span class="op">=</span><span class="va">A</span>(<span class="op">:,</span><span class="fl">2</span>)<span class="op">&#39;;</span> <span class="co">%所有顶点的y坐标</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="va">x</span><span class="op">=</span>[<span class="va">x</span><span class="op">,</span><span class="va">x</span>(<span class="fl">1</span>)]<span class="op">;</span> <span class="co">%为了形成闭合多变形，把起始点的坐标加进去</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="va">y</span><span class="op">=</span>[<span class="va">y</span><span class="op">,</span><span class="va">y</span>(<span class="fl">1</span>)]<span class="op">;</span> <span class="co">%同上</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="va">s</span><span class="op">=</span><span class="fl">0</span><span class="op">;</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>[<span class="va">m</span><span class="op">,</span><span class="va">n</span>]<span class="op">=</span><span class="va">size</span>(<span class="va">x</span>)<span class="op">;</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a> <span class="kw">for</span> <span class="va">i</span><span class="op">=</span><span class="fl">1</span><span class="op">:</span><span class="va">n</span><span class="op">-</span><span class="fl">1</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>     <span class="va">a</span><span class="op">=</span><span class="va">sqrt</span>((<span class="va">x</span>(<span class="va">i</span>)<span class="op">-</span><span class="va">x</span>(<span class="va">i</span><span class="op">+</span><span class="fl">1</span>))<span class="op">^</span><span class="fl">2</span><span class="op">+</span>(<span class="va">y</span>(<span class="va">i</span>)<span class="op">-</span><span class="va">y</span>(<span class="va">i</span><span class="op">+</span><span class="fl">1</span>))<span class="op">^</span><span class="fl">2</span>)<span class="op">;</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>     <span class="va">s</span><span class="op">=</span><span class="va">s</span><span class="op">+</span><span class="va">a</span><span class="op">;</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span></code></pre></div>
<p>函数调用</p>
<ul>
<li>如果在一个函数的定义中调用了其他函数这就是函数的嵌套调用。</li>
<li>一个函数调用它自身称为函数的递归调用。</li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>[输出实参表]<span class="op">=</span>函数名(输入实参表)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span>[<span class="va">s</span>]<span class="op">=</span><span class="va">N_perimeter</span>(<span class="va">A</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span><span class="va">N_perimeter</span>(<span class="va">A</span>)</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">% 嵌套</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> [<span class="va">s</span>]<span class="op">=</span><span class="va">N_perimeter</span>(<span class="va">A</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="va">x</span><span class="op">=</span><span class="va">A</span>(<span class="op">:,</span><span class="fl">1</span>)<span class="op">&#39;;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="va">y</span><span class="op">=</span><span class="va">A</span>(<span class="op">:,</span><span class="fl">2</span>)<span class="op">&#39;;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="va">x</span><span class="op">=</span>[<span class="va">x</span><span class="op">,</span><span class="va">x</span>(<span class="fl">1</span>)]<span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="va">y</span><span class="op">=</span>[<span class="va">y</span><span class="op">,</span><span class="va">y</span>(<span class="fl">1</span>)]<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="va">s</span><span class="op">=</span><span class="fl">0</span><span class="op">;</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>[<span class="va">m</span><span class="op">,</span><span class="va">n</span>]<span class="op">=</span><span class="va">size</span>(<span class="va">x</span>)<span class="op">;</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">for</span> <span class="va">i</span><span class="op">=</span><span class="fl">1</span><span class="op">:</span><span class="va">n</span><span class="op">-</span><span class="fl">1</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>     <span class="va">a</span><span class="op">=</span><span class="va">sqrt</span>((<span class="va">x</span>(<span class="va">i</span>)<span class="op">-</span><span class="va">x</span>(<span class="va">i</span><span class="op">+</span><span class="fl">1</span>))<span class="op">^</span><span class="fl">2</span><span class="op">+</span>(<span class="va">y</span>(<span class="va">i</span>)<span class="op">-</span><span class="va">y</span>(<span class="va">i</span><span class="op">+</span><span class="fl">1</span>))<span class="op">^</span><span class="fl">2</span>)<span class="op">;</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>     <span class="va">s</span><span class="op">=</span><span class="va">s</span><span class="op">+</span><span class="va">a</span><span class="op">;</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a> <span class="kw">end</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">% 递归</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="va">f</span><span class="op">=</span><span class="va">fact</span>(<span class="va">n</span>) </span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="va">n</span><span class="op">&lt;=</span><span class="fl">1</span> </span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">f</span><span class="op">=</span><span class="fl">1</span><span class="op">;</span> </span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="kw">else</span> </span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">f</span><span class="op">=</span><span class="va">fact</span>(<span class="va">n</span><span class="op">-</span><span class="fl">1</span>)<span class="op">*</span><span class="va">n</span><span class="op">;</span> </span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>绘图函数</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">% plot 函数二维作图</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">x</span><span class="op">=</span>[<span class="fl">2.5</span><span class="op">,</span> <span class="fl">3.5</span><span class="op">,</span> <span class="fl">4</span><span class="op">,</span> <span class="fl">5</span>]<span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">y</span><span class="op">=</span>[<span class="fl">1.5</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">1</span><span class="op">,</span> <span class="fl">1.5</span>]<span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">plot</span>(<span class="va">x</span><span class="op">,</span> <span class="va">y</span>)</span></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">% fplot 函数二维作图</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">% fplot(f,lims) 其中，f 代表一个函数，通常采用函数句柄的形式。lims 为 x 轴的取值范围。</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;</span> <span class="va">fplot</span>(<span class="op">@</span>(<span class="va">x</span>) <span class="va">sin</span>(<span class="va">x</span>)<span class="op">,</span>[<span class="fl">0</span><span class="op">,</span><span class="fl">3</span>])</span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">% plot3 函数三维作图</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="va">x</span><span class="op">=</span>[<span class="fl">0.2</span><span class="op">,</span> <span class="fl">1.8</span><span class="op">,</span> <span class="fl">2.5</span>]<span class="op">;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="va">y</span><span class="op">=</span>[<span class="fl">1.3</span><span class="op">,</span> <span class="fl">2.8</span><span class="op">,</span> <span class="fl">1.1</span>]<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="va">z</span><span class="op">=</span>[<span class="fl">0.4</span><span class="op">,</span> <span class="fl">1.2</span><span class="op">,</span> <span class="fl">1.6</span>]<span class="op">;</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="va">plot3</span>(<span class="va">x</span><span class="op">,</span> <span class="va">y</span><span class="op">,</span> <span class="va">z</span>)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="va">grid</span> <span class="va">on</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="va">axis</span>([<span class="fl">0</span><span class="op">,</span> <span class="fl">3</span><span class="op">,</span> <span class="fl">1</span><span class="op">,</span> <span class="fl">3</span><span class="op">,</span> <span class="fl">0</span><span class="op">,</span> <span class="fl">2</span>])<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">% fplot3 函数三维作图</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="co">% fplot3(funx,funy,funz,tlims) 其中，funx、funy、funz 代表定义曲线 x、y、z 坐标的函数，通常采用函数句柄的形式。tlims 为参数函数自变量的取值范围。</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="va">xt</span><span class="op">=@</span>(<span class="va">t</span>) <span class="va">exp</span>(<span class="op">-</span><span class="va">t</span><span class="op">/</span><span class="fl">10</span>)<span class="op">.*</span><span class="va">sin</span>(<span class="fl">5</span><span class="op">*</span><span class="va">t</span>)<span class="op">;</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="va">yt</span><span class="op">=@</span>(<span class="va">t</span>) <span class="va">exp</span>(<span class="op">-</span><span class="va">t</span><span class="op">/</span><span class="fl">10</span>)<span class="op">.*</span><span class="va">cos</span>(<span class="fl">5</span><span class="op">*</span><span class="va">t</span>)<span class="op">;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="va">zt</span><span class="op">=@</span>(<span class="va">t</span>) <span class="va">t</span><span class="op">;</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="va">fplot3</span>(<span class="va">xt</span><span class="op">,</span> <span class="va">yt</span><span class="op">,</span> <span class="va">zt</span><span class="op">,</span> [<span class="op">-</span><span class="fl">12</span><span class="op">,</span> <span class="fl">12</span>])</span></code></pre></div>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-01-14T16:00:00.000Z" itemprop="datePublished">2022/01/15</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">计算机 - 数据库</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-知识表示"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/">知识表示</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="知识">知识</h2>
<p>知识的分类：</p>
<ul>
<li>陈述性知识（Declarative knowledge）指个人具有有意识的提取线索，因而能直接陈述的知识。是关于“是什么”、“为什么”的知识。</li>
<li>程序性知识（Procedural knowledge）个人没有有意识提取线索，只能借助某种作业形式间接推论其存在的知识。是关于“怎么办”的知识。一套办事的操作步骤。</li>
<li>显性知识（Explicit Knowledge）“能明确表达的知识”，“可以写下来，能说出来的知识”。</li>
<li>隐性知识（Tacit Knowledge）波兰尼（Michael Polanyi）在1958年从哲学领域提出的概念。</li>
<li>根据作用范围：
<ul>
<li>常识性知识</li>
<li>领域性知识</li>
</ul></li>
<li>根据确定程度：
<ul>
<li>确定性知识</li>
<li>不确定性知识</li>
</ul></li>
<li>根据结构及表现形式：
<ul>
<li>逻辑性知识</li>
<li>形象性知识</li>
</ul></li>
<li>根据表达的内容：
<ul>
<li>事实性知识</li>
<li>过程性知识（有一定规律性的处理问题的方法）</li>
<li>控制性知识（对事物的一些控制规则）</li>
<li>行为性知识（常表示为某种数学模型）</li>
<li>实例性知识（只给出实例而规律隐藏在其中的案例）</li>
<li>类比性知识（只能给出相似性的描述而不能完整刻画事物的一些比喻等）</li>
<li>元知识（关于知识的知识）</li>
</ul></li>
</ul>
<p>知识的特性：</p>
<ul>
<li>相对正确性：任何知识都是在一定的条件及环境下产生的，在这种条件和环境下才是正确的。</li>
<li>不确定性：随机性、模糊性、经验和不完全性引起的不确定性。</li>
<li>可表示性与可利用性 ：可表示性指用适当的形式表示知识。可利用性是指知识可以被利用。</li>
</ul>
<h2 id="知识工程">知识工程</h2>
<p>知识工程：以知识为处理对象，研究知识系统的知识表示、处理和应用的方法和开发工具的学科</p>
<p>传统KE的基本特点：</p>
<ul>
<li>自上而下</li>
<li>严重依赖专家和人的干预</li>
<li>规模有限，质量存疑</li>
</ul>
<p>传统KE的主要挑战：</p>
<ul>
<li>知识获取困难
<ul>
<li>隐性知识、过程知识等难以表达</li>
<li>领域知识的形式化表达较为困难</li>
<li>专家知识不可避免地存在主观性</li>
<li>不同专家之间知识可能存在不一致性</li>
<li>知识表达难以完备，缺漏是常态</li>
</ul></li>
<li>知识应用困难
<ul>
<li>应用易于超出预先设定的知识边界</li>
<li>很多应用需要常识的支撑</li>
<li>难以处理异常情况</li>
<li>难以处理不确定性推理</li>
<li>知识更新困难</li>
</ul></li>
</ul>
<p>大数据知识工程（BigKE）的特点：互联网上的搜索关键字具有开放性、规模巨大等特点</p>
<ul>
<li>大规模开放性应用：永远不知道用户下一个搜索关键字是什么</li>
<li>精度要求不高：搜索引擎从来不需要保证每个搜索的理解和检索都是正确的</li>
<li>应用/推理简单：大部分搜索理解与回答只需要实现简单的推理</li>
</ul>
<h2 id="知识表示">知识表示</h2>
<p>知识表示的用途或特点：</p>
<ul>
<li>客观事物的机器标识（KR is a Surrogate)，定义客观实体的机器指代或指称。</li>
<li>一组本体约定和概念模型（A KR is a Set of Ontological Commitments)，定义用于描述客观事物的概念和类别体系。</li>
<li>支持推理的表示基础（A KR is a Theory of Intelligent Reasoning)，提供机器推理的模型与方法。</li>
<li>用于高效计算的数据结构（A KR is a medium for Efficient Computation)，知识表示也是一种用于高效计算的数据结构。</li>
<li>人可理解的机器语言（A KR is a Medium of Human Expression)，接近于人的认知，是人可理解的机器语言。</li>
</ul>
<p>知识表示方法的选择：方法的选择关系到知识的有效存储，影响知识推理效率和对新知识的获取能力。</p>
<ul>
<li>能充分表示领域知识：足够的表示能力，能正确有效地表示问题求解所需的各种知识。</li>
<li>具有较高的知识使用效率：清晰自然的模块结构，有利于对知识的利用。表示模型简单、有效，便于领域问题求解策略的推理和对知识库的搜索实现。</li>
<li>易于扩展与管理：易于新知识的获取和知识库的维护、扩充与完善。</li>
<li>知识和元知识的统一表达：知识和知识元属于不同层次的知识，使用统一的表示方法可以简化知识处理。</li>
<li>便于理解与实现：好的知识表示是同时为机器和人设计的。</li>
</ul>
<p>医学知识表示的挑战：</p>
<ul>
<li>医学词汇、本体、CIGs和EHRs的整合</li>
<li>知识的更新和维护</li>
<li>精准医疗的知识定制和总结</li>
<li>为了支持数据驱动的医学大数据分析</li>
<li>多重病症</li>
<li>将遗传和组学知识纳入医疗保健</li>
<li>促进将基于知识的技术和系统纳入卫生保健</li>
<li>扩展这些技术和系统的用途</li>
</ul>
<h3 id="早期方法">早期方法</h3>
<h4 id="命题逻辑">命题逻辑</h4>
<p>命题（Proposition）：具有“真假”意义的陈述句。</p>
<p>原子命题：不能被分解成更为简单的陈述句。（不包含任何逻辑联结词的命题）</p>
<p>复合命题：由联结词、标点符号和原子命题等组合构成的命题。</p>
<p>命题演算的判定问题：通过有限步骤确定给定命题是永真式、永假式或可满足的问题。</p>
<p>范式：当命题中原子命题的数目较大时，用真值表演算太麻烦，可把命题公式化为某种标准型。</p>
<p>个体（Individual）：原子命题中所描述的对象。指可以独立存在的事物，可以是抽象的概念，也可以是具体的实体。任意一个个体都有一个讨论范围，称为论域（Universe of Discourse），通常用D表示。个体相当于论域中的元素。</p>
<p>谓词（Predicates）：在原子命题中用以描述个体的性质或个体间关系的部分。</p>
<p>命题的谓词形式：一个命题用一个谓词和n个有次序的个体表示成 P(a1, a2, …, an）。个体的出现顺序影响命题的真值。谓词中的个体数目称为谓词的元数。</p>
<p>函词（Function）：指以论域为定义域和值域的一种映射，用来表示函数。在原子命题中用以描述个体的性质或个体间关系的部分。</p>
<p>量词（Quantifier）：</p>
<ul>
<li>全称量词（∀）：“所有的”，“任意的”，“每一个”</li>
<li>存在量词（∃）：“存在一些”，“对于某些”，“至少有”</li>
</ul>
<h4 id="谓词逻辑">谓词逻辑</h4>
<p>谓词逻辑：人工智能领域的一种知识表示方法。</p>
<p>谓词逻辑翻译的一般步骤：</p>
<ul>
<li>正确理解给定命题。必要时把命题改叙，使其能表达每个原子命题及原子命题间的关系。</li>
<li>把每个原子命题分解成个体、谓词和量词。在全论域中讨论时，要给出特性谓词约束范围。</li>
<li>找出适当的量词。全称量词后跟蕴含式，存在量词后跟合取式。</li>
<li>用适当的联结词把给定命题表示出来。</li>
</ul>
<p>谓词逻辑的特点：</p>
<ul>
<li>优点：
<ul>
<li>结构性。能把事物的属性以及事物间的各种语义联想显式地表示出来 。</li>
<li>严密性。有形式化的语法和语义，以及相关的推理规则。</li>
<li>可实现性。可判定，可以转换为计算机内部形式，以便用算法实现。</li>
</ul></li>
<li>缺点：
<ul>
<li>有限的可用性。</li>
<li>一阶逻辑的逻辑归结只是半可判定性的。</li>
<li>无法表示不确定性知识。</li>
</ul></li>
</ul>
<h4 id="霍恩逻辑">霍恩逻辑</h4>
<p>霍恩子句：带有最多一个肯定文字的子句。</p>
<p>霍恩逻辑（Hom Logic）：一阶逻辑的子集。</p>
<p>霍恩子句和霍恩逻辑的特点：</p>
<ul>
<li>优点：
<ul>
<li>结构性。能把事物的属性以及事物间的各种语义联想显式地表示出来。</li>
<li>严密性。有形式化的语法和语义，以及相关的推理规则。</li>
<li>易实现性。可判定，可以转换为计算机内部形式，以便用算法实现。</li>
</ul></li>
<li>缺点：
<ul>
<li>有限的表达能力。</li>
<li>不能定义类表达式。</li>
<li>不能够任意使用量化 。</li>
<li>无法表示不确定性知识。</li>
</ul></li>
</ul>
<h4 id="描述逻辑">描述逻辑</h4>
<p>描述逻辑：一阶逻辑的一个可判定子集 。</p>
<p>描述逻辑可以被看成是利用一阶逻辑对语义网络和框架进行形式化后的产物。</p>
<p>描述逻辑支持一元谓词和二元谓词 。</p>
<ul>
<li>一元谓词称为类（概念）</li>
<li>二元谓词称为关系</li>
</ul>
<p>描述逻辑的知识库 O:=&lt;T, A&gt;，T 即 T-box，A 即 A-box</p>
<ul>
<li>T-box（Terminology Box）包含内涵知识，描述概念的一般性质。由于概念之间存在包含关系，T-box 知识形成类似格的结构，这是由包含关系决定的，与具体实现无关。</li>
<li>A-box（Assertion Box）包含外延知识（又称断言知识），描述论域中的特定个体。</li>
<li>R-Box（Role Box）包含属性/关系知识（property axioms）</li>
</ul>
<p>描述逻辑同时具有很强的表达能力和可判定性。</p>
<p>描述逻辑近年来受到广泛关注，被选为 W3C 互联网本体语言 (OWL) 的理论基础。</p>
<p>描述逻辑的特点：</p>
<ul>
<li>优点：
<ul>
<li>结构性。能把事物的属性以及事物间的各种语义联想显式地表示出来。</li>
<li>严密性。有形式化的语法和语义，以及相关的推理规则。</li>
<li>易实现性。可判定，可以转换为计算机内部形式，以便用算法实现。</li>
<li>多样性。具有大量可判定的扩展，以满足不同应用场景的需求。</li>
</ul></li>
<li>缺点：
<ul>
<li>有限的表达能力。</li>
<li>不支持显式使用变量。</li>
<li>不能够任意使用量化。</li>
<li>无法表示不确定性知识。</li>
</ul></li>
</ul>
<h4 id="产生式规则">产生式规则</h4>
<p>产生式规则的一般形式：由条件和动作组成的指令，记为 C -&gt; A（IF C THEN A）</p>
<ul>
<li>C：产生式前提（前件），指出该产生式可用的条件。</li>
<li>A：一组结论或操作（后件），指出当C的条件成立时，应当获得的结论或执行的操作。</li>
</ul>
<p>产生式规则具有广泛的知识表示能力：既可以表示确定性知识，又可以表示不确定性知识。</p>
<p>产生式规则与逻辑蕴含式：</p>
<ul>
<li>逻辑蕴含式是产生式规则的一种。
<ul>
<li>逻辑蕴含式是一个逻辑表达式，值只有真和假，只能表示精确知识。产生式规则表示的知识可以是不确定的。</li>
<li>逻辑蕴含式的匹配要求一定是精确的，产生式规则的前提和结论都可以是不确定的，匹配自然是可以不确定的。</li>
</ul></li>
</ul>
<p>产生式规则系统的构成：</p>
<ul>
<li>产生式规则库（规则集）
<ul>
<li>由领域规则组成，以某种动态数据结构进行组织。</li>
<li>规则库中知识的完整性、一致性、准确性、组织的合理性直接影响系统的性能。</li>
</ul></li>
<li>综合数据库（事实库）
<ul>
<li>存放问题求解过程中各种当前信息的数据结构。如：问题的初始状态、原始证据、中间结论、最终结果。</li>
<li>当规则库中某条规则的前提与综合数据库中的某些已知事实匹配时，该产生式被激活，并将它推出的结论放入综合数据库，作为新的已知事实。</li>
</ul></li>
<li>控制系统（推理机）
<ul>
<li>一个解释程序，控制和协调规则库及综合数据库的运行。
<ul>
<li>按一定策略从规则库中选择规则，与综合数据库中的事实进行匹配。</li>
<li>对于匹配成功的多条规则进行消解，选出一条规则执行。</li>
<li>将规则结论存入综合数据库或执行相应的操作。</li>
<li>对于不确定性知识，计算结论的不确定性。</li>
<li>在适当的时候停止系统的运行。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="专家系统">专家系统</h4>
<p>专家系统：一种具有智能的计算机系统，它应用人工智能技术和计算机技术，内部含有大量的某个领域专家水平的知识与经验，能够利用这些知识和解决问题的方法进行推理和判断，模拟人类专家的决策过程。</p>
<p>专家系统的特征：</p>
<ul>
<li>具有专家水平的领域知识
<ul>
<li>数据级知识：初始事实，中间结论，最终结论等。如患者的症状、化验结果、专家系统推出的病因、治疗方案等。</li>
<li>知识库级知识：专家的知识。如医学常识、医生诊断疾病的经验等。（系统的性能取决于此类知识的质量和数量）</li>
<li>控制级知识：如何运用前两种知识的知识。如搜索策略、匹配算法等。</li>
</ul></li>
<li>能进行有效的推理
<ul>
<li>领域不同，要求的推理机制不同。如，精确推理、不确定性推理</li>
</ul></li>
<li>获取知识的能力
<ul>
<li>知识工程师和领域专家采用知识编辑器输入。</li>
<li>基于机器学习自动进化。</li>
</ul></li>
<li>灵活性：知识库与推理机分离。</li>
<li>透明性：系统自身及其行为能被用户所理解。</li>
<li>交互性：领域专家和知识工程师获取知识。获取求解问题时所需的已知事实。回答用户提问。</li>
<li>实用性：针对特定领域问题开发。</li>
</ul>
<p>专家系统的分类：</p>
<ul>
<li>解释专家系统：通过对已知信息和数据的分析与解释，确定它们的含义。</li>
<li>预测专家系统：通过对过去和现在已知状况的分析，推断未来可能发生的情况。</li>
<li>设计专家系统：根据设计要求，求出满足设计问题约束的目标配置。</li>
<li>诊断专家系统：根据观察到的数据推断某个对象机能失常（故障）的原因。</li>
<li>教学专家系统：根据学生的特点、弱点和基础知识，选择最适当的教案和教学方法。</li>
<li>控制专家系统：自适应地管理一个受控对象或客体的全部行为，使之满足预期要求。</li>
</ul>
<h4 id="框架">框架</h4>
<p>框架（Frame）：一种描述对象（事物 、事件或概念等）属性的数据结构。</p>
<p>框架的目标：更好地理解视觉推理和自然语言处理。</p>
<p>框架的基本思想：人们对现实世界中各种事物的认识都以一种类似于框架的结构存储在记忆中。当面临一个新事物时，就从记忆中找出一个合适的框架，并根据实际情况对其细节加以修改、补充，从而形成对当前事物的认识。</p>
<p>类：框架的基本单位。每个类有一些槽，每个槽又可分为若干“侧面”。</p>
<ul>
<li><p>槽（Slot）：表示描述对象的一个属性，</p></li>
<li><p>侧面（Facet）：表示槽属性的一个方面，</p></li>
<li><p>槽和侧面都可以有值，分别称为槽值和侧面值 。</p></li>
</ul>
<p>框架允许给属性设默认值，以及设立触发器以维护框架 。</p>
<p>框架是知识的基本单位，把一组有关的框架连结起来便可形成一个框架网络。</p>
<ul>
<li>纵向联系：继承</li>
<li>横向联系：用另一框架填写槽值或侧面值</li>
</ul>
<p>框架的特点：</p>
<ul>
<li>优点：
<ul>
<li>结构性，能把事物的属性以及事物间的各种语义联想显式地表示出来 。</li>
<li>框架对于知识的描述比较全面，支持默认值以及触发器。</li>
</ul></li>
<li>缺点：
<ul>
<li>构建成本非常高，对知识库的质量要求非常高 。</li>
<li>默认值会增大推理的复杂度。</li>
<li>无法表示不确定性知识 。</li>
</ul></li>
</ul>
<h4 id="语义网络">语义网络</h4>
<p>语义网络（Semantic Network)：概念及其语义关系组成的一种带标识的有向图。</p>
<ul>
<li>节点：各种事物、概念、情况、状态等。每个节点可以有若干属性。</li>
<li>边：也称连接弧或联想弧，表示各种语义联系、动作 。每个边有方向、有标注。</li>
</ul>
<p>语义网络的基本语义关系：</p>
<ol type="1">
<li><p>类属关系：具有共同属性的不同事物间的分类关系、成员关系或实例关系。“具体与抽象”、“个体与集体”的层次关系</p>
<ul>
<li><p>AKO (A-Kind-Of)：一个事物是另一个事物的一种类型。</p></li>
<li><p>AMO (A-Member-Of)：一个事物是另一个事物的成员。</p></li>
<li><p>ISA ( Is-A)：一个事物是另一个事物的实例。</p></li>
</ul></li>
<li><p>聚类关系（包含关系）：具有组织或结构特征的“部分与整体”之间的关系。</p>
<p>与类属关系的区别：聚类关系一般不具备属性的继承性。</p>
<ul>
<li>Part-of：一个事物是另一个事物的一部分。（脚， Part-of，肢体） ，（细胞核，Part-of，细胞）</li>
</ul></li>
<li><p>属性关系：事物和其属性之间的关系。</p>
<ul>
<li><p>Have：一个节点具有另一个节点所描述的属性。</p></li>
<li><p>Can：一个节点能做另一个节点的事情。（降压药，Can，降血压），（糖尿病，有症状，多饮）</p></li>
</ul></li>
<li><p>因果关系：由于某一事件的发生而导致另一个事件的发生，适合规则性知识。</p>
<ul>
<li>If-then：如果...那么...（超重，If-then，糖尿病高危人群）</li>
</ul></li>
<li><p>时间关系：不同事件在其发生时间方面的先后关系。</p>
<ul>
<li><p>Before：一个事件在另一个事件之前发生。（单药治疗， before，二联治疗）</p></li>
<li><p>After：表示一个事件在另一个事件之后发生。（三联治疗，after，二联治疗）</p></li>
</ul></li>
<li><p>位置关系</p>
<ul>
<li><p>Located-on（表皮， Located-on，真皮）</p></li>
<li><p>Located-at</p></li>
<li><p>Located-under</p></li>
<li><p>Located-inside（心脏，Located-inside，身体）</p></li>
<li><p>Located-outside</p></li>
</ul></li>
<li><p>相近关系（相似关系）：不同事物在形状、内容等方面相似或接近。</p>
<ul>
<li><p>Similar-to（相似）</p></li>
<li><p>Near-to（接近）</p></li>
</ul></li>
<li><p>组成关系：某一事物由其他一些事物构成。</p>
<ul>
<li>Composed-of</li>
</ul></li>
</ol>
<p>知识的语义网络表示：</p>
<ul>
<li>事实性知识的表示：
<ul>
<li>简单事实用两个节点和基本语义关系即可表示。</li>
<li>复杂事实通常涉及多个事物，通常用语义网络表示。</li>
</ul></li>
<li>情况、动作和事件的表示：
<ul>
<li>情况的表示：不及物动词语句的表示或没有间接宾语的及物动词语句，如果语句的动作表示了一些其他情况，如动作的时间等。增加一个情况节点用于指出各种不同的情况。</li>
<li>动作的表示：语句既有发出动作的主体，又有接受动作的客体。增加一个动作节点以指出动作的主体和客体。</li>
<li>事件的表示：增加一个事件节点表示事件知识。</li>
</ul></li>
<li>连词和量词的表示：
<ul>
<li>合取与析取的表示：增加合取节点和析取节点。</li>
</ul></li>
<li>存在量词和全称量词的表示：
<ul>
<li>存在量词用“是一种”，“是一个”表示。</li>
<li>全称量词用语义网络分区技术表示。把一个复杂的命题划分成若干个子命题，每个子命题用一个简单的语义网络表示，称为子空间，每个子空间看作大空间的一个节点，称为超节点。空间可以逐层嵌套，子空间之间用弧连接。</li>
</ul></li>
</ul>
<p>用语义网络表示知识的步骤：</p>
<ol type="1">
<li>确定问题中所有对象及其属性。</li>
<li>确定对象间的关系。</li>
<li>对语义网络中的节点及弧进行整理，包括增加节点、弧和归并节点等。
<ul>
<li>ISA、AKO、AMO等类属关系：下层节点对上层节点具有属性继承性。抽取同一层节点的共同属性加入上层节点中，避免信息冗余。</li>
<li>因果关系：增加情况节点，从该节点引出多条弧，将原因节点和结果节点连接起来。</li>
<li>动作关系：增加动作节点，从该节点引出多条弧，将动作的主体节点、客体节点连接起来。</li>
<li>“与”“或”关系：增加“与”节点和“或”节点，用弧将这些“与”“或”节点与其他节点连接起来以表示知识中的语义关系。</li>
<li>全称量词和存在量词：采用语义网络分区技术。</li>
<li>规则性知识：分析问题中的条件与结论，将它们作为语义网络中的两个节点，然后用 if-then 弧将它们连接起来。</li>
</ul></li>
<li>以对象作为节点，关系作为节点间的弧，连接形成语义网络。</li>
</ol>
<p>语义网络的推理方法：</p>
<ul>
<li><p>继承推理：下层节点继承上层节点的属性或方法。</p>
<ul>
<li>建立节点表，存放待求节点和所有以继承弧与此节点相连的那些节点。初始状态只有待求解的节点。</li>
<li>检查表中第一个节点是否有继承弧。如果有，从该弧所指的存放所有节点的节点表的末尾记录这些节点的所有属性，并从节点表中删除第一个节点。如果没有，仅从节点表中删除第一个节点。</li>
<li>重复检查表中的下一个节点是否有继承弧，直到节点表为空。记录下来的属性就是待求节点的所有属性。</li>
<li>推理规则：
<ul>
<li>IF X (AKO) Y AND Y (AKO) Z THEN X(AKO) Z</li>
<li>IF X (ISA) Y AND Y (AKO) Z THEN X (ISA) Z</li>
<li>IF X (AKO) Y AND Y (属性) Z THEN X (属性) Z</li>
<li>IF X (ISA) Y AND Y (属性) Z THEN X (属性) Z</li>
<li>IF X (属性) Y AND Y (AKO) Z THEN X (属性) Z</li>
<li>IF X (属性) Y AND Y (ISA) Z THEN X (属性) Z</li>
</ul></li>
</ul></li>
<li><p>匹配推理：在语义网络中寻找与待求问题相符的语义网络模式。</p>
<ul>
<li><p>根据问题的要求构造网络片段，片段中有些节点或弧为空，标记待求解的问题（询问处）。</p></li>
<li><p>根据片段在知识库中寻找相应的信息。</p></li>
<li><p>当待求的语义网络片段和知识库中的语义网络片段相匹配时，与询问处（待求解的地方）相匹配的事实就是问题的解。</p></li>
</ul></li>
</ul>
<p>语义网络的特点：</p>
<ul>
<li>优点：
<ul>
<li>联想性。最初是作为人类联想记忆模型提出来的。</li>
<li>自然性。直观地把事物的属性及其语义联系表示出来，便于理解，自然语言与语义网络的转换比较容易实现，故语义网络表示法在自然语言理解系统中的应用最为广泛 。</li>
<li>结构性。语义网络是一种结构化的知识表示方法，对数据子图特别有效 。它能把事物的属性以及事物间的各种语义联想显式地表示出来。</li>
<li>自索引性。用户通过与某一节点连接的弧很容易找出相关信息，不必查找整个知识库，可以避免搜索时的组合爆炸问题。</li>
</ul></li>
<li>缺点：
<ul>
<li>无形式化语法。
<ul>
<li>语义网络表示知识的手段多样，虽然灵活性很高，但是由于表示形式的不一致增加了对其处理的复杂性。</li>
</ul></li>
<li>无形式化语义。
<ul>
<li>与一阶谓词逻辑相比，语义网络没有公认的形式表示体系。一个给定的语义网络表达的含义完全依赖处理程序如何对它进行解释。通过推理网络而实现的推理不能保证其正确性。</li>
<li>采用量词的语义网络表示法在逻辑上是不充分的，可能存在二义性 。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="语义网">语义网</h3>
<p>语义网（Semantic Web）：核心是通过给万维网上的文档（如HTML文档、XML文档）添加能够被计算机所理解的语义“元数据”（Meta data），从而使整个互联网成为一个通用的信息交换媒介。</p>
<p>语义网的缺点： - 节点和边的值没有标准，完全是由用户自己定义。 - 多源数据融合比较困难，因为没有标准。 - 无法区分概念节点和对象节点。 - 无法对节点和边的标签进行定义。</p>
<h4 id="rdf">RDF</h4>
<p>RDF（Resource Description Framework）：Web中信息的表示框架。W3C的RDF工作组制定的关于知识图谱的国际标准，是W3C一系列语义网标准的核心。既满足计算机对Web中信息的处理，又便于人的阅读。RDF提供了一个用于表示该信息的公共框架，因此可以在应用程序之间交换信息，而不会失去意义。</p>
<p>资源（Resource）：IRI 或 literal，同义词：entity。可以是任何事物，包括物理实体、文档、抽象概念、数字和字符串。</p>
<ul>
<li>字面量（literal）有数据类型，例如 strings, numbers, and dates。可以通过语言标记（langString）指定字面量的语言类型。</li>
</ul>
<p>RDF图中知识以三元组的形式表示。一个RDF三元组被称为一个RDF语句（statement）：(subject，predicate，object)</p>
<ul>
<li>主语：是一个个体（Individual），个体是类的实例。</li>
<li>谓语：是一个属性。属性可以连接两个个体，或者连接一个个体和一个数据类型的实例。</li>
<li>宾语：可以是一个个体，也可以是一个数据类型的实例。</li>
</ul>
<p>RDF图中可以3种节点：IRI, literal, blank node。</p>
<ul>
<li>IRI (Internationalized Resource Identifier)：国际化资源标识符，URI的超集，字符集被扩展到通用字符集Unicode
<ul>
<li>URI：统一资源标识符，字符集被限制为US-ASCII
<ul>
<li>URN：统一资源名称，由命名空间标识符（NID）和命名空间特定字符串（NSS）组成</li>
<li>URL：统一资源定位符，即网址，通常指的是不包含URN的URI子集</li>
</ul></li>
</ul></li>
<li>字面量（literal）由两个或三个元素组成：
<ul>
<li>词汇形式，是Unicode字符串，</li>
<li>一个数据类型 IRI ，作为一个识别数据类型的 IRI ，决定了词汇形式如何映射到一个字面量（IBM-Talk, talkDate, “05-10-2012” ^xsd:date）</li>
</ul></li>
<li>空白节点（Blank Node）：RDF中没有全局标识的节点，前缀为“_”。</li>
</ul>
<p>RDF图：一组RDF三元组。一个RDF graph也有对应的 IRI。</p>
<p>IRI 命名空间：RDF词汇表中的 IRIs 通常从称为命名空间 IRI 的公共子字符串开始。</p>
<p>RDF是抽象的数据模型，支持不同的序列化格式，例如 RDF/XML、Turtle 和 N-Triple：</p>
<ul>
<li>XML的格式太冗长，不便于阅读，通常不会使用这种方式来处理RDF数据。</li>
<li>Turtle是使用得最多的一种RDF序列化方式。比RDF/XML紧凑，可读性比N-Triples好。</li>
<li>N-Triples用多个三元组来表示RDF数据集，是最直观的表示方法。在文件中，每一行表示一个三元组，方便机器解析和处理。开放领域知识图谱DBpedia通常是用这种格式来发布数据的</li>
</ul>
<p>RDF 图谱里的知识有可能是不完备的，这符合 Web 的开放性特点和要求。经典数据库采用封闭世界假设， RDF采用的是开放世界假设：</p>
<ul>
<li>开放世界假设：没有明确的包含的所有元组，都被假定为是未知的事实而不是假的。</li>
<li>封闭世界假设：所有没有明确包含在表中的记录都假定表示这是假的事实。</li>
</ul>
<h4 id="rdfs">RDFS</h4>
<p>RDFS（RDF Schema）：RDF的语义扩展。用RDF编写，为RDF数据提供了数据建模词汇表，提供了描述相关资源组和这些资源之间关系的机制。</p>
<p>RDFS 提供了最基本的对类和属性的描述元语</p>
<ul>
<li>rdfs:subClassOf: 用于指定类的父类</li>
<li>rdfs:subPropertyOf: 用于指定属性的父属性</li>
<li>rdfs:domain: 用于指定属性的定义域</li>
<li>rdfs:range: 用于指定属性的值域</li>
<li>rdfs:subPropertyOf：用于描述该属性的父属性</li>
<li>rdfs:label：用于描述人可读的资源名字</li>
<li>rdfs:comment：为资源提供人可读的文本描述</li>
<li>rdfs:seeAlso：声明对当前资源提供了额外信息的资源。</li>
<li>rdfs:isDefinedBy：用于描述当前资源是由哪个资源定义的</li>
<li>rdfs:Class：所有类的类</li>
<li>rdfs:Resource：所有资源的类</li>
<li>rdfs:Literal：字符串和整数等字面量的类
<ul>
<li>属性值如文本字符串是rdfs:Literal的实例。</li>
<li>rdfs:Literal是rdfs:Class的一个实例。</li>
<li>rdfs:Literal是rdfs:Resource的子类。</li>
</ul></li>
<li>rdfs:Datatype：数据类型的类。
<ul>
<li>rdfs:Datatype的所有实例对应于RDF概念规范中描述的RDF模型数据类型。</li>
<li>rdfs:Datatype是rdfs:Class的一个实例和子类。</li>
<li>rdfs:Datatype的每个实例都是rdfs:Literal的一个子类。</li>
</ul></li>
</ul>
<p>在更复杂的场景下，RDFS 的语义表达能力不够，缺少一些常用的特征 :</p>
<ul>
<li>对于局部值域的属性定义
<ul>
<li>RDFS 中通过 rdfs:range 定义了属性的值域，该值域是全局性的，无法说明该属性应用于某些具体的类时具有的特殊值域限制，如无法声明父母至少有一个孩子 。</li>
</ul></li>
<li>类、属性、个体的等价性
<ul>
<li>RDFS 中无法声明两个类或多个类、属性和个体是等价还是不等价。如，无法声明 Tim-BemsLee和T.B.Lee是同一个人。</li>
</ul></li>
<li>不相交类的定义
<ul>
<li>在 RDFS 中只能声明子类关系，但无法声明这两个类是不相交的 。如，男人和女人是不相交的类</li>
</ul></li>
<li>基数约束
<ul>
<li>对某属性值可能或必需的取值范围进行约束，如说明一个人有双亲 (包括两个人)，一门课至少有一名教师等。</li>
</ul></li>
<li>关于属性特性的描述
<ul>
<li>声明属性的某些特性，如传递性、函数性、对称性，以及声明一个属性是另一个属性的逆属性等，如大于关系的逆关系是小于关系。</li>
</ul></li>
</ul>
<h4 id="owl">OWL</h4>
<figure>
<img src="https://img-blog.csdnimg.cn/20200807211114841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY1MDgx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>OWL语言的选择：在要求简单是可采用OWL Lite，通常可采用OWL DL，对概念要求定义精确时采用OWL Full。</p>
<ul>
<li>选择 OWL Lite 还是 OWL DL 主要取决于用户需要整个语言在多大程度上给出约束的可表达性。</li>
<li>选择 OWL DL 还是 OWL Full 主要取决于用户在多大程度上需要 RDF 的元模型机制，如定义类型的类型以及为类型赋予属性。</li>
<li>当使 用 OWL Full 而不是 OWL DL 时，推理的支持可能不能工作，因为目前还没有完全支持 OWL Full 的系统实现。</li>
</ul>
<p>OWL和RDF的关系：</p>
<ul>
<li>OWL Full可以看成是RDF的扩展</li>
<li>OWL Lite和OWL DL可以看成是一个约束化的RDF的扩展</li>
<li>所有的OWL文档（Lite, DL, Full）都是一个RDF文档</li>
<li>所有的RDF文档都是一个OWL Full文档</li>
<li>只有一些RDF文档是一个合法的OWL Lite和OWL DL文档</li>
</ul>
<h4 id="owl-2">OWL 2</h4>
<p>OWL 2 ：OWL 1的扩展，增加了新的功能和特性。</p>
<p>OWL 2 本体包括：classes, properties, individuals, and data values</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2020080721151672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY1MDgx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>OWL2 QL适合概念多的情况，OWL2 EL适合实例较多的情况，如医学领域，OWL2 RL适合高效推理。</p>
<p>OWL2 QL：QL代表query language的意思，专为基于本体的查询设计。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200807211600434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY1MDgx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>OWL2 EL：是基于描述逻辑语言EL++定义的，专为概念术语描述,推理而设计：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200807211710240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY1MDgx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p>OWL 2 RL：在RDFS的基础上引入属性的特殊特性 (函数性,互反性,对称性)；允许声明等价性；允许属性的局部约束。OWL 2 RL与描述逻辑没有直接关系。专为高效推理设计（推理针对的是实例数据）。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200807211728526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTY1MDgx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<h3 id="本体">本体</h3>
<p>本体：共享概念模型的明确的形式化规范说明。</p>
<p>本体形式化表示为，O={C，H， P，A，I}：</p>
<ul>
<li>C，概念集合，如事物性概念和事件类概念。
<ul>
<li>例如：二甲双胍</li>
</ul></li>
<li>H，概念的上下位关系集合，也称为Taxonomy 知识。
<ul>
<li>例如：“糖尿病”与“2型糖尿病”</li>
</ul></li>
<li>P，属性集合，描述概念所具有的特征。
<ul>
<li>例如：病人具有年龄、性别、诊断等属性</li>
</ul></li>
<li>A，规则集合，描述领域规则。
<ul>
<li>例如：用Swrl描述的一条规则：age(?a), ‘cardiovascular disease’(?z1), patient(?x), ‘patient profile’(?y), has_demographic(?y, ?a), has_patient_profile(?x, ?y), has_complication(?y, ?z1), has_quantitatie_Value(?a, ?v), greaterThanOrEqual(?v, 45) à ‘symptomatic patient’(?x)</li>
</ul></li>
<li>I ，实例集合，用来描述实例-属性-值。</li>
</ul>
<p>本体的分类：</p>
<ul>
<li><p>按详细程度（详细程度指描述、刻画建模对象的程度）分</p>
<ul>
<li>参考（Reference）本体，详细程度高</li>
<li>共享（Share）本体，详细程度低</li>
</ul></li>
<li><p>按领域依赖度分</p>
<ul>
<li><p>顶层（Top level）本体：描述最普遍的概念及概念间的关系，表达常识性知识，与具体应用无关。如：空间、时间、事件、行为等</p></li>
<li><p>领域（Domain）本体：描述特定领域的概念及概念间关系。如：医学、药学、商业等</p></li>
<li><p>任务（Task）本体：描述特定任务或行为这的概念及概念间关系。如：治疗、医院管理、随访等</p></li>
<li><p>应用（Application）本体：描述依赖于特定领域和任务的概念及概念间关系。</p>
<table>
<thead>
<tr class="header">
<th>本体类型</th>
<th>典型代表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>顶层本体</td>
<td>BFO、GFO、SUMO等</td>
</tr>
<tr class="even">
<td>领域本体</td>
<td>DO、GO、OGMS、HPO等</td>
</tr>
<tr class="odd">
<td>应用本体</td>
<td>IDO、CIDO、KTAO、DMTO等</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>
<p>本体构建规则：</p>
<ul>
<li>明确性和客观性：本体应该用自然语言对所定义的术语给出明确的、客观的语义定义。</li>
<li>完全性：定义是完整的，完全能表达所描述术语的含义。</li>
<li>一致性：由术语得出的推论与术语本身的含义是相容的，不会产生矛盾。</li>
<li>最大单调可扩展性：向本体中添加通用或专用的术语时，不需要修改已有的内容。</li>
<li>最小承诺：对待建模对象给出尽可能少的约束。</li>
</ul>
<p><strong>本体的构建步骤：</strong></p>
<ol type="1">
<li><strong>确定本体的领域和范围</strong></li>
<li><strong>考虑重用现有的本体</strong></li>
<li><strong>列举本体论中的重要术语</strong></li>
<li><strong>定义类和类层次结构</strong></li>
<li><strong>定义类的属性——槽</strong></li>
<li><strong>定义槽的面（槽候选值、槽值类型、槽的域）</strong></li>
<li><strong>创建实例（选择一个类并创建类的个体实例，填入槽值）</strong></li>
</ol>
<p><strong>从文本中构建领域本体的步骤：</strong></p>
<ol type="1">
<li><strong>预处理 (preprocessing)：对输入的文本进行先期处理（如断句、分词、词性标注、短语识别等），使之符合后续任务对输入的格式要求。</strong></li>
<li><strong>术语抽取（term extraction）：从输入文本中提取那些和目标领域高度相关的领域术语。</strong></li>
<li><strong>概念抽取（concept extraction）：从输入文本中提取那些和目标领域高度相关的概念。</strong></li>
<li><strong>层次关系抽取（hierarchical relation extraction）：抽取本体概念之间的层次关系。</strong></li>
<li><strong>非层次关系抽取（non-hierarchical relation extraction）：抽取本体概念之间的层次关系以外的其它类型关系。</strong></li>
<li><strong>形成本体（form ontology）模块：将前面任务中抽取出来的术语、概念以及概念之间的各种关系进行整合，形成最终的目标本体。</strong></li>
</ol>
<ul>
<li>统计主导的本体构建方法：词汇单元（单个词、词组、短语、词串等）间的共现信息可以为识别它们之间的关系以及描述对应词汇的重要程度提供重要的指示信息，因而可直接应用在本体构建过程中的概念抽取及关系挖掘中。
<ul>
<li>常用的统计方法：聚类、词频统计、词共现分析、潜在语义分析、术语搭配、关系规则挖掘、浅层自然语言处理等。</li>
</ul></li>
<li>语言学方法主导的本体构建方法：在依据给定文本构建本体的过程中，本体概念以及概念之间的关系隐式地存在于输入文本中，这类知识只有通过全面而深入的文本分析技术才可以获得。
<ul>
<li>自然语言处理技术：词性标注、句法分析、依存分析、语义角色标注等。</li>
<li>一些语言相关的资源被广泛应用：语义词典、语义模板、词汇–句法模板等。</li>
</ul></li>
</ul>
<p>从文本中构建领域本体的问题与挑战：</p>
<ul>
<li>多数方法的移植性较差，无法被应用在构建大规模、实用化的本体。</li>
<li>本体更新：对于领域内出现的新概念需要能快速有效地识别，并为之分配合适的关系及属性。由于当前许多本体概念识别方法都依赖于该概念在数据中出现的频率信息，而把新概念和老概念放在统一的数据源中进行重新学习，往往会得到偏倚（biased）结果。</li>
<li>关系消歧：如果关系获取由核心动词决定，由于自然文本中一个核心动词往往具有多个语义，会造成由之确定的关系在实际应用中出现语义不确定性。</li>
<li>概念属性的自动获取以及概念消歧：目前大多数方法得到的本体是一种扁平化的结构。概念通常以单个词、词组或一个相近术语集合的形式给出，无法深入地揭示概念在一个特定领域中所具有的属性。本体概念的消歧问题将直接影响随后的关系抽取任务。</li>
</ul>
<p>生物医学本体：</p>
<ul>
<li>BioPortal</li>
<li>Gene Ontology</li>
<li>SNOMED CT：临床医学系统术语（The Systematized Nomenclature of Medicine - Clinical Terms）</li>
<li>UMLS：（Unified Medical Language System）</li>
<li>HPO：（Human Phenotype Ontology）</li>
<li>OBO：（Open Biomedical Ontologies）</li>
</ul>
<p>本体应用：</p>
<ul>
<li>KPMP：（Kidney Precision Medicine Project）基于 KTAO（Kidney Tissue Atlas Ontology）</li>
<li>Ontology based CDSS</li>
</ul>
<h2 id="知识库">知识库</h2>
<p>知识库：人类知识组织成结构化的知识系统。主要研究目标是从无（半）结构的互联网信息中获取有结构知识，自动融合构建知识库、服务知识推理等相关应用。以网络的形式组织知识库中的知识获得广泛认可。</p>
<p>知识库构建的难题：</p>
<ul>
<li>计算效率问题：每个实体用不同的节点表示。当利用知识库计算实体间的语义或推理关系时，往往需要人们设计专门的图算法来实现，可移植性差。基于图的算法计算复杂度高、可扩展性差，当知识库达到一定规模时，很难较好地满足实时计算的需求。</li>
<li>数据稀疏问题：与其他类型的大规模数据类似，大规模知识库也遵守长尾分布，在长尾部分的实体和关系上，面临严重的数据稀疏问题。例如，对于长尾部分的罕见实体，由于只有极少的知识或路径涉及它们，对这些实体的语义或推理关系的计算往往准确率极低。</li>
</ul>
<p>知识库的符号表示：G = (E, R, S)</p>
<ul>
<li>E是知识库中的实体集合。</li>
<li>R是知识库中的关系集合。</li>
<li>S 属于 E × R × E，代表知识库中的三元组集合，一般表示为 (h, r, t)，h和t表示头实体和尾实体，r表示h和t之间的关系。</li>
</ul>
<p>早期的知识库项目：</p>
<ul>
<li><p>Cyc知识库主要由术语（Term）和断言（Assertion）组成 。术语包含概念、 关系和实体的定义。断言用来建立术语之间的关系，既包括事实（Fact） 描述，也包含规则（Rule）描述。主要特点：基于形式化的知识表示方法来刻画知识。优点：可以支持复杂的推理。缺点：过于形式化导致知识库的扩展性和应用的灵活性不够。</p></li>
<li><p>WordNet最著名的英文词典知识库，主要用于词义消歧。主要定义了名词、动词、形容词和副词之间的语义关系。名词之间的上下位关系（如：“猫科动物”是“猫”的上位词）动词之间的蕴含关系（如：“打鼾”蕴含着“睡眠”）等。</p></li>
<li><p>ConceptNet多语言常识知识库。以三元组形式的关系型知识构成。构建方法：互联网众包、专家创建和游戏。与Cyc相比，ConceptNet采用了非形式化、更加接近自然语言的描述，而不是像Cyc那样采用形式化的谓词逻辑。与链接数据和谷歌知识图谱相比，ConceptNet比较侧重于词与词之间的关系。从这个角度看，ConceptNet更加接近于WordNet，但是又比WordNet包含的关系类型多。</p></li>
</ul>
<h2 id="知识图谱">知识图谱</h2>
<p>互联网时代的知识库——知识图谱：</p>
<ul>
<li><p>Wikidata一个免费开放、多语言、任何人或机器都可以编辑修改的大规模链接知识库。继承了Wikipedia的众包协作的机制，但与Wikipedia不同，WikiData支持的是以三元组为基础的知识条目（Items）的自由编辑。一个三元组代表一个关于该条目的陈述（Statements）。例如：给“地球”的条目增加“&lt;地球，地表面积是，五亿平方公里&gt;”的三元组陈述。</p></li>
<li><p>DBpedia是早期的语义网项目，意指数据库版本的Wikipedia，是从Wikipedia抽取出来的链接数据集。采用了较为严格的RDF语义数据模型本体，包含人、地点、音乐、电影、组织机构、物种、疾病等类定义。与Freebase，Open CYC、Bio2RDF等多个数据集建立了数据链接。</p></li>
<li><p>Schema.org支持各个网站采用语义标签（Semantic Markup）的方式将语义化的链接数据嵌入到网页中。搜索引擎自动搜集和归集这些，快速的从网页中抽取语义化的数据。提供了一个词汇本体用于描述这些语义标签。词汇本体已经包含600多个类和900多个关系，覆盖范围包括：个人、组织机构、地点、时间、医疗、商品等。本质是采用互联网众包的方式生成和收集高质量的知识图谱数据。</p></li>
<li><p>BabelNet类似于WordNet的多语言词典知识库。目标是解决WordNet在非英语语种中数据缺乏的问题。BabelNet采用将WordNet词典与Wikipedia百科集成的方法，首先建立WordNet中的词与Wikipedia的页面标题的映射，然后利用Wikipedia中的多语言链接，再辅以机器翻译技术，来给WordNet增加多种语言的词汇。BabelNet 4.0 包含了284种语言，1600万同义词组，36.4万词语关系和3.8亿从Wikipedia中抽取的链接关系，总计超过19亿RDF三元组。BabelNet集成WordNet在词语关系上的优势和Wikipedia在多语言语料方面的优势，构建成功了目前最大规模的多语言词典知识库。</p></li>
<li><p>NELL（Never-Ending Language Learner）主要采用互联网挖掘的方法从Web自动抽取三元组知识。NELL的基本理念：给定一个初始的本体（少量类和关系的定义）和少量样本，让机器能够通过自学习的方式不断的从Web学习和抽取新的知识。</p></li>
<li><p>LOD（LOD-Linked Open）实现Tim Berners-Lee在2006年发表的有关链接数据（Linked Data）作为语义网的一种实现的设想。LOD遵循了Tim提出的进行数据链接的四个规则：（1）使用URI标识万物（2）使用HTTP URI，以便用户可以（像访问网页一样）查看事物的描述（3）使用RDF和SPARQL标准（4）为事物添加与其它事物的URI链接，建立数据关联。</p></li>
</ul>
<p>知识图谱：事实的结构化表示，由实体、关系和语义描述组成。（本体是知识图谱<strong>核心</strong>和<strong>知识表示基础</strong>）</p>
<h2 id="其它">其它</h2>
<p>实体链接：将文本中的实体指称(Mention) 链向其在给定知识库中目标实体的过程。</p>
<ol type="1">
<li>实体指称识别</li>
<li>候选实体生成</li>
<li>候选实体消歧</li>
</ol>
<p>演绎推理：在给定的一个或多个前提的情况下，推断出一个必然成立的结论的过程。</p>
<p>归纳推理：基于已有的部分观察得出一般结论的过程。</p>
<ul>
<li>溯因推理：给定一个或多个已有观察事实 O (Observation)，并根据已有的知识 T(Theory) 推断出对已有观察最简单且最有可能的解释 E 的过程。</li>
</ul>
<p>知识融合：建立异构本体或异构实例之间的联系，使异构的知识图谱能相互沟通，实现它们之间的互操作，是解决知识图谱异构问题的有效途径 。</p>
<p>问答系统应具备的四大要素：</p>
<ol type="1">
<li>问题，问答系统的输入，问句、选择题、多选题、列举答案题和填空题等形式；</li>
<li>答案，问答系统的输出，文本表示的答案，一组答案、候选答案的选择、多媒体信息；</li>
<li>智能体，问答系统的执行者，理解问题的语义，使用知识库解答问题，生成人可读的答案；</li>
<li>知识库，存储了问答系统的知识，其形态可以是文本、数据库、知识图谱或者是逻辑规则、机器学习模型。</li>
</ol>
<p>本体映射：寻找本体间的映射规则。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-01-14T16:00:00.000Z" itemprop="datePublished">2022/01/15</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KR/" rel="tag">KR</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-Neo4j快速入门"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/Neo4j%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">Neo4j快速入门</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="写在最开始">0. 写在最开始</h2>
<p>本教程写于 2021.11.3 ，采用的Neo4j版本为 4.3.6 社区版，采用的教程为官方文档 v4.3 ，学习本教程请注意时效性。若与您学习时版本内容出现冲突，请以您学习版本的官网文档内容为准！</p>
<p>以下Neo4j相关的所有内容皆来自neo4j官方网站，本快速入门教程只截取了部分内容，完整内容请根据需求前往官网自行学习。下面列出部分常用网址，供快速访问：</p>
<p>Neo4j官网：https://neo4j.com/</p>
<ul>
<li><p>Neo4j Download (community)：https://neo4j.com/download-center/#community</p></li>
<li><p>Neo4j Documentation：https://neo4j.com/docs/</p>
<ul>
<li>Getting Started Guide：https://neo4j.com/docs/getting-started/current/</li>
<li>Operations Manual：https://neo4j.com/docs/operations-manual/current/</li>
<li>Cypher Manual：https://neo4j.com/docs/cypher-manual/current/</li>
<li>Cypher Refcard：https://neo4j.com/docs/cypher-refcard/current/</li>
</ul></li>
</ul>
<h2 id="简介">1. 简介</h2>
<p>随着社交、电商、金融、零售、物联网等行业的快速发展，现实社会织起了了一张庞大而复杂的关系网，传统数据库很难处理关系运算。大数据行业需要处理的数据之间的关系随数据量呈几何级数增长，亟需一种支持海量复杂数据关系运算的数据库，图数据库应运而生。</p>
<p>世界上很多著名的公司都在使用图数据库。比如：</p>
<ul>
<li><strong>社交领域</strong>：Facebook, Twitter，Linkedin用它来管理社交关系，实现好友推荐</li>
<li><strong>零售领域</strong>：eBay，沃尔玛使用它实现商品实时推荐，给买家更好的购物体验</li>
<li><strong>金融领域</strong>：摩根大通，花旗和瑞银等银行在用图数据库做风控处理</li>
<li><strong>汽车制造领域</strong>：沃尔沃，戴姆勒和丰田等顶级汽车制造商依靠图数据库推动创新制造解决方案</li>
<li><strong>电信领域</strong>：Verizon, Orange和AT&amp;T 等电信公司依靠图数据库来管理网络，控制访问并支持客户360</li>
<li><strong>酒店领域</strong>：万豪和雅高酒店等顶级酒店公司依使用图数据库来管理复杂且快速变化的库存</li>
</ul>
<h3 id="graph-database-concepts-图数据库概念">1.1. Graph database concepts 图数据库概念</h3>
<p>Neo4j uses a <em>property graph</em> database model.</p>
<p>A graph data structure consists of <strong>nodes</strong> (discrete objects) that can be connected by <strong>relationships</strong>.</p>
<blockquote>
<h6 id="example-1.-concept-of-a-graph-structure">Example 1. Concept of a graph structure</h6>
<p>A graph with three nodes (the circles) and three relationships (the arrows).</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/graph_concept_three_nodes.svg" alt="graph concept three nodes" /><figcaption aria-hidden="true">graph concept three nodes</figcaption>
</figure>
</blockquote>
<p>The Neo4j property graph database model consists of:</p>
<ul>
<li><strong>Nodes</strong> describe entities (discrete objects) of a domain.</li>
<li><strong>Nodes</strong> can have zero or more <strong>labels</strong> to define (classify) what kind of nodes they are.</li>
<li><strong>Relationships</strong> describes a connection between a <em>source node</em> and a <em>target node</em>.</li>
<li><strong>Relationships</strong> always has a direction (one direction).</li>
<li><strong>Relationships</strong> must have a <strong>type</strong> (one type) to define (classify) what type of relationship they are.</li>
<li>Nodes and relationships can have <strong>properties</strong> (key-value pairs), which further describe them.</li>
</ul>
<blockquote>
<p>In mathematics, graph theory is the study of graphs.</p>
<p>In graph therory:</p>
<ul>
<li>Nodes are also refered to as vertices or points.</li>
<li>Relationships are also refered to as edges, links, or lines.</li>
</ul>
</blockquote>
<h4 id="example-graph-示例图">1.1.1. Example graph 示例图</h4>
<p>The example graph shown below, introduces the basic concepts of the property graph:</p>
<blockquote>
<p>Example 2. Example graph.</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/graph_simple.svg" alt="graph simple" /><figcaption aria-hidden="true">graph simple</figcaption>
</figure>
</blockquote>
<blockquote>
<p>Example 3. Cypher.</p>
<p>To create the example graph, use the Cypher clause <code>CREATE</code>.</p>
<pre class="cypher"><code>CREATE (:Person:Actor &#123;name: &#39;Tom Hanks&#39;, born: 1956&#125;)-[:ACTED_IN &#123;roles: [&#39;Forrest&#39;]&#125;]-&gt;(:Movie &#123;title: &#39;Forrest Gump&#39;&#125;)&lt;-[:DIRECTED]-(:Person &#123;name: &#39;Robert Zemeckis&#39;, born: 1951&#125;)</code></pre>
</blockquote>
<h4 id="node-节点">1.1.2. Node 节点</h4>
<p>Nodes are used to represent <em>entities</em> (discrete objects) of a domain.</p>
<p>The simplest possible graph is a single node with no relationships. Consider the following graph, consisting of a single node.</p>
<blockquote>
<p>Example 4. Node.</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/graph_single_node.svg" alt="graph single node" /><figcaption aria-hidden="true">graph single node</figcaption>
</figure>
<p>The node labels are:</p>
<ul>
<li><code>Person</code></li>
<li><code>Actor</code></li>
</ul>
<p>The properties are:</p>
<ul>
<li><code>name: Tom Hanks</code></li>
<li><code>born: 1956</code></li>
</ul>
<p>The node can be created with Cypher using the query:</p>
<pre class="cypher"><code>CREATE (:Person:Actor &#123;name: &#39;Tom Hanks&#39;, born: 1956&#125;)</code></pre>
</blockquote>
<h4 id="node-labels-节点标签">1.1.3. Node labels 节点标签</h4>
<p>Labels shape the domain by grouping (classifying) nodes into sets where all nodes with a certain label belong to the same set.</p>
<p>For example, all nodes representing users could be labeled with the label <code>User</code>. With that in place, you can ask Neo4j to perform operations only on your user nodes, such as finding all users with a given name.</p>
<p>Since labels can be added and removed during runtime, they can also be used to mark temporary states for nodes. A <code>Suspended</code> label could be used to denote bank accounts that are suspended, and a <code>Seasonal</code> label can denote vegetables that are currently in season.</p>
<p>A node can have zero to many labels.</p>
<p>In the example graph, the node labels, <code>Person</code>, <code>Actor</code>, and <code>Movie</code>, are used to describe (classify) the nodes. More labels can be added to express different dimensions of the data.</p>
<p>The following graph shows the use of multiple labels.</p>
<blockquote>
<h6 id="example-5.-multiple-labels.">Example 5. Multiple labels.</h6>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/graphdb-simple-labels-multi.svg" alt="graphdb simple labels multi" /><figcaption aria-hidden="true">graphdb simple labels multi</figcaption>
</figure>
</blockquote>
<h4 id="relationship-关系">1.1.4. Relationship 关系</h4>
<p>A relationship describes how a connection between a <em>source node</em> and a <em>target node</em> are related. It is possible for a node to have a relationship to itself.</p>
<p>A relationship:</p>
<ul>
<li>Connects a <em>source node</em> and a <em>target node</em>.</li>
<li>Has a direction (one direction).</li>
<li>Must have a <strong>type</strong> (one type) to define (classify) what type of relationship it is.</li>
<li>Can have properties (key-value pairs), which further describe the relationship.</li>
</ul>
<p>Relationships organize nodes into structures, allowing a graph to resemble a list, a tree, a map, or a compound entity — any of which may be combined into yet more complex, richly inter-connected structures.</p>
<blockquote>
<h6 id="example-6.-relationship.">Example 6. Relationship.</h6>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/graph_example_relationship.svg" alt="graph example relationship" /><figcaption aria-hidden="true">graph example relationship</figcaption>
</figure>
</blockquote>
<p>The node type: <code>ACTED_IN</code></p>
<p>The properties are:</p>
<ul>
<li><code>roles: ['Forrest']</code></li>
<li><code>performance: 5</code></li>
</ul>
<p>The <code>roles</code> property has an array value with a single item (<code>'Forrest'</code>) in it.</p>
<p>The relationship can be created with Cypher using the query:</p>
<pre class="cypher"><code>CREATE ()-[:ACTED_IN &#123;roles: [&#39;Forrest&#39;], performance: 5&#125;]-&gt;()</code></pre>
<p>You must create or reference a <em>source node</em> and a <em>target node</em> to be able to create a relationship.</p>
<p>Relationships always have a direction. However, the direction can be disregarded where it is not useful. This means that there is no need to add duplicate relationships in the opposite direction unless it is needed to describe the data model properly.</p>
<p>A node can have relationships to itself. To express that <code>Tom Hanks</code> <code>KNOWS</code> himself would be expressed as:</p>
<blockquote>
<h6 id="example-7.-relationship-to-a-single-node.">Example 7. Relationship to a single node.</h6>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/graphdb-nodes-and-rel-self.svg" alt="graphdb nodes and rel self" /><figcaption aria-hidden="true">graphdb nodes and rel self</figcaption>
</figure>
</blockquote>
<h4 id="relationship-type-关系类型">1.1.5. Relationship type 关系类型</h4>
<p>A relationship must have exactly one relationship type.</p>
<p>Below is an <code>ACTED_IN</code> relationship, with the <code>Tom Hanks</code> node as the <em>source node</em> and <code>Forrest Gump</code> as the <em>target node</em>.</p>
<blockquote>
<h6 id="example-8.-relationship-type.">Example 8. Relationship type.</h6>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/graphdb-nodes-and-rel.svg" alt="graphdb nodes and rel" /><figcaption aria-hidden="true">graphdb nodes and rel</figcaption>
</figure>
</blockquote>
<p>Observe that the <code>Tom Hanks</code> node has an <em>outgoing</em> relationship, while the <code>Forrest Gump</code> node has an <em>incoming</em> relationship.</p>
<h4 id="properties-属性">1.1.6. Properties 属性</h4>
<p>Properties are key-value pairs that are used for storing data on nodes and relationships.</p>
<p>The value part of a property:</p>
<ul>
<li>Can hold different data types, such as <code>number</code>, <code>string</code>, or <code>boolean</code>.</li>
<li>Can hold a homogeneous list (array) containing, for example, strings, numbers, or boolean values.</li>
</ul>
<blockquote>
<h6 id="example-9.-number">Example 9. Number</h6>
<pre class="cypher"><code>CREATE (:Example &#123;a: 1, b: 3.14&#125;)</code></pre>
<ul>
<li>The property <code>a</code> has the type <code>integer</code> with the value <code>1</code>.</li>
<li>The property <code>b</code> has the type <code>float</code> with the value <code>3.14</code>.</li>
</ul>
</blockquote>
<blockquote>
<h6 id="example-10.-string-and-boolean">Example 10. String and boolean</h6>
<pre class="cypher"><code>CREATE (:Example &#123;c: &#39;This is an example string&#39;, d: true, e: false&#125;)</code></pre>
<ul>
<li>The property <code>c</code> has the type <code>string</code> with the value <code>'This is an example string'</code>.</li>
<li>The property <code>d</code> has the type <code>boolean</code> with the value <code>true</code>.</li>
<li>The property <code>e</code> has the type <code>boolean</code> with the value <code>false</code>.</li>
</ul>
</blockquote>
<blockquote>
<h6 id="example-11.-lists">Example 11. Lists</h6>
<pre class="cypher"><code>CREATE (:Example &#123;f: [1, 2, 3], g: [2.71, 3.14], h: [&#39;abc&#39;, &#39;example&#39;], i: [true, true, false]&#125;)</code></pre>
<ul>
<li>The property <code>f</code> contains an array with the value <code>[1, 2, 3]</code>.</li>
<li>The property <code>g</code> contains an array with the value <code>[2.71, 3.14]</code>.</li>
<li>The property <code>h</code> contains an array with the value <code>['abc', 'example']</code>.</li>
<li>The property <code>i</code> contains an array with the value <code>[true, true, false]</code>.</li>
</ul>
</blockquote>
<h4 id="traversals-and-paths-遍历和路径">1.1.7. Traversals and paths 遍历和路径</h4>
<p>A traversal is how you query a graph in order to find answers to questions, for example: "What music do my friends like that I don’t yet own?", or "What web services are affected if this power supply goes down?".</p>
<p>Traversing a graph means visiting nodes by following relationships according to some rules. In most cases only a subset of the graph is visited.</p>
<blockquote>
<h6 id="example-12.-path-matching.">Example 12. Path matching.</h6>
<p>To find out which movies Tom Hanks acted in according to the tiny example database, the traversal would start from the <code>Tom Hanks</code> node, follow any <code>ACTED_IN</code> relationships connected to the node, and end up with <code>Forrest Gump</code> as the result (see the dashed lines):</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/graphdb-traversal.svg" alt="graphdb traversal" /><figcaption aria-hidden="true">graphdb traversal</figcaption>
</figure>
<p>The traversal result could be returned as a path with the length <code>1</code>:</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/graphdb-path.svg" alt="graphdb path" /><figcaption aria-hidden="true">graphdb path</figcaption>
</figure>
</blockquote>
<p>The shortest possible path has length zero. It contains a single node and no relationships.</p>
<blockquote>
<h6 id="example-13.-path-of-length-zero.">Example 13. Path of length zero.</h6>
<p>A path containing only a single node has the length of <code>0</code>.</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/graphdb-path-zero.svg" alt="graphdb path zero" /><figcaption aria-hidden="true">graphdb path zero</figcaption>
</figure>
</blockquote>
<blockquote>
<h6 id="example-14.-path-of-length-one.">Example 14. Path of length one.</h6>
<p>A path containing one relationship has the length of <code>1</code>.</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/graphdb-path-example-loop.svg" alt="graphdb path example loop" /><figcaption aria-hidden="true">graphdb path example loop</figcaption>
</figure>
</blockquote>
<h4 id="schema-架构">1.1.8. Schema 架构</h4>
<p>A <em>schema</em> in Neo4j refers to indexes and constraints.</p>
<p>Neo4j is often described as <em>schema optional</em>, meaning that it is not necessary to create indexes and constraints. You can create data — nodes, relationships and properties — without defining a schema up front. Indexes and constraints can be introduced when desired, in order to gain performance or modeling benefits.</p>
<h4 id="indexes-索引">1.1.9. Indexes 索引</h4>
<p>Indexes are used to increase performance.</p>
<h4 id="constraints-约束">1.1.10. Constraints 约束</h4>
<p>Constraints are used to make sure that the data adheres to the rules of the domain.</p>
<h4 id="naming-conventions-命名规范">1.1.11. Naming conventions 命名规范</h4>
<p>Node labels, relationship types, and properties (the key part) are case sensitive, meaning, for example, that the property <code>name</code> is different from the property <code>Name</code>.</p>
<p>The following naming conventions are recommended:</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 47%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th>Graph entity</th>
<th>Recommended style</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Node label</td>
<td>Camel case, beginning with an upper-case character</td>
<td><code>:VehicleOwner</code> rather than <code>:vehice_owner</code></td>
</tr>
<tr class="even">
<td>Relationship type</td>
<td>Upper case, using underscore to separate words</td>
<td><code>:OWNS_VEHICLE</code> rather than <code>:ownsVehicle</code></td>
</tr>
<tr class="odd">
<td>Property</td>
<td>Lower camel case, beginning with a lower-case character</td>
<td><code>firstName</code> rather than <code>first_name</code></td>
</tr>
</tbody>
</table>
<h3 id="图数据库的横纵对比">1.2. 图数据库的横纵对比</h3>
<p>我们为什么要选择图数据库？它和其它数据库相比，优势在哪，劣势又在哪？通过《Neo4j IN ACTION》中的一个例子来了解一下。</p>
<h4 id="对比关系型数据库">1.2.1. 对比关系型数据库</h4>
<p>The example we’re going to explore is a social network—a set of users who can be friends with each other. Figure 1.1 illustrates the social network, where users connected with arrows are friends.</p>
<blockquote>
<h6 id="figure-users-and-their-friends-represented-as-a-graph-data-structure">Figure: Users and their friends represented as a graph data structure</h6>
<p><img src="\f1.png" alt="f1" style="zoom: 80%;" /></p>
</blockquote>
<h5 id="graph-data-in-a-relational-database">1.2.1.1. Graph data in a relational database</h5>
<p>In a relational database, you’d typically have two relational tables for storing social network data: one for user information, and another for the relationships between users.</p>
<blockquote>
<p>Figure: SQL diagram of tables representing user and friend data</p>
<p><img src="\f2.png" alt="f2" style="zoom:80%;" /></p>
</blockquote>
<p>The following listing shows the SQL script for creating tables using a MySQL database.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">create</span> <span class="kw">table</span> t_user ( </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">id</span> bigint <span class="kw">not</span> <span class="kw">null</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a> name <span class="dt">varchar</span>(<span class="dv">255</span>) <span class="kw">not</span> <span class="kw">null</span>,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">primary</span> <span class="kw">key</span> (<span class="kw">id</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
<p>Table definition for storing friendship relations</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">create</span> <span class="kw">table</span> t_user_friend ( </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">id</span> bigint <span class="kw">not</span> <span class="kw">null</span>,</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a> user_1 bigint <span class="kw">not</span> <span class="kw">null</span>,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a> user_2 bigint <span class="kw">not</span> <span class="kw">null</span>,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">primary</span> <span class="kw">key</span> (<span class="kw">id</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
<p>Foreign key constraints</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">alter</span> <span class="kw">table</span> t_user_friend </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">add</span> <span class="kw">index</span> FK416055ABC6132571 (user_1), </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">add</span> <span class="kw">constraint</span> FK416055ABC6132571 </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">foreign</span> <span class="kw">key</span> (user_1) <span class="kw">references</span> t_user (<span class="kw">id</span>); </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">alter</span> <span class="kw">table</span> t_user_friend </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">add</span> <span class="kw">index</span> FK416055ABC6132572 (user_2), </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">add</span> <span class="kw">constraint</span> FK416055ABC6132572 </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">foreign</span> <span class="kw">key</span> (user_2) <span class="kw">references</span> t_user (<span class="kw">id</span>); </span></code></pre></div>
<p>Table t_user contains columns with user information, while table t_user_friend simply has two columns referencing table t_user using a foreign key relation. The primary key and foreign key columns have indexes for quicker lookup operations, a strategy typically employed when modeling relational databases.</p>
<h5 id="querying-graph-data-using-mysql">1.2.1.2. Querying graph data using MySQL</h5>
<p>How would you go about querying relational data? Getting the count for direct friends of a particular user is quite straightforward. A basic select query such as the following would do the trick:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">select</span> <span class="fu">count</span>(<span class="kw">distinct</span> uf.<span class="op">*</span>) <span class="kw">from</span> t_user_friend uf <span class="kw">where</span> uf.user_1 <span class="op">=</span> ?</span></code></pre></div>
<p>How about finding all friends of a user’s friends? This time you’d typically join the t_user_friend table with itself before querying:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">select</span> <span class="fu">count</span>(<span class="kw">distinct</span> uf2.<span class="op">*</span>) <span class="kw">from</span> t_user_friend uf1</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inner</span> <span class="kw">join</span> t_user_friend uf2 <span class="kw">on</span> uf1.user_1 <span class="op">=</span> uf2.user_2</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span> uf1.user_1 <span class="op">=</span> ?</span></code></pre></div>
<p>Popular social networks usually have a feature where they suggest people from your friendship network as potential friends or contacts, up to a certain degree of separation, or depth. If you wanted to do something similar to find friends of friends of friends of a user, you’d need another join operation:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">select</span> <span class="fu">count</span>(<span class="kw">distinct</span> uf3.<span class="op">*</span>) <span class="kw">from</span> t_user_friend uf1</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">inner</span> <span class="kw">join</span> t_user_friend uf2 <span class="kw">on</span> uf1.user_1 <span class="op">=</span> uf2.user_2</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">inner</span> <span class="kw">join</span> t_user_friend uf3 <span class="kw">on</span> uf2.user_1 <span class="op">=</span> uf3.user_2</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span> uf1.user_1 <span class="op">=</span> ?</span></code></pre></div>
<p>Similarly, to iterate through a fourth level of friendship, you’d need four joins. To get all connections for the famous six degrees of separation problem, six joins would be required.</p>
<p>There’s nothing unusual about this approach, but there’s one potential problem: although you’re only interested in friends of friends of a single user, you have to perform a join of all data in the t_user_friend table, and then discard all rows that you’re not interested in. On a small data set, this wouldn’t be a big concern, but if your social network grows large, you could start running into serious performance problems. As you’ll see, this can put a huge strain on your relational database engine.</p>
<p>To illustrate the performance of such queries, we ran the friends-of-friends query a few times against a small data set of 1,000 users, but increased the depth of the search with each invocation and recorded the results each time. On a small data set of 1,000 users, where each user has on average 50 friends, table t_user contains 1,000 records, whereas table t_user_friend contains 1,000 u 50 = 50,000 records.</p>
<p>At each depth, we ran the query 10 times—this was simply to warm up any caches that could help with performance. The fastest execution time for each depth was recorded. No additional database performance tuning was performed, apart from column indexes defined in the SQL script from above. Table below shows the results of the experiment.</p>
<blockquote>
<h6 id="table-execution-times-for-multiple-join-queries-using-a-mysql-database-engine-on-a-data-set-of-1000-users">Table: Execution times for multiple join queries using a MySQL database engine on a data set of 1,000 users</h6>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Depth</th>
<th>Execution time (seconds) for 1,000 users</th>
<th>Count result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">2</td>
<td>0.028</td>
<td>~900</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td>0.213</td>
<td>~999</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td>10.273</td>
<td>~999</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td>92.613</td>
<td>~999</td>
</tr>
</tbody>
</table>
</blockquote>
<p>As you can see, MySQL handles queries to depths 2 and 3 quite well. That’s not unexpected—<code>join</code> operations are common in the relational world, so most database engines are designed and tuned with this in mind. The use of database indexes on the relevant columns also helped the relational database to maximize its performance of these <code>join</code> queries.</p>
<p>At depths 4 and 5, however, you see a significant degradation of performance: a query involving 4 joins takes over 10 seconds to execute, while at depth 5, execution takes way too long—over a minute and a half, although the count result doesn’t change. This illustrates the limitation of MySQL when modeling graph data: deep graphs require multiple joins, which relational databases typically don’t handle too well.</p>
<p>In a word, relational databases are not so great for modeling many-to-many relationships, especially in large data sets. Neo4j, on the other hand, excels at many-to-many relationships, so let’s take a look at how it performs with the same data set. Instead of tables, columns, and foreign keys, you’re going to model users as nodes, and friendships as relationships between nodes.</p>
<h5 id="graph-data-in-neo4j">1.2.1.3. Graph data in Neo4j</h5>
<p>跳过怎么在Neo4j中储存这些数据，之后会提到</p>
<p>Neo4j stores data as vertices and edges, or, in Neo4j terminology, <em>nodes</em> and <em>relationships</em>. Users will be represented as nodes, and friendships will be represented as relationships between user nodes. If you take another look at the social network in figure in 1.2.1, you’ll see that it represents nothing more than a graph, with users as nodes and friendship arrows as relationships.</p>
<p>There’s one key difference between relational and Neo4j databases, which you’ll come across right away: data querying. There are no tables and columns in Neo4j, nor are there any SQL-based <code>select</code> and <code>join</code> commands. So how do you query a graph database?</p>
<p>The answer is not “write a distributed MapReduce function.” Neo4j, like all graph databases, takes a powerful mathematical concept from graph theory and uses it as a powerful and efficient engine for querying data. This concept is <em>graph traversal</em>, and it’s one of the main tools that makes Neo4j so powerful for dealing with large-scale graph data.</p>
<h5 id="traversing-the-graph">1.2.1.4. Traversing the graph</h5>
<p>跳过怎么查询的，之后会提到，直接看查询结果</p>
<blockquote>
<h6 id="table-the-execution-times-for-graph-traversal-using-neo4j-on-a-data-set-of-1000-users">Table: The execution times for graph traversal using Neo4j on a data set of 1,000 users</h6>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Depth</th>
<th>Execution time (seconds) for 1,000 users</th>
<th>Count result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">2</td>
<td>0.04</td>
<td>~900</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td>0.06</td>
<td>~999</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td>0.07</td>
<td>~999</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td>0.07</td>
<td>~999</td>
</tr>
</tbody>
</table>
</blockquote>
<p>The first thing to notice is that the Neo4j performance is significantly better for all queries, except the simplest one. Only when looking for friends of friends (at depth 2) is the MySQL performance comparable to the performance of a Neo4j traversal. The traversal of friends at depth 3 is four times faster than the MySQL counterpart. When performing a traversal at depth 4, the results are five orders of magnitude better. The depth 5 results are 10 million times faster for the Neo4j traversal compared to the MySQL query!</p>
<p>Another conclusion is that the performance of the query degrades only slightly with the depth of the traversal when the count of nodes returned remains the same. The MySQL query performance degrades with the depth of the query because of the Cartesian product operations that are executed before most of the results are discarded. Neo4j keeps track of the nodes visited, so it can skip nodes it’s visited before and therefore significantly improve performance.</p>
<p>To find all friends at depth 5, MySQL will perform a Cartesian product on the t_user_friend table five times, resulting in 50,0005 records, out of which all but 1,000 are discarded. Neo4j will simply visit nodes in the database, and when there are no more nodes to visit, it will stop the traversal. That is why Neo4j can maintain constant performance as long as the number of nodes returned remains the same, whereas there’s a significant degradation in performance when using MySQL queries.</p>
<h5 id="sql-joins-versus-graph-traversal-on-a-large-scale">1.2.1.5. SQL joins versus graph traversal on a large scale</h5>
<p>But how does this graphing approach scale? To get the answer, let’s repeat the experiment with a data set of 1 million users.</p>
<p>In MySQL we had 1,000,000 records in the t_user table, and approximately 1,000,000 × 50 = 50,000,000 records in the t_user_friend table. We ran the same four queries against this data set (friends at depths 2, 3, 4, and 5). Table below shows the collected results for the performance of SQL queries in this case.</p>
<blockquote>
<h6 id="table-the-execution-times-for-multiple-join-queries-using-a-mysql-database-engine-on-a-data-set-of-1-million-users">Table: The execution times for multiple join queries using a MySQL database engine on a data set of 1 million users</h6>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Depth</th>
<th>Execution time (seconds) for 1 million users</th>
<th>Count result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">2</td>
<td>0.016</td>
<td>~2,500</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td>30.267</td>
<td>~125,000</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td>1,543.505</td>
<td>~600,000</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td>Not finished</td>
<td>—</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Comparing these results to the MySQL results for a data set of 1,000 users, you can see that the performance of the depth 2 query has stayed the same, which can be explained by the design of the MySQL engine handling table joins efficiently using indexes. Queries at depths 3 and 4 (which use 3 and 4 <code>join</code> operations, respectively) demonstrate much worse results, by at least two orders of magnitude. The SQL query for all friends at depth 5 did not finish in the hour we ran the script.</p>
<p>These results clearly show that the MySQL relational database is optimized for single <code>join</code> queries, even on large data sets. The performance of multiple <code>join</code> queries on large data sets degrades significantly, to the point that some queries are not even executable (for example, friends at depth 5 for a data set of 1 million users).</p>
<blockquote>
<h6 id="why-are-relational-database-queries-so-slow">Why are relational database queries so slow?</h6>
<p>The results in table 1.3 are somewhat expected, given the way <code>join</code> operations work. As we discussed earlier, each <code>join</code> creates a Cartesian product of all potential combinations of rows, then filters out those that don’t match the <code>where</code> clause. With 1 million users, the Cartesian product of 5 joins (equivalent to a query at depth 5) contains a huge number of rows—billions. Way too many zeros to be readable. Filtering out all the records that don’t match the query is too expensive, such that the SQL query at depth 5 never finishes in a reasonable time.</p>
</blockquote>
<p>We repeated the same experiment with Neo4j traversals. We had 1 million nodes representing users, and approximately 50 million relationships stored in Neo4j. We ran the same four traversals as in the previous example, and we got the performance results in table below.</p>
<blockquote>
<h6 id="table-the-execution-times-for-graph-traversal-using-neo4j-on-a-data-set-of-1-million-users">Table: The execution times for graph traversal using Neo4j on a data set of 1 million users</h6>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Depth</th>
<th>Execution time (seconds) for 1 million users</th>
<th>Count result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">2</td>
<td>0.01</td>
<td>~2,500</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td>0.168</td>
<td>~125,000</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td>1.359</td>
<td>~600,000</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td>2.132</td>
<td>~800,000</td>
</tr>
</tbody>
</table>
</blockquote>
<p>As you can see, the increase in data by a thousand times didn’t significantly affect Neo4j’s performance. The traversal does get slower as you increase the depth, but the main reason for that is the increased number of results that are returned. The performance slows linearly with the increase of the result size, and it’s predictable even with a larger data set and depth level. In addition, this is at least a hundred times better than the corresponding MySQL performance.</p>
<p>The main reason for Neo4j’s predictability is the localized nature of the graph traversal; irrespective of how many nodes and relationships are in the graph, the traversal will only visit ones that are connected to the starting node, according to the traversal rules. Remember, relational join operations compute the Cartesian product before discarding irrelevant results, affecting performance exponentially with the growth of the data set. Neo4j, however, only visits nodes that are relevant to the traversal, so it’s able to maintain predictable performance regardless of the total data set size. The more nodes the traversal has to visit, the slower the traversal, as you’ve seen while increasing the traversal depth. But this increase is linear and is still independent of the total graph size.</p>
<p>These experiments demonstrate that the Neo4j graph database is significantly faster in querying graph data than using a relational database. In addition, a single Neo4j instance can handle data sets of three orders of magnitude without performance penalties. The independence of traversal performance on graph size is one of the key aspects that make Neo4j an ideal candidate for solving graph problems, even when data sets are very large.</p>
<h4 id="对比其它非关系型数据库">1.2.2. 对比其它非关系型数据库</h4>
<p><img src="\f3.png" alt="f3" style="zoom:50%;" /></p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 42%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th>NoSQL category</th>
<th>Typical use cases</th>
<th>Best-known technologies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Key-value stores</td>
<td>■ Caches<br/>■ Simple domain with fast read access<br/>■ Massively concurrent systems</td>
<td>■ Redis<br/>■ Memcached<br/>■ Tokyo Cabinet</td>
</tr>
<tr class="even">
<td>Column-family stores</td>
<td>■ Write on a big scale <br/>■ Collocated data access (for reading and writing)</td>
<td>■ Cassandra <br/>■ Google BigTable<br/>■ Apache HBase</td>
</tr>
<tr class="odd">
<td>Document-oriented databases</td>
<td>■ When domain model is a document by nature<br/>■ To simplify development using natural document data structures<br/>■ Highly scalable systems (although on a lower level than the key-value and column family stores)</td>
<td>■ MongoDB<br/>■ CouchDB</td>
</tr>
<tr class="even">
<td>Graph databases</td>
<td>■ With interconnected data<br/>■ Domain can be represented with nodes and relationships naturally<br/>■ Social networks<br/>■ Recommendation engines<br/>■ Access control lists</td>
<td>■ Neo4j<br/>■ AllegroGraph<br/>■ OrientDB</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 35%" />
<col style="width: 31%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th>分类</th>
<th>数据模型</th>
<th>优势</th>
<th>劣势</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>键值数据库</td>
<td>哈希表</td>
<td>查找速度快</td>
<td>数据无结构化，通常只被当作字符串或者二进制数据</td>
<td>Redis</td>
</tr>
<tr class="even">
<td>列存储数据库</td>
<td>列式数据存储</td>
<td>查找速度快；支持分布横向扩展；数据压缩率高</td>
<td>功能相对受限</td>
<td>HBase</td>
</tr>
<tr class="odd">
<td>文档型数据库</td>
<td>键值对扩展</td>
<td>数据结构要求不严格；表结构可变；不需要预先定义表结构</td>
<td>查询性能不高，缺乏统一的查询语法</td>
<td>MongoDB</td>
</tr>
<tr class="even">
<td>图数据库</td>
<td>节点和关系组成的图</td>
<td>利用图结构相关算法(最短路径、节点度关系查找等)</td>
<td>可能需要对整个图做计算，不利于图数据分布存储</td>
<td>Neo4j、JanusGraph</td>
</tr>
</tbody>
</table>
<h4 id="总结">1.2.3. 总结</h4>
<p>优点：</p>
<ol type="1">
<li>数据的插入，查询操作很直观，不用再像之前要考虑各个表之间的关系。</li>
<li>提供的图搜索和图遍历方法很方便，速度也是比较快的。</li>
<li>更快的数据库操作。当然，有一个前提条件，那就是数据量较大，在MySql中存储的话需要许多表，并且表之间联系较多（即有不少的操作需要join表）。</li>
</ol>
<p>缺点：</p>
<ol type="1">
<li>当数据过大时插入速度可能会越来越慢。.</li>
<li>超大节点。当有一个节点的边非常多时（常见于大V），有关这个节点的操作的速度将大大下降。这个问题很早就有了，官方也说过会处理，然而现在仍然不能让人满意。</li>
<li>提高数据库速度的常用方法就是多分配内存，然而看了官方操作手册，貌似无法直接设置数据库内存占用量，而是需要计算后为其”预留“内存…</li>
</ol>
<blockquote>
<p>鉴于其明显的优缺点，Neo4j适合存储“修改较少，查询较多，没有超大节点”的图数据。</p>
</blockquote>
<h2 id="安装配置运行">2. 安装&amp;配置&amp;运行</h2>
<h3 id="安装">2.1. 安装</h3>
<p>Download the latest release from <a target="_blank" rel="noopener" href="https://neo4j.com/download-center/">Neo4j Download Center</a>.</p>
<p>Select the appropriate ZIP distribution.</p>
<p>下载社区版（Community）</p>
<p>Right-click the downloaded file, click Extract All.</p>
<h3 id="配置">2.2. 配置</h3>
<p>添加环境变量Path：%你的解压路径%4j-community-4.3.6</p>
<p>用文本编辑器打开目录 %你的解压路径%4j-community-4.3.64j.conf，找到下方所示的两行代码，去掉第二行开头的#，修改参数能够切换不同的数据库（社区版不能在Neo4j Browser中切换数据库，只能通过修改配置文件完成切换）</p>
<pre><code># The name of the default database
dbms.default_database=&lt;your database name&gt;</code></pre>
<h3 id="运行">2.3. 运行</h3>
<p>由于我们已经配置了环境变量，直接在cmd中输入neo4j console，输出</p>
<pre><code>Neo4j is already running.</code></pre>
<blockquote>
<p>Stop the server by typing <code>Ctrl-C</code> in the console.</p>
</blockquote>
<p>然后在浏览器中输入localhost:7474访问Neo4j Browser</p>
<blockquote>
<p>The default user name is <code>neo4j</code> and password <code>neo4j</code>.</p>
</blockquote>
<p>若修改了配置文件，需要通过重启应用来使配置生效，在cmd中输入neo4j restart，并刷新浏览器</p>
<h2 id="cypher介绍">3. Cypher介绍</h2>
<h3 id="什么是cypher">3.1. 什么是Cypher</h3>
<p>Cypher is a declarative graph query language that allows for expressive and efficient <a target="_blank" rel="noopener" href="https://neo4j.com/docs/cypher-manual/4.1/introduction/quering-updating-administering/">querying, updating and administering</a> of the graph. It is designed to be suitable for both developers and operations professionals. Cypher is designed to be simple, yet powerful; highly complicated database queries can be easily expressed, enabling you to focus on your domain, instead of getting lost in database access.</p>
<p>Cypher is inspired by a number of different approaches and builds on established practices for expressive querying. Many of the keywords, such as <code>WHERE</code> and <code>ORDER BY</code>, are inspired by <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/SQL">SQL</a>. Pattern matching borrows expression approaches from <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/SPARQL">SPARQL</a>. Some of the list semantics are borrowed from languages such as Haskell and Python. Cypher’s constructs, based on English prose and neat iconography, make queries easy, both to write and to read.</p>
<p><strong>Structure</strong></p>
<p>Cypher borrows its structure from SQL — queries are built up using various clauses.</p>
<p>Clauses are chained together, and they feed intermediate result sets between each other. For example, the matching variables from one <code>MATCH</code> clause will be the context that the next clause exists in.</p>
<p>The query language is comprised of several distinct clauses. These are discussed in more detail in the chapter on <a target="_blank" rel="noopener" href="https://neo4j.com/docs/cypher-manual/4.1/clauses/">Clauses</a>.</p>
<p>The following are a few examples of clauses used to read from the graph:</p>
<ul>
<li><code>MATCH</code>: The graph pattern to match. This is the most common way to get data from the graph.</li>
<li><code>WHERE</code>: Not a clause in its own right, but rather part of <code>MATCH</code>, <code>OPTIONAL MATCH</code> and <code>WITH</code>. Adds constraints to a pattern, or filters the intermediate result passing through <code>WITH</code>.</li>
<li><code>RETURN</code>: What to return.</li>
</ul>
<p>Let’s see <code>MATCH</code> and <code>RETURN</code> in action.</p>
<p>Let’s create a simple example graph with the following query:</p>
<pre class="cypher"><code>CREATE (john:Person &#123;name: &#39;John&#39;&#125;)
CREATE (joe:Person &#123;name: &#39;Joe&#39;&#125;)
CREATE (steve:Person &#123;name: &#39;Steve&#39;&#125;)
CREATE (sara:Person &#123;name: &#39;Sara&#39;&#125;)
CREATE (maria:Person &#123;name: &#39;Maria&#39;&#125;)
CREATE (john)-[:FRIEND]-&gt;(joe)-[:FRIEND]-&gt;(steve)
CREATE (john)-[:FRIEND]-&gt;(sara)-[:FRIEND]-&gt;(maria)</code></pre>
<figure>
<img src="https://kroki.io/graphviz/svg/eNqtj8EKgkAQhu89xWAHT0G60iXsVEFREnV0PWztlMK2K6sFYb57q0WUBHbwNMzsfjPfz5OTZmkMKyhAKo4QZjFL0dd4UJpDlt-EadRFcuTRuAcQDCE0BUCwPQrwwSo2qDMl75Kd0fTUXqpYUpuK0jIfoyczmEBAXuRBCaUrsu8i8cjIqqdHJfPfL-9L8-1iFkypbOx1Ot_r_JERvyM6tYrbuYrbqrLL8dqQIe0Q06zJVAG8zgN4rS5rppNPmfIBKVKtCA==" alt="Diagram" /><figcaption aria-hidden="true">Diagram</figcaption>
</figure>
<p>For example, here is a query which finds a user called <strong>'John'</strong> and <strong>'John’s'</strong> friends (though not his direct friends) before returning both <strong>'John'</strong> and any friends-of-friends that are found.</p>
<pre class="cypher"><code>MATCH (john &#123;name: &#39;John&#39;&#125;)-[:FRIEND]-&gt;()-[:FRIEND]-&gt;(fof)
RETURN john.name, fof.name</code></pre>
<p>Resulting in:</p>
<pre><code>+----------------------+
| john.name | fof.name |
+----------------------+
| &quot;John&quot;    | &quot;Maria&quot;  |
| &quot;John&quot;    | &quot;Steve&quot;  |
+----------------------+
2 rows</code></pre>
<p>Next up we will add filtering to set more parts in motion:</p>
<p>We take a list of user names and find all nodes with names from this list, match their friends and return only those followed users who have a <strong>'name'</strong> property starting with <strong>'S'</strong>.</p>
<pre class="cypher"><code>MATCH (user)-[:FRIEND]-&gt;(follower)
WHERE user.name IN [&#39;Joe&#39;, &#39;John&#39;, &#39;Sara&#39;, &#39;Maria&#39;, &#39;Steve&#39;] AND follower.name =~ &#39;S.*&#39;
RETURN user.name, follower.name</code></pre>
<p>Resulting in:</p>
<pre><code>+---------------------------+
| user.name | follower.name |
+---------------------------+
| &quot;Joe&quot;     | &quot;Steve&quot;       |
| &quot;John&quot;    | &quot;Sara&quot;        |
+---------------------------+
2 rows</code></pre>
<p>And these are examples of clauses that are used to update the graph:</p>
<ul>
<li><code>CREATE</code> (and <code>DELETE</code>): Create (and delete) nodes and relationships.</li>
<li><code>SET</code> (and <code>REMOVE</code>): Set values to properties and add labels on nodes using <code>SET</code> and use <code>REMOVE</code> to remove them.</li>
<li><code>MERGE</code>: Match existing or create new nodes and patterns. This is especially useful together with unique constraints.</li>
</ul>
<h3 id="patterns-句法结构">3.2. Patterns 句法结构</h3>
<p>Neo4j’s Property Graphs are composed of nodes and relationships, either of which may have properties. Nodes represent entities, for example concepts, events, places and things. Relationships connect pairs of nodes.</p>
<p>However, nodes and relationships can be considered as low-level building blocks. The real strength of the property graph lies in its ability to encode <em>patterns</em> of connected nodes and relationships. A single node or relationship typically encodes very little information, but a pattern of nodes and relationships can encode arbitrarily complex ideas.</p>
<p>Cypher, Neo4j’s query language, is strongly based on patterns. Specifically, patterns are used to match desired graph structures. Once a matching structure has been found or created, Neo4j can use it for further processing.</p>
<p>A simple pattern, which has only a single relationship, connects a pair of nodes (or, occasionally, a node to itself). For example, <em>a Person</em> <code>LIVES_IN</code> <em>a City</em> or <em>a City is</em> <code>PART_OF</code> <em>a Country</em>.</p>
<p>Complex patterns, using multiple relationships, can express arbitrarily complex concepts and support a variety of interesting use cases. For example, we might want to match instances where <em>a Person</em> <code>LIVES_IN</code> <em>a Country</em>. The following Cypher code combines two simple patterns into a slightly more complex pattern which performs this match:</p>
<pre class="cypher"><code>(:Person) -[:LIVES_IN]-&gt; (:City) -[:PART_OF]-&gt; (:Country)</code></pre>
<p>Diagrams made up of icons and arrows are commonly used to visualize graphs. Textual annotations provide labels, define properties etc.</p>
<h4 id="node-syntax-节点语法">3.2.1. Node syntax 节点语法</h4>
<p>Cypher uses a pair of parentheses to represent a node: <code>()</code>. This is reminiscent of a circle or a rectangle with rounded end caps. Below are some examples of nodes, providing varying types and amounts of detail:</p>
<pre class="cypher"><code>()
(matrix)
(:Movie)
(matrix:Movie)
(matrix:Movie &#123;title: &#39;The Matrix&#39;&#125;)
(matrix:Movie &#123;title: &#39;The Matrix&#39;, released: 1997&#125;)</code></pre>
<p>The simplest form, <code>()</code>, represents an anonymous, uncharacterized node. If we want to refer to the node elsewhere, we can add a variable, for example: <code>(matrix)</code>. A variable is restricted to a single statement. It may have different or no meaning in another statement.</p>
<p>The <code>:Movie</code> pattern declares a label of the node. This allows us to restricts the pattern, keeping it from matching (say) a structure with an <code>Actor</code> node in this position.</p>
<p>The node’s properties, for example <code>title</code>, are represented as a list of key-value pairs, enclosed within a pair of braces, for example: <code>&#123;name: 'Keanu Reeves'&#125;</code>. Properties can be used to store information and/or restrict patterns.</p>
<h4 id="relationship-syntax-关系语法">3.2.2. Relationship syntax 关系语法</h4>
<p>Cypher uses a pair of dashes (<code>--</code>) to represent an undirected relationship. Directed relationships have an arrowhead at one end (<code>&lt;--</code>, <code>--&gt;</code>). Bracketed expressions (<code>[...]</code>) can be used to add details. This may include variables, properties, and type information:</p>
<pre class="cypher"><code>--&gt;
-[role]-&gt;
-[:ACTED_IN]-&gt;
-[role:ACTED_IN]-&gt;
-[role:ACTED_IN &#123;roles: [&#39;Neo&#39;]&#125;]-&gt;</code></pre>
<p>The syntax and semantics found within a relationship’s bracket pair are very similar to those used between a node’s parentheses. A variable (e.g., <code>role</code>) can be defined, to be used elsewhere in the statement. The relationship’s type (e.g., <code>:ACTED_IN</code>) is analogous to the node’s label. The properties (e.g., <code>roles</code>) are entirely equivalent to node properties.</p>
<h4 id="pattern-syntax-完整语法">3.2.3. Pattern syntax 完整语法</h4>
<p>Combining the syntax for nodes and relationships, we can express patterns. The following could be a simple pattern (or fact) in this domain:</p>
<pre class="cypher"><code>(keanu:Person:Actor &#123;name: &#39;Keanu Reeves&#39;&#125;)-[role:ACTED_IN &#123;roles: [&#39;Neo&#39;]&#125;]-&gt;(matrix:Movie &#123;title: &#39;The Matrix&#39;&#125;)</code></pre>
<p>Equivalent to node labels, the <code>:ACTED_IN</code> pattern declares the relationship type of the relationship. Variables (e.g., <code>role</code>) can be used elsewhere in the statement to refer to the relationship.</p>
<p>As with node properties, relationship properties are represented as a list of key/value pairs enclosed within a pair of braces, for example: <code>&#123;roles: ['Neo']&#125;</code>. In this case, we used an array property for the <code>roles</code>, allowing multiple roles to be specified. Properties can be used to store information and/or restrict patterns.</p>
<h4 id="pattern-variables-命名变量">3.2.4. Pattern variables 命名变量</h4>
<p>To increase modularity and reduce repetition, Cypher allows patterns to be assigned to variables. This allows the matching paths to be inspected, used in other expressions, etc.</p>
<pre class="cypher"><code>acted_in = (:Person)-[:ACTED_IN]-&gt;(:Movie)</code></pre>
<p>The <code>acted_in</code> variable would contain two nodes and the connecting relationship for each path that was found or created. There are a number of functions to access details of a path, for example: <code>nodes(path)</code>, <code>relationships(path)</code>, and <code>length(path)</code>.</p>
<h4 id="clauses-分句">3.2.5. Clauses 分句</h4>
<p>Cypher statements typically have multiple <em>clauses</em>, each of which performs a specific task, for example:</p>
<ul>
<li>create and match patterns in the graph</li>
<li>filter, project, sort, or paginate results</li>
<li>compose partial statements</li>
</ul>
<p>By combining Cypher clauses, we can compose more complex statements that express what we want to know or create.</p>
<h3 id="patterns-in-practice-模式实例练习">3.3. Patterns in practice 模式实例练习</h3>
<h4 id="creating-data-创建节点">3.3.1. Creating data 创建节点</h4>
<p>We’ll start by looking into the clauses that allow us to create data.</p>
<p>To add data, we just use the patterns we already know. By providing patterns we can specify what graph structures, labels and properties we would like to make part of our graph.</p>
<p>Obviously the simplest clause is called <code>CREATE</code>. It will just go ahead and directly create the patterns that you specify.</p>
<p>For the patterns we have looked at so far this could look like the following:</p>
<pre class="cypher"><code>CREATE (:Movie &#123;title: &#39;The Matrix&#39;, released: 1997&#125;)</code></pre>
<p>If we execute this statement, Cypher returns the number of changes, in this case adding 1 node, 1 label and 2 properties.</p>
<pre><code>Created Nodes: 1
Added Labels: 1
Set Properties: 2
Rows: 0</code></pre>
<p>As we started out with an empty database, we now have a database with a single node in it:</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/cypher-intro-patterns-in-practice01.svg" alt="cypher intro patterns in practice01" /><figcaption aria-hidden="true">cypher intro patterns in practice01</figcaption>
</figure>
<p>If case we also want to return the created data we can add a <code>RETURN</code> clause, which refers to the variable we have assigned to our pattern elements.</p>
<pre class="cypher"><code>CREATE (p:Person &#123;name: &#39;Keanu Reeves&#39;, born: 1964&#125;)
RETURN p</code></pre>
<p>This is what gets returned:</p>
<pre><code>Created Nodes: 1
Added Labels: 1
Set Properties: 2
Rows: 1

+----------------------------------------------+
| p                                            |
+----------------------------------------------+
| (:Person &#123;name: &#39;Keanu Reeves&#39;, born: 1964&#125;) |
+----------------------------------------------+</code></pre>
<p>If we want to create more than one element, we can separate the elements with commas or use multiple <code>CREATE</code> statements.</p>
<p>We can of course also create more complex structures, like an <code>ACTED_IN</code> relationship with information about the character, or <code>DIRECTED</code> ones for the director.</p>
<pre class="cypher"><code>CREATE (a:Person &#123;name: &#39;Tom Hanks&#39;, born: 1956&#125;)-[r:ACTED_IN &#123;roles: [&#39;Forrest&#39;]&#125;]-&gt;(m:Movie &#123;title: &#39;Forrest Gump&#39;, released: 1994&#125;)
CREATE (d:Person &#123;name: &#39;Robert Zemeckis&#39;, born: 1951&#125;)-[:DIRECTED]-&gt;(m)
RETURN a, d, r, m</code></pre>
<p>This is the part of the graph we just updated:</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/cypher-intro-patterns-in-practice02.svg" alt="cypher intro patterns in practice02" /><figcaption aria-hidden="true">cypher intro patterns in practice02</figcaption>
</figure>
<p>In most cases, we want to connect new data to existing structures. This requires that we know how to find existing patterns in our graph data, which we will look at next.</p>
<h4 id="matching-patterns-查询">3.3.2. Matching patterns 查询</h4>
<p>Matching patterns is a task for the <code>MATCH</code> statement. We pass the same kind of patterns we’ve used so far to <code>MATCH</code> to describe what we’re looking for. It is similar to <em>query by example</em>, only that our examples also include the structures.</p>
<blockquote>
<p>A <code>MATCH</code> statement will search for the patterns we specify and return <em>one row per successful pattern match</em>.</p>
</blockquote>
<p>To find the data we have created so far, we can start looking for all nodes labeled with the <code>Movie</code> label.</p>
<pre class="cypher"><code>MATCH (m:Movie)
RETURN m</code></pre>
<p>Here’s the result:</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/cypher-intro-patterns-in-practice03.svg" alt="cypher intro patterns in practice03" /><figcaption aria-hidden="true">cypher intro patterns in practice03</figcaption>
</figure>
<p>This should show both <em>The Matrix</em> and <em>Forrest Gump</em>.</p>
<p>We can also look for a specific person, like <em>Keanu Reeves</em>.</p>
<pre class="cypher"><code>MATCH (p:Person &#123;name: &#39;Keanu Reeves&#39;&#125;)
RETURN p</code></pre>
<p>This query returns the matching node:</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/cypher-intro-patterns-in-practice04.svg" alt="cypher intro patterns in practice04" /><figcaption aria-hidden="true">cypher intro patterns in practice04</figcaption>
</figure>
<p>Note that we only provide enough information to find the nodes, not all properties are required. In most cases you have key-properties like SSN, ISBN, emails, logins, geolocation or product codes to look for.</p>
<p>We can also find more interesting connections, like for instance the movies titles that <em>Tom Hanks</em> acted in and the roles he played.</p>
<pre class="cypher"><code>MATCH (p:Person &#123;name: &#39;Tom Hanks&#39;&#125;)-[r:ACTED_IN]-&gt;(m:Movie)
RETURN m.title, r.roles
Rows: 1

+------------------------------+
| m.title        | r.roles     |
+------------------------------+
| &#39;Forrest Gump&#39; | [&#39;Forrest&#39;] |
+------------------------------+</code></pre>
<p>In this case we only returned the properties of the nodes and relationships that we were interested in. You can access them everywhere via a dot notation <code>identifer.property</code>.</p>
<p>Of course this only lists his role as <em>Forrest</em> in <em>Forrest Gump</em> because that’s all data that we have added.</p>
<p>Now we know enough to connect new nodes to existing ones and can combine <code>MATCH</code> and <code>CREATE</code> to attach structures to the graph.</p>
<h4 id="attaching-structures-创建关系">3.3.3. Attaching structures 创建关系</h4>
<p>To extend the graph with new information, we first match the existing connection points and then attach the newly created nodes to them with relationships. Adding <em>Cloud Atlas</em> as a new movie for <em>Tom Hanks</em> could be achieved like this:</p>
<pre class="cypher"><code>MATCH (p:Person &#123;name: &#39;Tom Hanks&#39;&#125;)
CREATE (m:Movie &#123;title: &#39;Cloud Atlas&#39;, released: 2012&#125;)
CREATE (p)-[r:ACTED_IN &#123;roles: [&#39;Zachry&#39;]&#125;]-&gt;(m)
RETURN p, r, m</code></pre>
<p>Here’s what the structure looks like in the database:</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/cypher-intro-patterns-in-practice05.svg" alt="cypher intro patterns in practice05" /><figcaption aria-hidden="true">cypher intro patterns in practice05</figcaption>
</figure>
<blockquote>
<p>It is important to remember that we can assign variables to both nodes and relationships and use them later on, no matter if they were created or matched.</p>
</blockquote>
<p>It is possible to attach both node and relationship in a single <code>CREATE</code> clause. For readability it helps to split them up though.</p>
<blockquote>
<p>A tricky aspect of the combination of <code>MATCH</code> and <code>CREATE</code> is that we get <em>one row per matched pattern</em>. This causes subsequent <code>CREATE</code> statements to be executed once for each row. In many cases this is what you want. If that’s not intended, please move the <code>CREATE</code> statement before the <code>MATCH</code>, or change the cardinality of the query with means discussed later or use the <em>get or create</em> semantics of the next clause: <code>MERGE</code>.</p>
</blockquote>
<h4 id="completing-patterns-合并">3.3.4. Completing patterns 合并</h4>
<p>Whenever we get data from external systems or are not sure if certain information already exists in the graph, we want to be able to express a repeatable (idempotent) update operation. In Cypher <code>MERGE</code> has this function. It acts like a combination of <code>MATCH</code> <em>or</em> <code>CREATE</code>, which checks for the existence of data first before creating it. With <code>MERGE</code> you define a pattern to be found or created. Usually, as with <code>MATCH</code> you only want to include the key property to look for in your core pattern. <code>MERGE</code> allows you to provide additional properties you want to set <code>ON CREATE</code>.</p>
<p>If we would not know if our graph already contained <em>Cloud Atlas</em> we could merge it in again.</p>
<pre class="cypher"><code>MERGE (m:Movie &#123;title: &#39;Cloud Atlas&#39;&#125;)
ON CREATE SET m.released = 2012
RETURN m
Created Nodes: 1
Added Labels: 1
Set Properties: 2
Rows: 1

+-------------------------------------------------+
| m                                               |
+-------------------------------------------------+
| (:Movie &#123;title: &#39;Cloud Atlas&#39;, released: 2012&#125;) |
+-------------------------------------------------+</code></pre>
<p>We get a result in any both cases: either the data (potentially more than one row) that was already in the graph or a single, newly created <code>Movie</code> node.</p>
<blockquote>
<p>A <code>MERGE</code> clause without any previously assigned variables in it either matches the full pattern or creates the full pattern. It never produces a partial mix of matching and creating within a pattern. To achieve a partial match/create, make sure to use already defined variables for the parts that shouldn’t be affected.</p>
</blockquote>
<p>So foremost <code>MERGE</code> makes sure that you can’t create duplicate information or structures, but it comes with the cost of needing to check for existing matches first. Especially on large graphs it can be costly to scan a large set of labeled nodes for a certain property. You can alleviate some of that by creating supporting indexes or constraints, which we will discuss later. But it’s still not for free, so whenever you’re sure to not create duplicate data use <code>CREATE</code> over <code>MERGE</code>.</p>
<blockquote>
<p><code>MERGE</code> can also assert that a relationship is only created once. For that to work you <em>have to pass in</em> both nodes from a previous pattern match.</p>
</blockquote>
<pre class="cypher"><code>MATCH (m:Movie &#123;title: &#39;Cloud Atlas&#39;&#125;)
MATCH (p:Person &#123;name: &#39;Tom Hanks&#39;&#125;)
MERGE (p)-[r:ACTED_IN]-&gt;(m)
ON CREATE SET r.roles =[&#39;Zachry&#39;]
RETURN p, r, m</code></pre>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/cypher-intro-patterns-in-practice06.svg" alt="cypher intro patterns in practice06" /><figcaption aria-hidden="true">cypher intro patterns in practice06</figcaption>
</figure>
<p>In case the direction of a relationship is arbitrary, you can leave off the arrowhead. <code>MERGE</code> will then check for the relationship in either direction, and create a new directed relationship if no matching relationship was found.</p>
<p>If you choose to pass in only one node from a preceding clause, <code>MERGE</code> offers an interesting functionality. It will then only match within the direct neighborhood of the provided node for the given pattern, and, if not found create it. This can come in very handy for creating for example tree structures.</p>
<pre class="cypher"><code>CREATE (y:Year &#123;year: 2014&#125;)
MERGE (y)&lt;-[:IN_YEAR]-(m10:Month &#123;month: 10&#125;)
MERGE (y)&lt;-[:IN_YEAR]-(m11:Month &#123;month: 11&#125;)
RETURN y, m10, m11</code></pre>
<p>This is the graph structure that gets created:</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/cypher-intro-patterns-in-practice07.svg" alt="cypher intro patterns in practice07" /><figcaption aria-hidden="true">cypher intro patterns in practice07</figcaption>
</figure>
<p>Here there is no global search for the two <code>Month</code> nodes; they are only searched for in the context of the <em>2014</em> <code>Year</code> node.</p>
<h3 id="getting-the-correct-results-高级查询">3.4. Getting the correct results 高级查询</h3>
<p>First we create some data to use for our examples:</p>
<pre class="cypher"><code>CREATE (matrix:Movie &#123;title: &#39;The Matrix&#39;, released: 1997&#125;)
CREATE (cloudAtlas:Movie &#123;title: &#39;Cloud Atlas&#39;, released: 2012&#125;)
CREATE (forrestGump:Movie &#123;title: &#39;Forrest Gump&#39;, released: 1994&#125;)
CREATE (keanu:Person &#123;name: &#39;Keanu Reeves&#39;, born: 1964&#125;)
CREATE (robert:Person &#123;name: &#39;Robert Zemeckis&#39;, born: 1951&#125;)
CREATE (tom:Person &#123;name: &#39;Tom Hanks&#39;, born: 1956&#125;)
CREATE (tom)-[:ACTED_IN &#123;roles: [&#39;Forrest&#39;]&#125;]-&gt;(forrestGump)
CREATE (tom)-[:ACTED_IN &#123;roles: [&#39;Zachry&#39;]&#125;]-&gt;(cloudAtlas)
CREATE (robert)-[:DIRECTED]-&gt;(forrestGump)</code></pre>
<p>This is the resulting graph:</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/cypher-intro-results01.svg" alt="cypher intro results01" /><figcaption aria-hidden="true">cypher intro results01</figcaption>
</figure>
<h4 id="filtering-results-添加筛选条件">3.4.1. Filtering results 添加筛选条件</h4>
<p>So far we have matched patterns in the graph and always returned all results we found. Now we will look into options for filtering the results and only return the subset of data that we are interested in. Those filter conditions are expressed using the <code>WHERE</code> clause. This clause allows to use any number of boolean expressions, <em>predicates</em>, combined with <code>AND</code>, <code>OR</code>, <code>XOR</code> and <code>NOT</code>. The simplest predicates are comparisons; especially equality.</p>
<pre class="cypher"><code>MATCH (m:Movie)
WHERE m.title = &#39;The Matrix&#39;
RETURN m</code></pre>
<pre><code>Rows: 1

+------------------------------------------------+
| m                                              |
+------------------------------------------------+
| (:Movie &#123;title: &#39;The Matrix&#39;, released: 1997&#125;) |
+------------------------------------------------+</code></pre>
<blockquote>
<p>The query above, using the <code>WHERE</code> clause, is equivalent to this query which includes the condition in the pattern matching:</p>
<pre class="cypher"><code>MATCH (m:Movie &#123;title: &#39;The Matrix&#39;&#125;) RETURN m</code></pre>
</blockquote>
<p>Other options are numeric comparisons, matching regular expressions, and checking the existence of values within a list.</p>
<p>The <code>WHERE</code> clause in the following example includes a regular expression match, a greater-than comparison, and a test to see if a value exists in a list:</p>
<pre class="cypher"><code>MATCH (p:Person)-[r:ACTED_IN]-&gt;(m:Movie)
WHERE p.name =~ &#39;K.+&#39; OR m.released &gt; 2000 OR &#39;Neo&#39; IN r.roles
RETURN p, r, m</code></pre>
<pre><code>Rows: 1

+------------------------------------------------------------------------------------------------------------------------------+
| p                                         | r                               | m                                              |
+------------------------------------------------------------------------------------------------------------------------------+
| (:Person &#123;name: &#39;Tom Hanks&#39;, born: 1956&#125;) | [:ACTED_IN &#123;roles: [&#39;Zachry&#39;]&#125;] | (:Movie &#123;title: &#39;Cloud Atlas&#39;, released: 2012&#125;)|
+------------------------------------------------------------------------------------------------------------------------------+</code></pre>
<p>An advanced aspect is that patterns can be used as predicates. Where <code>MATCH</code> expands the number and shape of patterns matched, a pattern predicate restricts the current result set. It only allows the paths to pass that satisfy the specified pattern. As we can expect, the use of <code>NOT</code> only allows the paths to pass that do <em>not</em> satisfy the specified pattern.</p>
<pre class="cypher"><code>MATCH (p:Person)-[:ACTED_IN]-&gt;(m)
WHERE NOT (p)-[:DIRECTED]-&gt;()
RETURN p, m</code></pre>
<pre><code>Rows: 2

+----------------------------------------------------------------------------------------------+
| p                                         | m                                                |
+----------------------------------------------------------------------------------------------+
| (:Person &#123;name: &#39;Tom Hanks&#39;, born: 1956&#125;) | (:Movie &#123;title: &#39;Cloud Atlas&#39;, released: 2012&#125;)  |
| (:Person &#123;name: &#39;Tom Hanks&#39;, born: 1956&#125;) | (:Movie &#123;title: &#39;Forrest Gump&#39;, released: 1994&#125;) |
+----------------------------------------------------------------------------------------------+</code></pre>
<p>Here we find actors, because they sport an <code>ACTED_IN</code> relationship but then skip those that ever <code>DIRECTED</code> any movie.</p>
<p>There are more advanced ways of filtering, for example <em>list predicates</em>, which we will discuss later in this section.</p>
<h4 id="returning-results-指定返回结果">3.4.2. Returning results 指定返回结果</h4>
<p>So far, we have returned nodes, relationships and paths directly via their variables. However, the <code>RETURN</code> clause can return any number of expressions. But what are expressions in Cypher?</p>
<p>The simplest expressions are literal values. Examples of literal values are: numbers, strings, arrays (for example: <code>[1,2,3]</code>), and maps (for example: <code>&#123;name: 'Tom Hanks', born:1964, movies: ['Forrest Gump', ...], count: 13&#125;</code>). Individual properties of any node, relationship or map can be accessed using the <em>dot syntax</em>, for example: <code>n.name</code>. Individual elements or slices of arrays can be retrieved with subscripts, for example: <code>names[0]</code> and <code>movies[1..-1]</code>. Each function evaluation, for example: <code>length(array)</code>, <code>toInteger('12')</code>, <code>substring('2014-07-01', 0, 4)</code> and <code>coalesce(p.nickname, 'n/a')</code>, is also an expression.</p>
<p>Predicates used in <code>WHERE</code> clauses count as <em>boolean expressions</em>.</p>
<p>Simple expressions can be composed and concatenated to form more complex expressions.</p>
<p>By default the expression itself will be used as label for the column, in many cases you want to alias that with a more understandable name using <code>expression AS alias</code>. The alias can be used subsequently to refer to that column.</p>
<pre class="cypher"><code>MATCH (p:Person)
RETURN
  p.name AS name,
  toUpper(p.name),
  coalesce(p.nickname, &#39;n/a&#39;) AS nickname,
  &#123;name: p.name, label: head(labels(p))&#125; AS person
</code></pre>
<pre><code>Rows: 3

+-----------------------------------------------------------------------------------------------+
| name              | toUpper(p.name)   | nickname | person                                     |
+-----------------------------------------------------------------------------------------------+
| &#39;Keanu Reeves&#39;    | &#39;KEANU REEVES&#39;    | &#39;n/a&#39;    | &#123;name: &#39;Keanu Reeves&#39;, label: &#39;Person&#39;&#125;    |
| &#39;Robert Zemeckis&#39; | &#39;ROBERT ZEMECKIS&#39; | &#39;n/a&#39;    | &#123;name: &#39;Robert Zemeckis&#39;, label: &#39;Person&#39;&#125; |
| &#39;Tom Hanks&#39;       | &#39;TOM HANKS&#39;       | &#39;n/a&#39;    | &#123;name: &#39;Tom Hanks&#39;, label: &#39;Person&#39;&#125;       |
+-----------------------------------------------------------------------------------------------+</code></pre>
<p>If we wish to display only unique results we can use the <code>DISTINCT</code> keyword after <code>RETURN</code>:</p>
<pre class="cypher"><code>MATCH (n)
RETURN DISTINCT labels(n) AS Labels</code></pre>
<pre><code>Rows: 2

+------------+
| Labels     |
+------------+
| [&#39;Movie&#39;]  |
| [&#39;Person&#39;] |
+------------+</code></pre>
<h4 id="aggregating-information-信息聚合">3.4.3. Aggregating information 信息聚合</h4>
<p>In many cases we wish to aggregate or group the data encountered while traversing patterns in our graph. In Cypher, aggregation happens in the <code>RETURN</code> clause while computing the final results. Many common aggregation functions are supported, e.g. <code>count</code>, <code>sum</code>, <code>avg</code>, <code>min</code>, and <code>max</code>, but there are several more.</p>
<p>Counting the number of people in your database could be achieved by this:</p>
<pre class="cypher"><code>MATCH (:Person)
RETURN count(*) AS people</code></pre>
<pre><code>Rows: 1

+--------+
| people |
+--------+
| 3      |
+--------+</code></pre>
<p>Note that <code>NULL</code> values are skipped during aggregation. For aggregating only unique values use <code>DISTINCT</code>, for example: <code>count(DISTINCT role)</code>.</p>
<p>Aggregation works implicitly in Cypher. We specify which result columns we wish to aggregate. Cypher will use all non-aggregated columns as grouping keys.</p>
<p>Aggregation affects which data is still visible in ordering or later query parts.</p>
<p>The following statement finds out how often an actor and director have worked together:</p>
<pre class="cypher"><code>MATCH (actor:Person)-[:ACTED_IN]-&gt;(movie:Movie)&lt;-[:DIRECTED]-(director:Person)
RETURN actor, director, count(*) AS collaborations</code></pre>
<pre><code>Rows: 1

+--------------------------------------------------------------------------------------------------------------+
| actor                                     | director                                        | collaborations |
+--------------------------------------------------------------------------------------------------------------+
| (:Person &#123;name: &#39;Tom Hanks&#39;, born: 1956&#125;) | (:Person &#123;name: &#39;Robert Zemeckis&#39;, born: 1951&#125;) | 1              |
+--------------------------------------------------------------------------------------------------------------+</code></pre>
<h4 id="ordering-and-pagination-排序和分页">3.4.4. Ordering and pagination 排序和分页</h4>
<p>It is common to sort and paginate after aggregating using <code>count(x)</code>.</p>
<p>Ordering is done using the <code>ORDER BY expression [ASC|DESC]</code> clause. The expression can be any expression, as long as it is computable from the returned information.</p>
<p>For instance, if we return <code>person.name</code> we can still <code>ORDER BY person.age</code> since both are accessible from the <code>person</code> reference. We cannot order by things that are not returned. This is especially important with aggregation and <code>DISTINCT</code> return values, since both remove the visibility of data that is aggregated.</p>
<p>Pagination is done using the <code>SKIP &#123;offset&#125;</code> and <code>LIMIT &#123;count&#125;</code> clauses.</p>
<p>A common pattern is to aggregate for a count (<em>score</em> or <em>frequency</em>), order by it, and only return the top-n entries.</p>
<p>For instance to find the most prolific actors we could do:</p>
<pre class="cypher"><code>MATCH (a:Person)-[:ACTED_IN]-&gt;(m:Movie)
RETURN a, count(*) AS appearances
ORDER BY appearances DESC LIMIT 10</code></pre>
<pre><code>Rows: 1

+---------------------------------------------------------+
| a                                         | appearances |
+---------------------------------------------------------+
| (:Person &#123;name: &#39;Tom Hanks&#39;, born: 1956&#125;) | 2           |
+---------------------------------------------------------+</code></pre>
<h4 id="collecting-aggregation-聚合为集合">3.4.5. Collecting aggregation 聚合为集合</h4>
<p>A very helpful aggregation function is <code>collect()</code>, which collects all the aggregated values into a list. This is very useful in many situations, since no information of details is lost while aggregating.</p>
<p><code>collect()</code> is well-suited for retrieving typical parent-child structures, where one core entity (<em>parent</em>, <em>root</em> or <em>head</em>) is returned per row with all its dependent information in associated lists created with <code>collect()</code>. This means that there is no need to repeat the parent information for each child row, or running <code>n+1</code> statements to retrieve the parent and its children individually.</p>
<p>The following statement could be used to retrieve the cast of each movie in our database:</p>
<pre class="cypher"><code>MATCH (m:Movie)&lt;-[:ACTED_IN]-(a:Person)
RETURN m.title AS movie, collect(a.name) AS cast, count(*) AS actors</code></pre>
<pre><code>Rows: 2

+-----------------------------------------+
| movie          | cast          | actors |
+-----------------------------------------+
| &#39;Forrest Gump&#39; | [&#39;Tom Hanks&#39;] | 1      |
| &#39;Cloud Atlas&#39;  | [&#39;Tom Hanks&#39;] | 1      |
+-----------------------------------------+</code></pre>
<p>The lists created by <code>collect()</code> can either be used from the client consuming the Cypher results, or directly within a statement with any of the list functions or predicates.</p>
<h3 id="defining-a-schema-定义架构">3.5. Defining a schema 定义架构</h3>
<p>First we create some data to use for our examples:</p>
<pre class="cypher"><code>CREATE (matrix:Movie &#123;title: &#39;The Matrix&#39;, released: 1997&#125;)
CREATE (cloudAtlas:Movie &#123;title: &#39;Cloud Atlas&#39;, released: 2012&#125;)
CREATE (forrestGump:Movie &#123;title: &#39;Forrest Gump&#39;, released: 1994&#125;)
CREATE (keanu:Person &#123;name: &#39;Keanu Reeves&#39;&#125;)
CREATE (robert:Person &#123;name: &#39;Robert Zemeckis&#39;, born: 1951&#125;)
CREATE (tom:Person &#123;name: &#39;Tom Hanks&#39;, born: 1956&#125;)
CREATE (tom)-[:ACTED_IN &#123;roles: [&#39;Forrest&#39;]&#125;]-&gt;(forrestGump)
CREATE (tom)-[:ACTED_IN &#123;roles: [&#39;Zachry&#39;]&#125;]-&gt;(cloudAtlas)
CREATE (robert)-[:DIRECTED]-&gt;(forrestGump)</code></pre>
<p>This is the resulting graph:</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/cypher-intro-schema01.svg" alt="cypher intro schema01" /><figcaption aria-hidden="true">cypher intro schema01</figcaption>
</figure>
<h4 id="using-indexes-索引">3.5.1. Using indexes 索引</h4>
<p>The main reason for using indexes in a graph database is to find the starting point of a graph traversal. Once that starting point is found, the traversal relies on in-graph structures to achieve high performance.</p>
<p>Indexes can be added at any time. Note, however, that if there is existing data in the database, it will take some time for an index to come online.</p>
<p>In this case we want to create an index to speed up finding actors by name in the database:</p>
<pre class="cypher"><code>CREATE INDEX FOR (a:Actor) ON (a.name)</code></pre>
<p>In most cases it is not necessary to specify indexes when querying for data, as the appropriate indexes will be used automatically. For example, the following query will automatically use the index defined above:</p>
<pre class="cypher"><code>MATCH (actor:Actor &#123;name: &#39;Tom Hanks&#39;&#125;)
RETURN actor</code></pre>
<p>A <em>composite index</em> is an index on multiple properties for all nodes that have a particular label. For example, the following statement will create a composite index on all nodes labeled with <code>Actor</code> and which have both a <code>name</code> and a <code>born</code> property. Note that since the node with the <code>Actor</code> label that has a <code>name</code> of "Keanu Reeves" does not have the <code>born</code> property. Therefore that node will not be added to the index.</p>
<pre class="cypher"><code>CREATE INDEX FOR (a:Actor) ON (a.name, a.born)</code></pre>
<p>We can inspect our database to find out what indexes are defined. We do this by calling the built-in procedure <code>db.indexes</code>:</p>
<pre class="cypher"><code>CALL db.indexes
YIELD description, tokenNames, properties, type;</code></pre>
<pre><code>Rows: 2

+---------------------------------------------------------------------------------------+
| description                   | tokenNames | properties       | type                  |
+---------------------------------------------------------------------------------------+
| &#39;INDEX ON :Actor(name)&#39;       | [&#39;Actor&#39;]  | [&#39;name&#39;]         | &#39;node_label_property&#39; |
| &#39;INDEX ON :Actor(name, born)&#39; | [&#39;Actor&#39;]  | [&#39;name&#39;, &#39;born&#39;] | &#39;node_label_property&#39; |
+---------------------------------------------------------------------------------------+</code></pre>
<h4 id="using-constraints-约束">3.5.2. Using constraints 约束</h4>
<p>Constraints are used to make sure that the data adheres to the rules of the domain. For example: "If a node has a label of <code>Actor</code> and a property of <code>name</code>, then the value of <code>name</code> must be unique among all nodes that have the <code>Actor</code> label".</p>
<p>To create a constraint that makes sure that our database will never contain more than one node with the label <code>Movie</code> and the property <code>title</code>, we use the IS UNIQUE syntax:</p>
<pre class="cypher"><code>CREATE CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE</code></pre>
<p>Adding the unique constraint will implicitly add an index on that property. If the constraint is dropped, but the index is still needed, the index will have to be created explicitly.</p>
<p>Constraints can be added to database that already has data in it. This requires that the existing data complies with the constraint that is being added.</p>
<p>We can inspect our database to find out what constraints are defined. We do this by calling the built-in procedure <code>db.constraints</code>:</p>
<pre class="cypher"><code>CALL db.constraints</code></pre>
<pre><code>Rows: 1

+------------------------------------------------------------+
| description                                                |
+------------------------------------------------------------+
| &#39;CONSTRAINT ON (movie:Movie) ASSERT movie.title IS UNIQUE&#39; |
+------------------------------------------------------------+</code></pre>
<p>The constraint described above is available for all editions of Neo4j. Additional constraints are available for Neo4j Enterprise Edition.</p>
<h3 id="import-data-导入外部数据">3.6. Import data 导入外部数据</h3>
<p>With the combination of the Cypher clauses <code>LOAD CSV</code>, <code>MERGE</code>, and <code>CREATE</code> you can conveniently import data into Neo4j. <code>LOAD CSV</code> allows you to access the data values and perform actions on them.</p>
<p>In this tutorial, you import data from the following CSV files:</p>
<ul>
<li><em>persons.csv</em></li>
<li><em>movies.csv</em></li>
<li><em>roles.csv</em></li>
</ul>
<p>The content of the <em>persons.csv</em> file:</p>
<p>persons.csv</p>
<pre><code>id,name
1,Charlie Sheen
2,Michael Douglas
3,Martin Sheen
4,Morgan Freeman</code></pre>
<p>The <em>persons.csv</em> file contains two columns <code>id</code> and <code>name</code>. Each row represents one person that has a unique <code>id</code> and a <code>name</code>.</p>
<p>The content of the <em>movies.csv</em> file:</p>
<p>movies.csv</p>
<pre><code>id,title,country,year
1,Wall Street,USA,1987
2,The American President,USA,1995
3,The Shawshank Redemption,USA,1994</code></pre>
<p>The <em>movies.csv</em> file contains the columns <code>id</code>, <code>title</code>, <code>country</code>, and <code>year</code>. Each row represents one movie that has a unique <code>id</code>, a <code>title</code>, a <code>country</code> of origin, and a release <code>year</code>.</p>
<p>The content of the <em>roles.csv</em> file:</p>
<p>roles.csv</p>
<pre><code>personId,movieId,role
1,1,Bud Fox
4,1,Carl Fox
3,1,Gordon Gekko
4,2,A.J. MacInerney
3,2,President Andrew Shepherd
5,3,Ellis Boyd &#39;Red&#39; Redding</code></pre>
<p>The <em>roles.csv</em> file contains the columns <code>personId</code>, <code>movieId</code>, and <code>role</code>. Each row represents one role with relationship data about the person <code>id</code> (from the <em>persons.csv</em> file) and the movie <code>id</code> (from the <em>movies.csv</em> file).</p>
<p>The following simple data model shows what a graph model for this data set could look like:</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/getting-started-load-csv01.svg" alt="getting started load csv01" /><figcaption aria-hidden="true">getting started load csv01</figcaption>
</figure>
<p>This is the resulting graph, based on the data from the CSV files:</p>
<figure>
<img src="https://neo4j.com/docs/getting-started/current/_images/getting-started-load-csv02.svg" alt="getting started load csv02" /><figcaption aria-hidden="true">getting started load csv02</figcaption>
</figure>
<h4 id="prerequisites-事前准备">3.6.1. Prerequisites 事前准备</h4>
<p>It assumes that your current work directory is the <em><neo4j-home></em> directory of the tarball installation, and the CSV files are placed in the default <em>import</em> directory.</p>
<h4 id="prepare-the-database-构建数据库结构">3.6.2. Prepare the database 构建数据库结构</h4>
<p>Before importing the data, you should prepare the database you want to use by creating indexes and constraints.</p>
<p>You should ensure that the <code>Person</code> and <code>Movie</code> nodes have unique <code>id</code> properties by creating constraints on them.</p>
<p>Creating a unique constraint also implicitly creates an index. By indexing the <code>id</code> property, node lookup (e.g. by <code>MATCH</code>) will be much faster.</p>
<p>Additionally, it is a good idea to index the country <code>name</code> for a fast lookup.</p>
<h5 id="create-a-constraint-so-that-each-person-node-has-a-unique-id-property.">3.6.2.1. Create a constraint so that each <code>Person</code> node has a unique <code>id</code> property.</h5>
<p>You create a constraint on the <code>id</code> property of <code>Person</code> nodes to ensure that nodes with the <code>Person</code> label will have a unique <code>id</code> property.</p>
<p>Using <em>Neo4j Browser</em>, run the following Cypher:</p>
<pre class="cypher"><code>CREATE CONSTRAINT personIdConstraint ON (person:Person) ASSERT person.id IS UNIQUE</code></pre>
<h5 id="create-a-constraint-so-that-each-movie-node-has-a-unique-id-propery.">3.6.2.2. Create a constraint so that each <code>Movie</code> node has a unique <code>id</code> propery.</h5>
<p>You create a constraint on the <code>id</code> property of <code>Movie</code> nodes to ensure that nodes with the <code>Movie</code> label will have a unique <code>id</code> property.</p>
<p>Using <em>Neo4j Browser</em>, run the following Cypher:</p>
<pre class="cypher"><code>CREATE CONSTRAINT movieIdConstraint ON (movie:Movie) ASSERT movie.id IS UNIQUE</code></pre>
<h5 id="create-an-index-for-country-node-for-the-name-property.">3.6.2.3. Create an index for <code>Country</code> node for the <code>name</code> property.</h5>
<p>Create an index on the <code>name</code> property of <code>Country</code> nodes to ensure fast lookups.</p>
<blockquote>
<p>When using <code>MERGE</code> or <code>MATCH</code> with <code>LOAD CSV</code>, make sure you have an <a target="_blank" rel="noopener" href="https://neo4j.com/docs/getting-started/current/cypher-intro/schema/#cypher-intro-indexes">index</a> or a <a target="_blank" rel="noopener" href="https://neo4j.com/docs/getting-started/current/cypher-intro/schema/#cypher-intro-constraints">unique constraint</a> on the property that you are merging on. This will ensure that the query executes in a performant way.</p>
</blockquote>
<p>Using <em>Neo4j Browser</em>, run the following Cypher:</p>
<pre class="cypher"><code>CREATE INDEX FOR (c:Country) ON (c.name)</code></pre>
<h4 id="import-data-using-load-csv-导入数据">3.6.3. Import data using <code>LOAD CSV</code> 导入数据</h4>
<h5 id="load-the-data-from-the-persons.csv-file.">3.6.3.1. Load the data from the *persons.csv* file.</h5>
<p>You create nodes with the <code>Person</code> label and the the the properties <code>id</code> and <code>name</code>.</p>
<p>Using <em>Neo4j Browser</em>, run the following Cypher:</p>
<pre class="cypher"><code>LOAD CSV WITH HEADERS FROM &quot;file:///persons.csv&quot; AS csvLine
CREATE (p:Person &#123;id: toInteger(csvLine.id), name: csvLine.name&#125;)</code></pre>
<p>Output:</p>
<pre><code>Added 4 nodes, Set 8 properties, Added 4 labels</code></pre>
<h5 id="load-the-data-from-the-movies.csv-file.">3.6.3.2. Load the data from the *movies.csv* file.</h5>
<p>You create nodes with the <code>Movie</code> label and the the the properties <code>id</code>, <code>title</code>, and <code>year</code>.</p>
<p>Also you create nodes with the <code>Country</code> label. Using <code>MERGE</code> avoids creating duplicate <code>Country</code> nodes in the case where multiple movies have the same country of origin.</p>
<p>The relationship with the type <code>ORIGIN</code> will connect the <code>Country</code> node and the <code>Movie</code> node.</p>
<p>Using <em>Neo4j Browser</em>, run the following Cypher:</p>
<pre class="cypher"><code>LOAD CSV WITH HEADERS FROM &quot;file:///movies.csv&quot; AS csvLine
MERGE (country:Country &#123;name: csvLine.country&#125;)
CREATE (movie:Movie &#123;id: toInteger(csvLine.id), title: csvLine.title, year:toInteger(csvLine.year)&#125;)
CREATE (movie)-[:ORIGIN]-&gt;(country)</code></pre>
<p>Output:</p>
<pre><code>Added 4 nodes, Created 3 relationships, Set 10 properties, Added 4 labels</code></pre>
<h5 id="load-the-data-from-the-roles.csv-file">3.6.3.3. Load the data from the *roles.csv* file</h5>
<p>Importing the data from the <em>roles.csv</em> file is a matter of finding the <code>Person</code> node and <code>Movie</code> node and then creating relationships between them.</p>
<blockquote>
<p>For larger data files, it is useful to use the hint <code>USING PERIODIC COMMIT</code> clause of <code>LOAD CSV</code>. This hint tells Neo4j that the query might build up inordinate amounts of transaction state, and thus needs to be periodically committed.</p>
<p>For more information, see <a target="_blank" rel="noopener" href="https://neo4j.com/docs/cypher-manual/4.3/query-tuning/using/#query-using-periodic-commit-hint">4.3@cypher-manual:ROOT:query-tuning/using/index.adoc#query-using-periodic-commit-hint</a>.</p>
</blockquote>
<p>Using <em>Neo4j Browser</em>, run the following Cypher:</p>
<pre class="cypher"><code>USING PERIODIC COMMIT 500
LOAD CSV WITH HEADERS FROM &quot;file:///roles.csv&quot; AS csvLine
MATCH (person:Person &#123;id: toInteger(csvLine.personId)&#125;), (movie:Movie &#123;id: toInteger(csvLine.movieId)&#125;)
CREATE (person)-[:ACTED_IN &#123;role: csvLine.role&#125;]-&gt;(movie)</code></pre>
<p>Output:</p>
<pre><code>Created 5 relationships, Set 5 properties</code></pre>
<h4 id="validate-the-imported-data-验证导入效果">3.6.4. Validate the imported data 验证导入效果</h4>
<p>Check the resulting data set by finding all the nodes that have a relationship.</p>
<p>Using <em>Neo4j Browser</em>, run the following Cypher:</p>
<pre class="cypher"><code>MATCH (n)-[r]-&gt;(m) RETURN n, r, m</code></pre>
<p>Output:</p>
<pre><code>+------------------------------------------------------------------------------------------------------------------------------+
| n                                                               | r                                               | m        |
+------------------------------------------------------------------------------------------------------------------------------+
| (:Movie &#123;id: 3, title: &quot;The Shawshank Redemption&quot;, year: 1994&#125;) | [:ORIGIN]                                       | (:Country &#123;name: &quot;USA&quot;&#125;)                                      |
| (:Movie &#123;id: 2, title: &quot;The American President&quot;, year: 1995&#125;)   | [:ORIGIN]                                       | (:Country &#123;name: &quot;USA&quot;&#125;)                                      |
| (:Movie &#123;id: 1, title: &quot;Wall Street&quot;, year: 1987&#125;)              | [:ORIGIN]                                       | (:Country &#123;name: &quot;USA&quot;&#125;)                                      |
| (:Person &#123;name: &quot;Morgan Freeman&quot;, id: 4&#125;)                       | [:ACTED_IN &#123;role: &quot;Carl Fox&quot;&#125;]                  | (:Movie &#123;id: 1, title: &quot;Wall Street&quot;, year: 1987&#125;)            |
| (:Person &#123;name: &quot;Charlie Sheen&quot;, id: 1&#125;)                        | [:ACTED_IN &#123;role: &quot;Bud Fox&quot;&#125;]                   | (:Movie &#123;id: 1, title: &quot;Wall Street&quot;, year: 1987&#125;)            |
| (:Person &#123;name: &quot;Martin Sheen&quot;, id: 3&#125;)                         | [:ACTED_IN &#123;role: &quot;Gordon Gekko&quot;&#125;]              | (:Movie &#123;id: 1, title: &quot;Wall Street&quot;, year: 1987&#125;)            |
| (:Person &#123;name: &quot;Martin Sheen&quot;, id: 3&#125;)                         | [:ACTED_IN &#123;role: &quot;President Andrew Shepherd&quot;&#125;] | (:Movie &#123;id: 2, title: &quot;The American President&quot;, year: 1995&#125;) |
| (:Person &#123;name: &quot;Morgan Freeman&quot;, id: 4&#125;)                       | [:ACTED_IN &#123;role: &quot;A.J. MacInerney&quot;&#125;]           | (:Movie &#123;id: 2, title: &quot;The American President&quot;, year: 1995&#125;) |
+------------------------------------------------------------------------------------------------------------------------------+</code></pre>
<h2 id="后续">4. 后续</h2>
<p>恭喜您，已经入门了Neo4j，要想进一步精通，请前往官方文档学习。在此指出下一步的学习方向：</p>
<ol type="1">
<li>在Cypher Manual中学习Syntax，了解已学习的部分语法的详细用法，并接触更多高级语法的使用。</li>
<li>在Cypher Manual中学习Clauses，了解已学习的部分分句的详细用法，并接触更多高级分句的用法。</li>
<li>结合Cypher Refcard中众多参考样例，巩固各种分句的使用方法。</li>
</ol>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-01-14T16:00:00.000Z" itemprop="datePublished">2022/01/15</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%95%B0%E6%8D%AE%E5%BA%93-Neo4j/" rel="tag">计算机 - 数据库 - Neo4j</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-Cypher学习笔记"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/Cypher%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Cypher学习笔记</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h3 id="neo4j的安装配置运行">1. Neo4j的安装&amp;配置&amp;运行</h3>
<h4 id="安装">1.1. 安装</h4>
<p>从官网下载最新版v4.3.6 <a target="_blank" rel="noopener" href="https://neo4j.com/download-center/">Neo4j Download Center</a>，注意下载社区版（Community）的zip包。</p>
<p>将下载的压缩包解压至合适的目录下。（Neo4j无繁琐的安装步骤，解压即可使用）</p>
<h4 id="配置">1.2. 配置</h4>
<p>添加环境变量Path：%你的解压路径%4j-community-4.3.6</p>
<p>用文本编辑器打开目录 %你的解压路径%4j-community-4.3.64j.conf，找到下方所示的两行代码，去掉第二行开头的#，修改参数能够切换不同的数据库（社区版不能在Neo4j Browser中切换数据库，只能通过修改配置文件完成切换）</p>
<pre><code># The name of the default database
dbms.default_database=&lt;your database name&gt;</code></pre>
<h4 id="运行">1.3. 运行</h4>
<p>由于我们已经配置了环境变量，直接在cmd中输入 <code>neo4j console</code>，输出为</p>
<pre><code>Directories in use:
home:         F:\neo4j-community-4.3.6
config:       F:\neo4j-community-4.3.6\conf
logs:         F:\neo4j-community-4.3.6\logs
plugins:      F:\neo4j-community-4.3.6\plugins
import:       F:\neo4j-community-4.3.6\import
data:         F:\neo4j-community-4.3.6\data
certificates: F:\neo4j-community-4.3.6\certificates
licenses:     F:\neo4j-community-4.3.6\licenses
run:          F:\neo4j-community-4.3.6\run
Starting Neo4j.
Started neo4j. It is available at http://127.0.0.1:7474
There may be a short delay until the server is ready.</code></pre>
<blockquote>
<p>在cmd中输入 <code>neo4j stop</code> 来停止应用.</p>
</blockquote>
<p>然后在浏览器中输入 <code>localhost:7474</code> 访问Neo4j Browser</p>
<blockquote>
<p>默认用户名为 <code>neo4j</code> ，默认密码为 <code>neo4j</code>.</p>
</blockquote>
<p>若修改了配置文件，需要通过重启应用来使配置生效，在cmd中输入 <code>neo4j restart</code>，并刷新浏览器</p>
<h3 id="cypher语句的基础用法">2. Cypher语句的基础用法</h3>
<p>Cypher语句的分句可归纳为以下7类：</p>
<table>
<thead>
<tr class="header">
<th>中文</th>
<th>对应英文</th>
<th>对应小标题</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>常规语句</td>
<td>General</td>
<td>格式规范、数据类型、操作符</td>
</tr>
<tr class="even">
<td>读取语句</td>
<td>Read</td>
<td>读取语句</td>
</tr>
<tr class="odd">
<td>写入语句</td>
<td>Write</td>
<td>写入语句</td>
</tr>
<tr class="even">
<td>架构语句</td>
<td>Schema</td>
<td>不作要求</td>
</tr>
<tr class="odd">
<td>函数语句</td>
<td>Functions</td>
<td>不作要求</td>
</tr>
<tr class="even">
<td>跨库语句</td>
<td>Multidatabase</td>
<td>不作要求</td>
</tr>
<tr class="odd">
<td>安全语句</td>
<td>Security</td>
<td>不作要求</td>
</tr>
</tbody>
</table>
<h4 id="格式规范-patterns">2.1. 格式规范 Patterns</h4>
<h5 id="节点-node">2.1.1. 节点 Node</h5>
<p>单个节点用<strong>一对括号</strong>表示。</p>
<p>下式描述了单个节点，并使用变量 a 命名了该节点。</p>
<pre class="cypher"><code>(a)</code></pre>
<h5 id="关系-relationship">2.1.2. 关系 Relationship</h5>
<p>描述多个节点和它们之间的<strong>有向关系</strong>通过<strong>两个减号和一个左/右单书名号</strong>表示。</p>
<p>下式描述了两个节点，一个到另一个的单一关系，两个节点都分别命名为 a 和 b。注意这个关系是有向的，方向为a指向b，能够从箭头的方向直观地看出。</p>
<pre class="cypher"><code>(a)--&gt;(b)</code></pre>
<p>下式描述了三个节点的复杂关系，节点 a 和 c 都存在着指向 b 的关系。</p>
<pre class="cypher"><code>(a)--&gt;(b)&lt;--(c)</code></pre>
<p>描述多个节点和它们之间的<strong>无向关系</strong>通过<strong>两个减号</strong>表示。</p>
<p>下式描述了节点 a 与节点 b 的无向关系，这个关系可以是节点 a 指向节点 b，也可以是节点 b 指向节点 a 。</p>
<pre class="cypher"><code>(a)--(b)</code></pre>
<p>与节点一样，关系也可以命名。通过<strong>一对方括号</strong>将两个减号分开来描述关系。有向关系和无向关系使用的描述方法相同。</p>
<pre class="cypher"><code>(a)-[r]-&gt;(b)
(a)-[r]-(b)</code></pre>
<h5 id="变长关系-variable-length-relationship-路径-path">2.1.3. 变长关系 Variable-length Relationship | 路径 Path</h5>
<p>当关系描述变得越来越复杂时，简单的表达式无法满足关系描述的需求，故引入变长关系，通过在关系的方括号中的*<strong>N..M</strong>来描述。</p>
<pre class="cypher"><code>(a)-[*2]-&gt;(b)</code></pre>
<p>上式描述了一个包含三个节点和两个关系的图，为一条长度为2的路径。它的等同于下式：</p>
<pre class="cypher"><code>(a)--&gt;()--&gt;(b)</code></pre>
<p>指定的两个节点间的路径长度还可以指定一个范围，下式描述了节点 a 到节点 b 的一条长度为3~5的路径。</p>
<pre class="cypher"><code>(a)-[*3..5]-&gt;(b)</code></pre>
<p>上式中的3和5都可以省略，分别表示大于等于3和小于等于5的路径。若3和5同时省略，则表示长度大于等于1的所有路径。</p>
<pre class="cypher"><code>(a)-[*3..]-&gt;(b)
(a)-[*..5]-&gt;(b)
(a)-[*]-&gt;(b)</code></pre>
<p>路径长度为0表示节点自身，下式描述了节点 a 到节点 b 的长度为1的路径以及节点 a 自身。</p>
<pre class="cypher"><code>(a)-[*0..1]-&gt;(b)</code></pre>
<blockquote>
<p>找到一条最短路径shortestPath()</p>
<pre class="cypher"><code>shortestPath((n1:Person)-[*..6]-(n2:Person))</code></pre>
<p>找到所有的最短路径allShortestPaths()</p>
<pre class="cypher"><code>allShortestPaths((n1:Person)-[*..6]-&gt;(n2:Person))</code></pre>
<p>计算路径数量</p>
<pre class="cypher"><code>size((n)--&gt;()--&gt;())</code></pre>
</blockquote>
<h5 id="标签-label">2.1.4. 标签 Label</h5>
<p>节点和关系都可以通过<strong>冒号加标签名</strong>来表示节点所具有的标签。</p>
<p>下式描述了在节点 a 指向节点 b 的关系中，节点 a 必须具有标签 <code>User</code> 。</p>
<pre class="cypher"><code>(a:User)--&gt;(b)</code></pre>
<p>一个节点也可以具有多个标签。</p>
<pre class="cypher"><code>(a:User:Admin)--&gt;(b)</code></pre>
<p>同节点一样，关系也可以具有标签。</p>
<pre class="cypher"><code>(a)-[r:REL_TYPE]-&gt;(b)</code></pre>
<p>但是与节点不同是，关系的标签只能具有一个。如果想要列出两节点间的多种关系，可以通过用管道符 <code>|</code> 间隔列出多个标签。</p>
<pre class="cypher"><code>(a)-[r:TYPE1 | TYPE2]-&gt;(b)</code></pre>
<blockquote>
<p>列出节点的所有标签</p>
<pre class="cypher"><code>labels(n)</code></pre>
</blockquote>
<h5 id="属性-properties">2.1.5. 属性 Properties</h5>
<p>节点和关系都可以具有用<strong>键值对</strong>表示的属性。</p>
<p>下式描述了节点 a 具有两个属性 <code>name</code> 和 <code>sport</code>，属性值分别为 <code>'Andy'</code> 和 <code>'Brazilian Ju-Jitsu'</code> 。</p>
<pre class="cypher"><code>(a &#123;name: &#39;Andy&#39;, sport: &#39;Brazilian Ju-Jitsu&#39;&#125;)</code></pre>
<p>下式描述了节点 a 指向节点 b 的关系中，关系的属性 <code>blocked</code> 的值为 <code>false</code> 。</p>
<pre class="cypher"><code>(a)-[&#123;blocked: false&#125;]-&gt;(b)</code></pre>
<h5 id="路径变量-path-variables">2.1.6. 路径变量 Path Variables</h5>
<p>上面提到的路径可以声明为变量。</p>
<pre class="cypher"><code>p = (a)-[*3..5]-&gt;(b)</code></pre>
<h4 id="数据类型-datatype">2.2. 数据类型 Datatype</h4>
<p>此处只列出了一些值得注意的数据类型。</p>
<h5 id="列表-list">2.2.1. 列表 List</h5>
<p>用方括号声明列表</p>
<pre class="cypher"><code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] AS list</code></pre>
<blockquote>
<p>列表长度</p>
<pre class="cypher"><code>size(list)</code></pre>
</blockquote>
<blockquote>
<p>创建一个数字列表，以<code>$firstNum</code>开始，以<code>$lastNum</code>结束，步长为<code>$step</code>（步长为可选参数，不加为1）</p>
<pre class="cypher"><code>range($firstNum, $lastNum, $step)</code></pre>
</blockquote>
<blockquote>
<p>逆序列表</p>
<pre class="cypher"><code>reverse($list)</code></pre>
</blockquote>
<blockquote>
<p>判断列表是否为空</p>
<pre class="cypher"><code>isEmpty(list)</code></pre>
</blockquote>
<blockquote>
<p>list循环简约的表达</p>
<pre class="cypher"><code>reduce(accumulator = initial, variable IN list | expression)</code></pre>
</blockquote>
<blockquote>
<p>通过节点列表创建属性列表</p>
<pre><code>[x IN list | x.prop]</code></pre>
<p>筛选列表内容</p>
<pre><code>[x IN list WHERE x.prop &lt;&gt; $value]</code></pre>
<p>通过节点列表创建经过筛选的属性列表</p>
<pre><code>[x IN list WHERE x.prop &lt;&gt; $value | x.prop]</code></pre>
<blockquote>
<p>列表谓词逻辑判断（全真、任意、全假、唯一的条件成立时返回true，否则返回false）</p>
<pre class="cypher"><code>all(variable IN list WHERE predicate)
any(variable IN list WHERE predicate)
none(variable IN list WHERE predicate)
single(variable IN list WHERE predicate)</code></pre>
</blockquote>
</blockquote>
<p>列表索引、列表切片</p>
<pre class="cypher"><code>list[$idx]
list[$startIdx..$endIdx]</code></pre>
<p>通过 <code>UNWIND</code> 可以将列表中的每一项展开为单独的列</p>
<pre class="cypher"><code>UNWIND $names AS name
MATCH (n &#123;name: name&#125;)
RETURN avg(n.age)</code></pre>
<p>通过 <code>IN</code> 可以检查某元素是否在列表中</p>
<pre class="cypher"><code>n.property IN [$value1, $value2]</code></pre>
<h5 id="字典-map">2.2.2. 字典 Map</h5>
<p>用花括号声明字典</p>
<pre><code>&#123;name: &#39;Alice&#39;, age: 38,
 address: &#123;city: &#39;London&#39;, residential: true&#125;&#125;</code></pre>
<p>通过字典的key获取value</p>
<pre class="cypher"><code>map.name, map.age, map.children[0]</code></pre>
<h5 id="空值-null">2.2.3. 空值 null</h5>
<p>空值为 <code>null</code></p>
<h4 id="操作符-operators">2.3. 操作符 Operators</h4>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Aggregation operators</td>
<td><code>DISTINCT</code></td>
</tr>
<tr class="even">
<td>Property operators</td>
<td><code>.</code> for static property access, <code>[]</code> for dynamic property access, <code>=</code> for replacing all properties, <code>+=</code> for mutating specific properties</td>
</tr>
<tr class="odd">
<td>Mathematical operators</td>
<td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code></td>
</tr>
<tr class="even">
<td>Comparison operators</td>
<td><code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>IS NULL</code>, <code>IS NOT NULL</code></td>
</tr>
<tr class="odd">
<td>String operators</td>
<td><code>STARTS WITH</code>, <code>ENDS WITH</code>, <code>CONTAINS</code>, <code>+</code> for concatenation, <code>=~</code> for regex matching</td>
</tr>
<tr class="even">
<td>Boolean operators</td>
<td><code>AND</code>, <code>OR</code>, <code>XOR</code>, <code>NOT</code></td>
</tr>
<tr class="odd">
<td>Condition operators</td>
<td><code>CASE</code></td>
</tr>
</tbody>
</table>
<h5 id="聚合运算符">2.3.1. 聚合运算符</h5>
<p>去重 <code>DISTINCT</code></p>
<pre class="cypher"><code>CREATE
  (a:Person &#123;name: &#39;Anne&#39;, eyeColor: &#39;blue&#39;&#125;),
  (b:Person &#123;name: &#39;Bill&#39;, eyeColor: &#39;brown&#39;&#125;),
  (c:Person &#123;name: &#39;Carol&#39;, eyeColor: &#39;blue&#39;&#125;)
WITH [a, b, c] AS ps
UNWIND ps AS p
RETURN DISTINCT p.eyeColor</code></pre>
<pre><code>p.eyeColor

&quot;blue&quot;
&quot;brown&quot;</code></pre>
<h5 id="属性运算符">2.3.2. 属性运算符</h5>
<p>静态获取属性 <code>.</code></p>
<pre class="cypher"><code>CREATE
  (a:Person &#123;name: &#39;Jane&#39;, livesIn: &#39;London&#39;&#125;),
  (b:Person &#123;name: &#39;Tom&#39;, livesIn: &#39;Copenhagen&#39;&#125;)
WITH a, b
MATCH (p:Person)
RETURN  p.name</code></pre>
<pre><code>p.name

&quot;Jane&quot;
&quot;Tom&quot;</code></pre>
<blockquote>
<p>获取嵌套的属性</p>
<pre class="cypher"><code>WITH &#123;person: &#123;name: &#39;Anne&#39;, age: 25&#125;&#125; AS p
RETURN p.person.name</code></pre>
</blockquote>
<p>获取动态计算的属性 <code>[]</code></p>
<pre class="cypher"><code>CREATE
  (a:Restaurant &#123;name: &#39;Hungry Jo&#39;, rating_hygiene: 10, rating_food: 7&#125;),
  (b:Restaurant &#123;name: &#39;Buttercup Tea Rooms&#39;, rating_hygiene: 5, rating_food: 6&#125;),
  (c1:Category &#123;name: &#39;hygiene&#39;&#125;),
  (c2:Category &#123;name: &#39;food&#39;&#125;)
WITH a, b, c1, c2
MATCH (restaurant:Restaurant), (category:Category)
WHERE restaurant[&quot;rating_&quot; + category.name] &gt; 6
RETURN DISTINCT restaurant.name</code></pre>
<pre><code>restaurant.name

&quot;Hungry Jo&quot;</code></pre>
<p>替换属性 <code>=</code></p>
<pre class="cypher"><code>CREATE (a:Person &#123;name: &#39;Jane&#39;, age: 20&#125;)
WITH a
MATCH (p:Person &#123;name: &#39;Jane&#39;&#125;)
SET p = &#123;name: &#39;Ellen&#39;, livesIn: &#39;London&#39;&#125;
RETURN p.name, p.age, p.livesIn</code></pre>
<pre><code>p.name   p.age   p.livesIn

&quot;Ellen&quot;  &lt;null&gt;  &quot;London&quot;</code></pre>
<p>添加属性 <code>+=</code></p>
<pre class="cypher"><code>CREATE (a:Person &#123;name: &#39;Jane&#39;, age: 20&#125;)
WITH a
MATCH (p:Person &#123;name: &#39;Jane&#39;&#125;)
SET p += &#123;name: &#39;Ellen&#39;, livesIn: &#39;London&#39;&#125;
RETURN p.name, p.age, p.livesIn</code></pre>
<pre><code>p.name   p.age   p.livesIn

&quot;Ellen&quot;  20      &quot;London&quot;</code></pre>
<h5 id="数学运算符">2.3.3. 数学运算符</h5>
<p>加 <code>+</code></p>
<p>减 <code>-</code></p>
<p>乘 <code>*</code></p>
<p>除 <code>/</code></p>
<p>模 <code>%</code></p>
<p>乘方 <code>^</code></p>
<h5 id="比较运算符">2.3.4. 比较运算符</h5>
<p>相等 <code>=</code></p>
<p>不相等 <code>&lt;&gt;</code></p>
<p>小于 <code>&lt;</code></p>
<p>大于 <code>&gt;</code></p>
<p>小于等于 <code>&lt;=</code></p>
<p>大于等于 <code>&gt;=</code></p>
<p>为空 <code>IS NULL</code></p>
<p>不为空 <code>IS NOT NULL</code></p>
<blockquote>
<p>可进行链式比较：</p>
<pre class="cypher"><code>MATCH (n) WHERE 21 &lt; n.age &lt;= 30 RETURN n</code></pre>
<p>等同于</p>
<pre class="cypher"><code>MATCH (n) WHERE 21 &lt; n.age AND n.age &lt;= 30 RETURN n</code></pre>
<p>另一个例子：</p>
<pre class="cypher"><code>a &lt; b = c &lt;= d &lt;&gt; e</code></pre>
<p>等同于</p>
<pre class="cypher"><code>a &lt; b AND b = c AND c &lt;= d AND d &lt;&gt; e</code></pre>
</blockquote>
<h5 id="字符串运算符">2.3.5. 字符串运算符</h5>
<ul>
<li>判断字符串是否以特定内容为开头 <code>STARTS WITH</code></li>
<li>判断字符串是否以特定内容为结尾 <code>ENDS WITH</code></li>
<li>判断字符串是否以包含特定内容 <code>CONTAINS</code></li>
</ul>
<pre class="cypher"><code>WITH [&#39;John&#39;, &#39;Mark&#39;, &#39;Jonathan&#39;, &#39;Bill&#39;] AS somenames
UNWIND somenames AS names
WITH names AS candidate
WHERE candidate STARTS WITH &#39;Jo&#39;
RETURN candidate</code></pre>
<pre><code>candidate

&quot;John&quot;
&quot;Jonathan&quot;</code></pre>
<p>字符串拼接 <code>+</code></p>
<p>字符串模糊匹配 <code>=~</code></p>
<pre class="cypher"><code>WITH [&#39;mouse&#39;, &#39;chair&#39;, &#39;door&#39;, &#39;house&#39;] AS wordlist
UNWIND wordlist AS word
WITH word
WHERE word =~ &#39;.*ous.*&#39;
RETURN word</code></pre>
<pre><code>word

&quot;mouse&quot;
&quot;house&quot;</code></pre>
<h5 id="布尔运算符">2.3.6. 布尔运算符</h5>
<p>与 <code>AND</code></p>
<p>或 <code>OR</code></p>
<p>异或 <code>XOR</code></p>
<p>非 <code>NOT</code></p>
<h5 id="条件控制运算符">2.3.7. 条件控制运算符</h5>
<p>从匹配的 <code>WHEN</code> 值中返回 <code>THEN</code> 值， <code>ELSE</code> 值是可选的，不加 <code>ELSE</code> 则替换为 <code>null</code></p>
<pre class="cypher"><code>CASE n.eyes
 WHEN &#39;blue&#39; THEN 1
 WHEN &#39;brown&#39; THEN 2
 ELSE 3
END</code></pre>
<h4 id="读取语句">2.4. 读取语句</h4>
<p>读取查询结构</p>
<pre class="cypher"><code>[MATCH WHERE]
[OPTIONAL MATCH WHERE]
[WITH [ORDER BY] [SKIP] [LIMIT]]
RETURN [ORDER BY] [SKIP] [LIMIT]</code></pre>
<h5 id="match-匹配语句">2.4.1. MATCH 匹配语句</h5>
<p>匹配所有节点。</p>
<pre class="cypher"><code>MATCH (n)</code></pre>
<p>匹配某标签的所有节点。</p>
<pre class="cypher"><code>MATCH (movie:Movie)</code></pre>
<p>匹配相关联的节点。</p>
<pre class="cypher"><code>MATCH (director &#123;name: &#39;Oliver Stone&#39;&#125;)--(movie)</code></pre>
<p>匹配关系。</p>
<pre class="cypher"><code>MATCH (n:Person)-[:KNOWS]-&gt;(m:Person) WHERE n.name = &#39;Alice&#39; </code></pre>
<p>通过 <code>OPTIONAL MATCH</code> 匹配，匹配结果中的缺失值会用 <code>null</code> 代替，若无结果也会返回 <code>null</code> 。</p>
<pre class="cypher"><code>OPTIONAL MATCH (n)-[r]-&gt;(m) </code></pre>
<h5 id="where-条件语句">2.4.2. WHERE 条件语句</h5>
<p>为匹配语句添加约束条件。</p>
<pre class="cypher"><code>MATCH (n)--&gt;(m) 
WHERE n.age = m.age</code></pre>
<h5 id="return-返回语句">2.4.3. RETURN 返回语句</h5>
<p>返回所有变量的值。</p>
<pre class="cypher"><code>RETURN *</code></pre>
<p>为结果列使用别名。</p>
<pre class="cypher"><code>RETURN n AS columnName</code></pre>
<p>结果去重。</p>
<pre class="cypher"><code>RETURN DISTINCT n</code></pre>
<p>结果排序。</p>
<pre class="cypher"><code>RETURN ORDER BY n.property</code></pre>
<p>结果降序/升序排序。</p>
<pre class="cypher"><code>RETURN ORDER BY n.property DESC
RETURN ORDER BY n.property ASC</code></pre>
<p>跳过指定数量的结果。</p>
<pre class="cypher"><code>RETURN SKIP $skipNumber</code></pre>
<p>指定返回结果的数量。</p>
<pre class="cypher"><code>RETURN LIMIT $limitNumber</code></pre>
<p>返回结果数。</p>
<pre class="cypher"><code>RETURN count(*)</code></pre>
<h5 id="with-子查询语句">2.4.4. WITH 子查询语句</h5>
<p>WITH 语法类似于 RETURN。它会将查询明确地分为多个部分，可以声明一些变量转移到下一部分。</p>
<pre class="cypher"><code>MATCH (user)-[:FRIEND]-(friend)
WHERE user.name = $name
WITH user, count(friend) AS friends
WHERE friends &gt; 10
RETURN user</code></pre>
<h5 id="union-合并语句">2.4.5. UNION 合并语句</h5>
<p>将多个查询结果合并，合并时需要注意结果列的名称和类型必须匹配。</p>
<pre class="cypher"><code>MATCH (a)-[:KNOWS]-&gt;(b)
RETURN b.name
UNION
MATCH (a)-[:LOVES]-&gt;(b)
RETURN b.name</code></pre>
<h4 id="写入语句">2.5. 写入语句</h4>
<p>只写查询结构</p>
<pre class="cypher"><code>(CREATE | MERGE)*
[SET|DELETE|REMOVE|FOREACH]*
[RETURN [ORDER BY] [SKIP] [LIMIT]]</code></pre>
<p>读写查询结构</p>
<pre class="cypher"><code>[MATCH WHERE]
[OPTIONAL MATCH WHERE]
[WITH [ORDER BY] [SKIP] [LIMIT]]
(CREATE | MERGE)*
[SET|DELETE|REMOVE|FOREACH]*
[RETURN [ORDER BY] [SKIP] [LIMIT]]</code></pre>
<h5 id="create-创建语句">2.5.1. CREATE 创建语句</h5>
<p>创建节点</p>
<pre class="cypher"><code>CREATE (n)</code></pre>
<p>创建带标签的节点</p>
<pre class="cypher"><code>CREATE (n:Person)</code></pre>
<p>创建带属性的节点</p>
<pre class="cypher"><code>CREATE (a &#123;name: &#39;Andy&#39;&#125;)</code></pre>
<p>创建关系</p>
<pre class="cypher"><code>CREATE (n)-[:LOVES &#123;since: $value&#125;]-&gt;(m)</code></pre>
<p>匹配相关节点创建关系</p>
<pre class="cypher"><code>MATCH (a:Person), (b:Person)
WHERE a.name = &#39;A&#39; AND b.name = &#39;B&#39;
CREATE (a)-[r:RELTYPE]-&gt;(b)</code></pre>
<h5 id="set-设置语句">2.5.2. SET 设置语句</h5>
<p>设置标签和属性的值。</p>
<pre class="cypher"><code>SET n:Person</code></pre>
<pre class="cypher"><code>SET n.property1 = $value1, n.property2 = $value2</code></pre>
<pre class="cypher"><code>SET n = $map</code></pre>
<pre class="cypher"><code>SET n += $map</code></pre>
<h5 id="merge-归并语句">2.5.3. MERGE 归并语句</h5>
<p>匹配符合条件的节点。若没有符合条件的节点，将根据所设条件创建一个节点。</p>
<pre class="cypher"><code>MERGE (michael:Person &#123;name: &#39;Michael Douglas&#39;&#125;)
RETURN michael</code></pre>
<p>归并匹配节点的共性属性，创建新的节点。</p>
<pre class="cypher"><code>MATCH (person:Person)
MERGE (city:City &#123;name: person.bornIn&#125;)
RETURN person, city</code></pre>
<p>匹配符合条件的节点，并通过 <code>MERGE</code> 为节点创建关系。</p>
<pre class="cypher"><code>MATCH (charlie:Person &#123;name: &#39;Charlie Sheen&#39;&#125;), (wallStreet:Movie &#123;title: &#39;Wall Street&#39;&#125;)
MERGE (charlie)-[r:ACTED_IN]-&gt;(wallStreet)</code></pre>
<blockquote>
<p>注意 <code>MERGE</code> 并不能将标签和属性完全相同的节点合并为同一个，而是以寻找节点共性、创建共性新节点的功能存在。在创建关系时也经常使用 <code>MERGE</code> 。</p>
</blockquote>
<h5 id="delete-删除语句">2.5.4. DELETE 删除语句</h5>
<p>删除节点和关系。</p>
<pre class="cypher"><code>DELETE n, r</code></pre>
<p>通过 <code>DETACH DELETE</code> 分离式删除，将会删除节点以及节点所有的关系。</p>
<pre class="cypher"><code>DETACH DELETE n</code></pre>
<h5 id="remove-移除语句">2.5.5. REMOVE 移除语句</h5>
<p>移除标签和属性。</p>
<pre class="cypher"><code>REMOVE n:Person, n.property</code></pre>
<h5 id="foreach-遍历语句">2.5.6. FOREACH 遍历语句</h5>
<p>遍历指定内容。</p>
<p>为路径中的所有关系添加属性。</p>
<pre class="cypher"><code>FOREACH (r IN relationships(path) | SET r.marked = true)</code></pre>
<p>为列表中的每个值创建 <code>name</code> 为这个值的 <code>Person</code> 节点。</p>
<pre class="cypher"><code>FOREACH (value IN coll | CREATE (:Person &#123;name: value&#125;))</code></pre>
<h5 id="load-csv-导入语句">2.5.7. LOAD CSV 导入语句</h5>
<p>将需要导入的文件放进 neo4j 目录下 import 文件夹中， <code>'file:///filename.csv'</code>为导入路径，也可输入绝对路径进行导入。</p>
<pre class="cypher"><code>LOAD CSV FROM &#39;file:///artists.csv&#39; AS line
CREATE (:Artist &#123;name: line[1], year: toInteger(line[2])&#125;)</code></pre>
<p>若csv文件中有headers，可使用以下方式导入。</p>
<pre class="cypher"><code>LOAD CSV WITH HEADERS FROM &#39;file:///artists-with-headers.csv&#39; AS line
CREATE (:Artist &#123;name: line.Name, year: toInteger(line.Year)&#125;)</code></pre>
<p>当导入数据量较大时，可以设置执行一定数量行后自动提交一次事物。</p>
<pre class="cypher"><code>:auto USING PERIODIC COMMIT
LOAD CSV WITH HEADERS FROM &#39;file:///artists-with-headers.csv&#39; AS line
CREATE (:Artist &#123;name: line.Name, year: toInteger(line.Year)&#125;)</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-01-14T16:00:00.000Z" itemprop="datePublished">2022/01/15</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%95%B0%E6%8D%AE%E5%BA%93-Neo4j/" rel="tag">计算机 - 数据库 - Neo4j</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-时间序列分析"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/">时间序列分析</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="时间序列的定义">时间序列的定义</h2>
<figure>
<img src="../images/时间序列的定义.png" alt="时间序列的定义" /><figcaption aria-hidden="true">时间序列的定义</figcaption>
</figure>
<h2 id="时间序列的特征">时间序列的特征</h2>
<ul>
<li>观测值按照时间有序排列。</li>
<li>每一个时刻的取值或数据点的位置有一定的随机性。</li>
<li>前后观测值之间有一定的相关性。</li>
<li>从整体上看，往往呈现某种趋势性或周期性。</li>
</ul>
<h2 id="时间序列的分类">时间序列的分类</h2>
<ul>
<li>按所研究的对象的多少
<ul>
<li>一元时间序列</li>
<li>多元时间序列</li>
</ul></li>
<li>按时间的连续性
<ul>
<li>离散时间序列</li>
<li>连续时间序列</li>
</ul></li>
<li>按序列的统计特性分
<ul>
<li>平稳时间序列</li>
<li>非平稳时间序列</li>
</ul></li>
<li>按序列的分布规律
<ul>
<li>高斯型(Gaussian)时间序列</li>
<li>非高斯型(non-Gaussian)时间序列</li>
</ul></li>
</ul>
<h2 id="时间序列的建立">时间序列的建立</h2>
<ul>
<li>时间序列数据的采集
<ul>
<li>按照一定的时间间隔对所研究的系统响应进行记录和观察，我们称之为采样。</li>
<li>相应地把记录和观察时间间隔称为采样间隔。</li>
<li>选择合适的采样间隔是建立时间序列的关键。</li>
<li>理想的采样间隔就是既没有损失信息，也没有出现信息冗余。</li>
</ul></li>
<li>离群点的检验与处理
<ul>
<li>离群点(Outlier)是指一个时间序列中，远离序列一般水平的极端大值和极端小值。</li>
<li>离群点可以通过将序列与平滑值的比较来检验。</li>
<li>离群点的分类
<ul>
<li>加性离群点：仅对序列产生一个即时效应。</li>
<li>革新离群点：标志着一个长期的外部干扰作用于系统的开始。</li>
<li>水平位移离群点：它的出现改变了系统结构，使序列均值发生水平位移。</li>
<li>暂时变更离群点：它的出现改变了系统结构，但影响会随着时间逐渐消失。</li>
</ul></li>
<li>离群点的处理
<ul>
<li>直接进行剔除。</li>
<li>对数据模型进行修正处理分析。</li>
</ul></li>
</ul></li>
<li>缺损值(Missing value)的补足
<ul>
<li>依据系统运动轨迹或变化趋势，运用一定的方法对缺损值进行估计、推测，以补足缺损的数值。</li>
</ul></li>
</ul>
<h2 id="时间序列的建模步骤">时间序列的建模步骤</h2>
<figure>
<img src="../images/时间序列的建模步骤.png" alt="时间序列的建模步骤" /><figcaption aria-hidden="true">时间序列的建模步骤</figcaption>
</figure>
<h2 id="时间序列的描述">时间序列的描述</h2>
<ul>
<li><p>数据图法</p></li>
<li><p>指标法</p>
<ul>
<li><p>核心指标反映系统的动态特征。</p></li>
<li><p>指标描述</p>
<ul>
<li><p>增长量：时间序列中各时点与基期水平的差值。</p>
<ul>
<li><p>逐期增长量：某时点与上一时点之差</p>
<figure>
<img src="../images/formula1.png" alt="formula" /><figcaption aria-hidden="true">formula</figcaption>
</figure></li>
<li><p>累计增长量：某时点与某一个固定点之差</p>
<figure>
<img src="../images/formula2.png" alt="formula" /><figcaption aria-hidden="true">formula</figcaption>
</figure></li>
</ul></li>
<li><p>增长速度：增长量与基期之比</p>
<ul>
<li><p>环比增长速度</p>
<figure>
<img src="../images/formula3.png" alt="formula" /><figcaption aria-hidden="true">formula</figcaption>
</figure></li>
</ul></li>
<li><p>发展速度：两个不同时间点的比值</p>
<ul>
<li><p>环比：相邻两个时间点之比</p>
<figure>
<img src="../images/formula4.png" alt="formula" /><figcaption aria-hidden="true">formula</figcaption>
</figure></li>
<li><p>定基比：与某一固定点之比</p>
<figure>
<img src="../images/formula5.png" alt="formula" /><figcaption aria-hidden="true">formula</figcaption>
</figure></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>模型法</p>
<ul>
<li>根据统计理论和数学方法，建立描述该序列的适应或最优统计模型，并进而进行预测和控制。</li>
<li>模型方法
<ul>
<li>以时间回归</li>
<li>移动平均</li>
<li>指数平滑</li>
</ul></li>
</ul></li>
</ul>
<h2 id="时间序列分析的目的">时间序列分析的目的</h2>
<ul>
<li>描述——认识系统的运行规律性。</li>
<li>建模——刻画系统结构和生成机制。</li>
<li>预测——预测系统未来行为。</li>
<li>控制——控制系统未来行为。</li>
</ul>
<h2 id="时间序列分析的方法">时间序列分析的方法</h2>
<p>描述性时间序列分析：沿着时间的发展，记录下随机变量的数据，通过直观的数据比较或绘图观察，寻找序列中蕴含的发展规律。</p>
<p>统计时间序列分析</p>
<ul>
<li>频域分析法
<ul>
<li>特点：非常有用的动态数据分析方法，但是由于分析方法复杂，结果抽象，有一定的使用局限性。</li>
</ul></li>
<li>时域分析法
<ul>
<li>原理：事件的发展通常都具有一定的惯性，这种惯性用统计的语言来描述就是序列值之间存在着一定的相关关系，这种相关关系通常具有某种统计规律。</li>
<li>目的：寻找出序列值之间相关关系的统计规律，并拟合出适当的数学模型来描述这种规律，进而利用这个拟合模型预测序列未来的走势。</li>
<li>特点：理论基础扎实，操作步骤规范，分析结果易于解释，是时间序列分析的主流方法 。</li>
<li>基本步骤
<ul>
<li>考察观察值序列的特征</li>
<li>根据序列的特征选择适当的拟合模型</li>
<li>根据序列的观察数据确定模型的参数值</li>
<li>检验模型，优化模型</li>
<li>利用拟合好的模型来推断序列其它的统计性质或预测序列将来的发展</li>
</ul></li>
</ul></li>
</ul>
<h2 id="时间序列分析和其它统计科目的主要区别">时间序列分析和其它统计科目的主要区别</h2>
<p><strong>取样：有时间关联的相依样本</strong>；独立样本。</p>
<p><strong>目的：建立模型进行预报和控制</strong>；统计推断。</p>
<p><strong>回归模型与时序模型：动态模型</strong>；静态模型。</p>
<h2 id="时间序列的特征统计量">时间序列的特征统计量</h2>
<ul>
<li><p>均值</p>
<figure>
<img src="../images/图片1.png" alt="图片1" /><figcaption aria-hidden="true">图片1</figcaption>
</figure></li>
<li><p>方差</p>
<figure>
<img src="../images/图片2.png" alt="图片2" /><figcaption aria-hidden="true">图片2</figcaption>
</figure></li>
<li><p>自协方差</p>
<figure>
<img src="../images/图片3.png" alt="图片3" /><figcaption aria-hidden="true">图片3</figcaption>
</figure></li>
<li><p>延迟 k 自协方差</p>
<p><img src="../images/图片8.png" alt="图片8" style="zoom:80%;" /></p>
<p>当k=0时，</p>
<p><img src="../images/图片9.png" alt="图片9" style="zoom: 80%;" /></p>
<p>估计值</p>
<p><img src="../images/图片11.png" alt="图片11" style="zoom: 80%;" /></p></li>
<li><p>自相关系数</p>
<figure>
<img src="../images/图片4.png" alt="图片4" /><figcaption aria-hidden="true">图片4</figcaption>
</figure></li>
<li><p>延迟 k 自相关系数</p>
<p><img src="../images/图片10.png" alt="图片10" style="zoom: 67%;" /></p>
<p>估计值</p>
<p><img src="../images/图片12.png" alt="图片12"  /></p></li>
</ul>
<h2 id="时间序列的预处理">时间序列的预处理</h2>
<h3 id="检验时间序列的平稳性">检验时间序列的平稳性</h3>
<h4 id="平稳时间序列">平稳时间序列</h4>
<ul>
<li><p>严平稳：所有的统计学性质都不随时间变化。往往只具有理论意义。</p></li>
<li><p>宽平稳：只要保证低阶矩平稳即可。弱平稳、二阶平稳。</p>
<figure>
<img src="../images/图片5.png" alt="图片5" /><figcaption aria-hidden="true">图片5</figcaption>
</figure></li>
<li><p>严平稳和宽平稳</p>
<ul>
<li>严平稳条件比宽平稳条件苛刻，通常情况下，严平稳（低阶矩存在）能推出宽平稳成立，而宽平稳序列不能反推严平稳成立。</li>
<li>不存在低阶矩的严平稳序列不满足宽平稳条件，例如服从柯西分布的严平稳序列就不是宽平稳序列（没有一、二阶矩）。</li>
<li>当序列服从多元正态分布时，宽平稳可以推出严平稳。</li>
</ul></li>
</ul>
<h4 id="平稳时间序列的性质">平稳时间序列的性质</h4>
<ul>
<li><p>常数均值</p>
<p><img src="../images/图片6.png" alt="图片6" style="zoom:48%;" /></p></li>
<li><p>自协方差函数和自相关函数只依赖于时间的平移长度而与时间的起止点无关</p>
<p><img src="../images/图片7.png" alt="图片7" style="zoom:48%;" /></p></li>
</ul>
<h4 id="平稳时间序列的意义">平稳时间序列的意义</h4>
<ul>
<li>平稳的基本思想是：时间序列的行为并不随时间改变。</li>
<li>在平稳序列场合，序列的均值等于常数，这意味着原本含有可列多个随机变量的均值序列变成了只含有一个变量的常数序列。</li>
<li>原本每个随机变量的均值（方差，自相关系数）只能依靠唯一的一个样本观察值去估计，现在由于平稳性，每一个统计量都将拥有大量的样本观察值。</li>
<li>极大地减少了随机变量的个数，并增加了待估变量的样本容量。</li>
<li>极大地简化了时序分析的难度，同时也提高了对特征统计量的估计精度。</li>
</ul>
<h4 id="平稳性检验常用方法">平稳性检验常用方法</h4>
<ul>
<li><p>图检验</p>
<ul>
<li>时序图检验
<ul>
<li>平稳时间序列具有常数均值和方差。意味着平稳序列的时序图应该显示出该序列始终在一个常数值附近波动，而且波动的范围有界的特点</li>
<li>如果序列的时序图显示出该序列有明显的趋势性或周期性，那该序列通常就不是平稳序列。</li>
</ul></li>
<li>自相关图检验
<ul>
<li>自相关图是一个平面二维坐标悬垂线图，横坐标表示延迟时期数，纵坐标表示自相关系数，悬垂线的长度表示自相关系数的大小。</li>
<li>平稳序列通常具有短期相关性。用自相关系数来描述就是随着延迟阶数k的增加
<ul>
<li>平稳序列的自相关系数 <span class="math inline">\(ρ_k\)</span> 会很快地衰减向零。</li>
<li>非平稳序列的自相关系数 <span class="math inline">\(ρ_k\)</span> 衰减向零的速度通常比较慢。</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>单位根检验</p>
<ul>
<li><p>DF检验</p>
<p>DF检验是从最简单的一种情况着手进行构造的单位根检验方法。假设序列的确定性部分可以只由过去一期的历史数据描述，即序列可以表达为</p>
<p><img src="../images/图片14.png" alt="图片14" style="zoom: 67%;" /></p>
<p>显然该序列只有一个特征根，且特征根为</p>
<p><img src="../images/图片15.png" alt="图片15" style="zoom:67%;" /></p>
<p>通过检验特征根是在单位圆内还是单位圆上（外）可以检验序列的平稳性。由于现实生活中绝大多数序列都是非平稳序列，所以单位根检验的原假设为序列非平稳，备择假设是序列平稳</p>
<p><img src="../images/图片13.png" alt="图片13" style="zoom: 67%;" /></p>
<p>DF检验的三种类型</p>
<p>类型一：无漂移项自回归结构</p>
<p>拒绝H0，表明零均值平稳序列</p>
<p>拒绝H0，表明零均值一阶自相关平稳序列</p>
<p>类型二：有漂移项自回归结构</p>
<p>拒绝H0，表明均值为φ0的平稳序列</p>
<p>拒绝H0，表明均值非0的一阶自相关平稳序列</p>
<p>类型三：带趋势回归结构</p>
<p>拒绝H0，表明带趋势平稳序列。</p>
<p>拒绝H0，表明带趋势的一阶自相关平稳序列</p>
<p>如果序列的结构考虑如上三种类型（6种子类型），统计量的P值均显著大于显著性水平，则可以判断，序列考虑如上6种结构之一提取确定性信息，随机性部分都不能实现平稳。</p></li>
<li><p>ADF检验</p>
<p>DF检验只适用于最简单的、确定性部分只由上一期历史数据描述的序列平稳性检验。为了使DF检验能适用于任意期确定性信息提取，人们对DF检验进行了一定的修正，得到了增广DF检验（augmented Dickey-Fuller），简记为ADF检验。</p>
<p>如果序列平稳，它必须满足所有非零特征根都在单位圆内。假如有一个单位根存在，不妨假设 λ1=1，则序列非平稳。把λ1=1代入特征方程，得到</p>
<p><img src="../images/图片16.png" alt="图片16" style="zoom: 80%;" /></p>
<p>这意味着，如果序列非平稳，存在特征根，那么序列回归系数之和恰好等于1。因而，对于序列的平稳性检验，可以通过检验它的回归系数之和的性质进行判断。</p>
<p><img src="../images/图片17.png" alt="图片17"  /></p></li>
</ul></li>
</ul>
<h3 id="检验时间序列的纯随机性">检验时间序列的纯随机性</h3>
<h4 id="纯随机序列">纯随机序列</h4>
<p>纯随机序列：如果序列满足如下两条性质，则称该序列为纯随机序列，也称为白噪声（White Noise）序列。</p>
<p><img src="../images/图片18.png" alt="图片18" style="zoom:67%;" /></p>
<p>容易证明，白噪声序列一定是平稳序列，而且是最简单的平稳序列。</p>
<h4 id="纯随机序列的性质">纯随机序列的性质</h4>
<ul>
<li><p>纯随机性：各序列值之间没有任何相关关系，即为 “没有记忆”的序列，意味着所有信息都被提出来了。</p>
<figure>
<img src="../images/图片19.png" alt="图片19" /><figcaption aria-hidden="true">图片19</figcaption>
</figure>
<p>这是一种理论上才会出现的理想状况。实际上，由于观察值序列的有限性，纯随机序列的样本自相关系数不会绝对为零。</p></li>
<li><p>方差齐性：根据马尔可夫定理，只有方差齐性假定成立时，用最小二乘法得到的未知参数估计值才是准确的、有效的。</p>
<figure>
<img src="../images/图片20.png" alt="图片20" /><figcaption aria-hidden="true">图片20</figcaption>
</figure></li>
</ul>
<h4 id="纯随机性检验的原理">纯随机性检验的原理</h4>
<ul>
<li><p>Bartlett定理：如果一个时间序列是纯随机的，得到一个观察期数为 <em>n</em> 的观察值序列，那么该序列的延迟非零期的样本自相关系数将近似服从均值为零，方差为序列观察期数倒数的正态分布</p>
<p><img src="../images/图片21.png" alt="图片21" style="zoom: 50%;" /></p></li>
<li><p>假设</p>
<ul>
<li><p>原假设：延迟期数小于或等于m期的序列值之间相互独立</p>
<figure>
<img src="../images/图片22.png" alt="图片22" /><figcaption aria-hidden="true">图片22</figcaption>
</figure></li>
<li><p>备择假设：延迟期数小于或等于m期的序列值之间有相关性</p>
<figure>
<img src="../images/图片23.png" alt="图片23" /><figcaption aria-hidden="true">图片23</figcaption>
</figure></li>
</ul></li>
<li><p>检验统计量</p>
<ul>
<li><p>Q统计量</p>
<figure>
<img src="../images/图片24.png" alt="图片24" /><figcaption aria-hidden="true">图片24</figcaption>
</figure></li>
<li><p>LB统计量</p>
<figure>
<img src="../images/图片25.png" alt="图片25" /><figcaption aria-hidden="true">图片25</figcaption>
</figure></li>
</ul></li>
</ul>
<p>为什么在本例中只检验了前6期和前12期延迟的 Q 统计量就直接判断该序列是白噪声序列</p>
<p>平稳序列通常具有短期相关性，如果序列值之间存在显著的相关关系，通常只存在于延迟时期比较短的序列值之间。 所以，如果一个平稳序列短期延迟的序列值之间都不存在显著的相关关系，通常长期延迟之间就更不会存在显著的相关关系了。假如一个平稳序列显示出显著的短期相关性, 那么该序列就一定不是白噪声序列，我们就可以对序列值之间存在的相关性进行分析。 假如此时考虑的延迟时期数太长，反而可能淹没了该序列的短期相关性。 因为平稳序列只要延迟时期足够长，自相关系数都会收敛于零。</p>
<h2 id="时间序列的平稳化">时间序列的平稳化</h2>
<h3 id="差分">差分</h3>
<ul>
<li><p><em>d</em> 阶差分</p>
<p><img src="../images/图片30.png" alt="图片30" style="zoom:80%;" /></p></li>
<li><p><em>d</em> 步差分（包括季节差分）</p>
<p><img src="../images/图片31.png" alt="图片31" style="zoom:80%;" /></p></li>
</ul>
<h4 id="差分方式的选择">差分方式的选择</h4>
<ul>
<li>对于线性趋势的序列，1阶差分可以实现趋势平稳。</li>
<li>对于曲线趋势的序列，1~3阶差分可以实现趋势平稳。</li>
<li>对于含有固定周期趋势的序列，以周期长度为差分步数，通常可以提取周期趋势。</li>
<li>方差不齐的非线性趋势的序列，可以先变换，再差分。</li>
</ul>
<h4 id="过差分">过差分</h4>
<p>一、二阶差分均能使序列达到平稳，但二阶差分序列的方差大于一阶差分的方差。方差越大估计精度就越低。可见，差分的阶数并非越高越好。</p>
<p>差分的目的是使序列平稳。为防止过差分，通常的做法是每次差分后进行一次平稳性检验，通过平稳性检验，若差分后已经是平稳序列，则停止差分运算。</p>
<h3 id="变量变换">变量变换</h3>
<p><img src="../images/图片26.png" alt="图片26" style="zoom:67%;" /></p>
<p>λ=1：没有进行实质上的转换</p>
<p>λ=1/2：平方根转换+线性转换</p>
<p>λ=1/3：立方根转换+线性转换</p>
<p>λ=0：log转换</p>
<p>λ=-1：与负倒数转换类似</p>
<p>box-cox变换的目标</p>
<ul>
<li>变换后，可以一定程度上减小不可观测的误差和预测变量的相关性。主要操作是对因变量转换，使得变换后的因变量于回归自变量具有线性相依关系，误差也服从正态分布，误差各分量是等方差且相互独立。</li>
<li>用这个变换来使得因变量获得一些性质，比如在时间序列分析中的平稳性，或者使得因变量分布为正态分布。</li>
</ul>
<h2 id="因素分解理论">因素分解理论</h2>
<h3 id="wold分解定理">Wold分解定理</h3>
<p>对于任意一个离散平稳时间序列 <span class="math inline">\(\{x_t\}\)</span> ，它都可以分解为两个不相关的平稳序列之和，确定性部分和随机性部分，</p>
<figure>
<img src="../images/图片27.png" alt="图片27" /><figcaption aria-hidden="true">图片27</figcaption>
</figure>
<p>因此，平稳序列 <span class="math inline">\(\{x_t\}\)</span> 可以表示为自回归移动平均模型（auto regression moving average, ARMA）</p>
<p><img src="../images/图片28.png" alt="图片28" style="zoom: 50%;" /></p>
<h3 id="cramer分解定理">Cramer分解定理</h3>
<p><img src="../images/image-20220113002037072.png" alt="image-20220113002037072" style="zoom: 67%;" /></p>
<h3 id="确定性因素分解">确定性因素分解</h3>
<p><img src="../images/image-20220113004415538.png" alt="image-20220113004415538" style="zoom: 67%;" /></p>
<p><img src="../images/image-20220113004430702.png" alt="image-20220113004430702" style="zoom:67%;" /></p>
<h2 id="常见确定性趋势">常见确定性趋势</h2>
<p>线性上升、下降</p>
<p>指数上升、下降（对序列取对数后，可以直线化。序列数据如果有0或负数不适用。）</p>
<p>周期趋势（可以用三角函数表示。）</p>
<p>长期趋势+周期趋势</p>
<p>多项式趋势</p>
<h2 id="延迟算子">延迟算子</h2>
<p><img src="../images/image-20220112192801404.png" alt="image-20220112192801404" style="zoom:67%;" /></p>
<h3 id="延迟算子的性质">延迟算子的性质</h3>
<p><img src="../images/image-20220112192838742.png" alt="image-20220112192838742" style="zoom:50%;" /></p>
<h3 id="延迟算子和差分的关系">延迟算子和差分的关系</h3>
<p><img src="../images/image-20220112192922461.png" alt="image-20220112192922461" style="zoom:50%;" /></p>
<h2 id="ar模型">AR模型</h2>
<p><img src="../images/image-20220112192657904.png" alt="image-20220112192657904" style="zoom: 80%;" /></p>
<h3 id="用延迟算子表达ar模型">用延迟算子表达AR模型</h3>
<p><img src="../images/image-20220112195929712.png" alt="image-20220112195929712" style="zoom:67%;" /></p>
<h3 id="ar模型的统计性质">AR模型的统计性质</h3>
<h4 id="自相关系数">自相关系数</h4>
<p><img src="../images/image-20220112201422163.png" alt="image-20220112201422163" style="zoom: 50%;" /></p>
<h3 id="ar模型的平稳性判别">AR模型的平稳性判别</h3>
<ul>
<li><p>判别原因</p>
<ul>
<li>要拟合一个平稳序列的发展，用来拟合的模型显然也应该是平稳的。</li>
<li>AR模型是常用的平稳序列的拟合模型之一，但并非所有的 AR 模型都是平稳的。</li>
</ul></li>
<li><p>判别方法</p>
<ul>
<li><p>特征根判别法</p>
<p><img src="../images/image-20220112192508872.png" alt="image-20220112192508872" style="zoom: 67%;" /></p></li>
<li><p>平稳域判别法</p>
<ul>
<li><p>AR（1）</p>
<p><img src="../images/image-20220112193949717.png" alt="image-20220112193949717" style="zoom: 67%;" /></p></li>
<li><p>AR（2）</p>
<p><img src="../images/image-20220112193924989.png" alt="image-20220112193924989" style="zoom: 67%;" /></p></li>
</ul></li>
</ul></li>
</ul>
<h3 id="平稳ar模型的统计性质">平稳AR模型的统计性质</h3>
<h4 id="均数">均数</h4>
<p>平稳序列均值为常数</p>
<h4 id="方差">方差</h4>
<p><img src="../images/image-20220112194452534.png" alt="image-20220112194452534" style="zoom:67%;" /></p>
<ul>
<li><p>AR（1）</p>
<p><img src="../images/image-20220112194649057.png" alt="image-20220112194649057" style="zoom:67%;" /></p></li>
<li><p>AR（p）</p>
<p><img src="../images/image-20220112194740776.png" alt="image-20220112194740776" style="zoom:67%;" /></p></li>
</ul>
<h4 id="协方差">协方差</h4>
<h4 id="相关系数">相关系数</h4>
<h4 id="自相关系数-1">自相关系数</h4>
<h4 id="偏自相关系数">偏自相关系数</h4>
<p>偏自相关系数的p阶截尾性</p>
<p><img src="../images/image-20220112201801274.png" alt="image-20220112201801274" style="zoom:67%;" /></p>
<h2 id="ma模型">MA模型</h2>
<p><img src="../images/image-20220112195630529.png" alt="image-20220112195630529" style="zoom:67%;" /></p>
<h3 id="用延迟算子表达ma模型">用延迟算子表达MA模型</h3>
<p><img src="../images/image-20220112200133896.png" alt="image-20220112200133896" style="zoom:67%;" /></p>
<h3 id="ma模型的统计性质">MA模型的统计性质</h3>
<p><img src="../images/image-20220112200412382.png" alt="image-20220112200412382" style="zoom:67%;" /></p>
<h4 id="自相关系数-2">自相关系数</h4>
<p><img src="../images/image-20220112200542423.png" alt="image-20220112200542423" style="zoom:67%;" /></p>
<h4 id="偏自相关系数-1">偏自相关系数</h4>
<p>MA模型的偏自相关系数拖尾</p>
<p><img src="../images/image-20220112204041577.png" alt="image-20220112204041577" style="zoom:67%;" /></p>
<h3 id="ma模型的可逆性">MA模型的可逆性</h3>
<p>不同的MA模型，可能具有完全相同的自相关系数的现象。产生这种现象的原因：自相关系数有可能不唯一。这种自相关系数的不唯一性，会给我们将来的工作增加麻烦。为了保证一个给定的自相关函数能够对应唯一的模型，我们就要给模型增加约束条件。称为模型的可逆性条件。</p>
<p>可逆MA模型定义：若一个MA模型能够表示成为收敛的AR模型形式，那么该MA模型称为可逆MA模型。</p>
<p>可逆概念的重要性：一个自相关系数列唯一对应一个可逆MA模型。</p>
<h3 id="ma模型的可逆条件">MA模型的可逆条件</h3>
<p><img src="../images/image-20220112202437807.png" alt="image-20220112202437807" style="zoom:67%;" /></p>
<figure>
<img src="../images/image-20220112202544566.png" alt="image-20220112202544566" /><figcaption aria-hidden="true">image-20220112202544566</figcaption>
</figure>
<h2 id="arma模型">ARMA模型</h2>
<figure>
<img src="../images/image-20220112202844889.png" alt="image-20220112202844889" /><figcaption aria-hidden="true">image-20220112202844889</figcaption>
</figure>
<h3 id="arma模型平稳条件与可逆条件">ARMA模型平稳条件与可逆条件</h3>
<figure>
<img src="../images/image-20220112203300774.png" alt="image-20220112203300774" /><figcaption aria-hidden="true">image-20220112203300774</figcaption>
</figure>
<h3 id="arma模型的统计性质">ARMA模型的统计性质</h3>
<figure>
<img src="../images/image-20220112203357885.png" alt="image-20220112203357885" /><figcaption aria-hidden="true">image-20220112203357885</figcaption>
</figure>
<h3 id="arma模型的相关性特征">ARMA模型的相关性特征</h3>
<table>
<thead>
<tr class="header">
<th>模型</th>
<th>自相关系数</th>
<th>偏自相关系数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AR（p）</td>
<td>拖尾</td>
<td>p阶截尾</td>
</tr>
<tr class="even">
<td>MA（q）</td>
<td>q阶截尾</td>
<td>拖尾</td>
</tr>
<tr class="odd">
<td>ARMA（p，q）</td>
<td>拖尾</td>
<td>拖尾</td>
</tr>
</tbody>
</table>
<h3 id="arma模型的建模步骤">ARMA模型的建模步骤</h3>
<figure>
<img src="../images/image-20220112203703973.png" alt="image-20220112203703973" /><figcaption aria-hidden="true">image-20220112203703973</figcaption>
</figure>
<h3 id="arma模型判断平稳性的方法">ARMA模型判断平稳性的方法</h3>
<p>单位根检验</p>
<p>计算样本相关系数（自相关、偏自相关）</p>
<h3 id="arma模型的参数估计方法">ARMA模型的参数估计方法</h3>
<figure>
<img src="../images/image-20220112204714695.png" alt="image-20220112204714695" /><figcaption aria-hidden="true">image-20220112204714695</figcaption>
</figure>
<p>常用估计方法</p>
<ul>
<li>矩估计</li>
<li>极大似然估计</li>
<li>最小二乘估计</li>
</ul>
<h4 id="矩估计">矩估计</h4>
<figure>
<img src="../images/image-20220112204853031.png" alt="image-20220112204853031" /><figcaption aria-hidden="true">image-20220112204853031</figcaption>
</figure>
<p>优点</p>
<ul>
<li>估计思想简单直观</li>
<li>不需要假设总体分布</li>
<li>计算量小（低阶模型场合）</li>
</ul>
<p>缺点</p>
<ul>
<li>信息浪费严重，只用到了p+q个样本自相关系数信息，其他信息都被忽略</li>
<li>估计精度差</li>
</ul>
<p>通常矩估计方法被用作极大似然估计和最小二乘估计迭代计算的初始值</p>
<h4 id="极大似然估计">极大似然估计</h4>
<figure>
<img src="../images/image-20220112205320988.png" alt="image-20220112205320988" /><figcaption aria-hidden="true">image-20220112205320988</figcaption>
</figure>
<p>优点</p>
<ul>
<li>极大似然估计充分应用了每一个观察值所提供的信息，因而它的估计精度高</li>
<li>同时还具有估计的一致性、渐近正态性和渐近有效性等许多优良的统计性质</li>
</ul>
<p>缺点</p>
<ul>
<li>需要假定总体分布</li>
</ul>
<h4 id="最小二乘估计">最小二乘估计</h4>
<p><img src="../images/image-20220112221513307.png" alt="image-20220112221513307" style="zoom: 80%;" /></p>
<p><img src="../images/image-20220112221603425.png" alt="image-20220112221603425" style="zoom:80%;" /></p>
<p>优点</p>
<ul>
<li>原理简单</li>
<li>方法普适</li>
<li>估计精度高</li>
</ul>
<h3 id="arma模型的显著性检验">ARMA模型的显著性检验</h3>
<p>目的：检验拟合模型的有效性（对相关信息的提取是否充分）</p>
<p>检验对象：残差序列</p>
<p>判定原则：一个好的拟合模型应该能够提取观察值序列中几乎所有的样本相关信息，即残差序列应该为白噪声序列。反之，如果残差序列为非白噪声序列，那就意味着残差序列中还残留着相关信息未被提取，这就说明拟合模型不够有效。</p>
<p><img src="../images/image-20220112222109937.png" alt="image-20220112222109937" style="zoom:80%;" /></p>
<h2 id="arima模型">ARIMA模型</h2>
<p>ARIMA模型中的I（ integrated ）的意思</p>
<p><img src="../images/image-20220113002722535.png" alt="image-20220113002722535" style="zoom: 67%;" /></p>
<p>ARIMA(0,1,0)就是随机漫步（random walk）模型，又称醉汉模型</p>
<h3 id="arima模型的性质">ARIMA模型的性质</h3>
<ul>
<li>非平稳性</li>
<li>异质方差性（方差非齐性）</li>
</ul>
<h3 id="arima模型的建模流程">ARIMA模型的建模流程</h3>
<p><img src="../images/image-20220113003959060.png" alt="image-20220113003959060" style="zoom:67%;" /></p>
<h2 id="sarima模型">SARIMA模型</h2>
<p><img src="../images/image-20220113004643096.png" alt="image-20220113004643096" style="zoom:67%;" /></p>
<p><img src="../images/image-20220113004659743.png" alt="image-20220113004659743" style="zoom:67%;" /></p>
<h3 id="sarima模型的建模流程">SARIMA模型的建模流程</h3>
<p><img src="../images/image-20220113004737244.png" alt="image-20220113004737244" style="zoom:67%;" /></p>
<h2 id="移动平均">移动平均</h2>
<h3 id="简单中心移动平均">简单中心移动平均</h3>
<p><img src="../images/image-20220113005142478.png" /></p>
<p>优点：</p>
<ul>
<li>能够提取低阶趋势（线性、二项）</li>
<li>能够实现拟合方差最小</li>
<li>按周期进行移动平均，能够消除季节性</li>
</ul>
<p>缺点：</p>
<ul>
<li>尾部少掉 s/2 的预测值</li>
<li>s 的确定</li>
</ul>
<h3 id="henderson加权移动平均">Henderson加权移动平均</h3>
<h3 id="musgrave非对称移动平均">Musgrave非对称移动平均</h3>
<h2 id="指数平滑">指数平滑</h2>
<h2 id="多元自回归模型">多元自回归模型</h2>
<h3 id="互相关函数">互相关函数</h3>
<h4 id="互协方差">互协方差</h4>
<p><img src="../images/image-20220113010214698.png" alt="image-20220113010214698" style="zoom:67%;" /></p>
<h4 id="互相关系数">互相关系数</h4>
<p><img src="../images/image-20220113010225345.png" alt="image-20220113010225345" style="zoom:67%;" /></p>
<h3 id="granger因果检验">Granger因果检验</h3>
<p>考察序列 {<span class="math inline">\(x_t\)</span>} 是否为序列 {<span class="math inline">\(y_t\)</span>} 的原因。如果序列 {<span class="math inline">\(x_t\)</span>} 是序列 {<span class="math inline">\(y_t\)</span>} 的原因，则 {<span class="math inline">\(x_t\)</span>} 将有助于预测 {<span class="math inline">\(y_t\)</span>} ，而 {<span class="math inline">\(y_t\)</span>} 不能有助于预测 {<span class="math inline">\(x_t\)</span>} 。</p>
<h3 id="单整">单整</h3>
<p>序列 {<span class="math inline">\(x_t\)</span>} 经过 <em>d</em> 阶差分达到平稳，称 {<span class="math inline">\(x_t\)</span>} 为 <em>d</em> 阶单整的(integration)。</p>
<h3 id="协整">协整</h3>
<p><img src="../images/image-20220113010626258.png" alt="image-20220113010626258" style="zoom: 80%;" /></p>
<p>EG 检验是 DF 检验的扩展(augmented Dickey–Fuller test for unit roots).</p>
<p><img src="../images/image-20220113010754134.png" alt="image-20220113010754134" style="zoom:80%;" /></p>
<h3 id="arimax模型">ARIMAX模型</h3>
<p><img src="../images/image-20220113010909122.png" alt="image-20220113010909122" style="zoom:80%;" /></p>
<h3 id="var模型">VAR模型</h3>
<p>多元自回归/向量自回归模型（Vector auto-regression model）</p>
<p>向量自回归模型把系统中每一个内生变量作为系统中所有内生变量的滞后值的函数来构造模型，从而将单变量自回归模型推广到由多元时间序列变量组成的“向量”自回归模型。简而言之，VAR模型就是把所有变量看成一个向量，然后做其对其滞后项的回归。</p>
<h2 id="案例">案例</h2>
<p>含有趋势性序列的建模</p>
<p>含有干扰点序列的建模</p>
<p>含有转折点序列的建模</p>
<p>含有缺失数据序列的建模</p>
<p>含有季节性序列的建模</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2022-01-14T16:00:00.000Z" itemprop="datePublished">2022/01/15</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" rel="tag">统计学</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  

  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%95%E9%A2%98/">试题</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI-NLP/" rel="tag">AI - NLP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KR/" rel="tag">KR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BB%E5%AD%A6/" rel="tag">医学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" rel="tag">统计学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%80%83%E7%A0%94/" rel="tag">考研</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">计算机 - 数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%95%B0%E6%8D%AE%E5%BA%93-Neo4j/" rel="tag">计算机 - 数据库 - Neo4j</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%BD%91%E7%BB%9C/" rel="tag">计算机 - 网络</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            NijiBlog &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Aomori</a>
        </div>
    </div>

</footer>

<script type="module" src="https://unpkg.com/ionicons@6.0.2/dist/ionicons/ionicons.esm.js"></script>






<script src="/dist/build.js?1654266144177.js"></script>


<script src="/dist/custom.js?1654266144177.js"></script>













</body>

</html>